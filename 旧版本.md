# 项目代码汇总

生成时间: 2026-01-05 13:13:33
文件总数: 36

---

## 文件: K Main_V3.py

```python
# K Main_V3.py (集成高清动态图标 + 多选标签逻辑)

import sys
import time
import os
from PyQt5.QtWidgets import QApplication, QMenu, QSystemTrayIcon, QDialog
from PyQt5.QtCore import QObject, Qt, QRectF
from PyQt5.QtGui import (QIcon, QPixmap, QPainter, QColor, QLinearGradient, 
                         QPainterPath, QPen, QBrush)
from PyQt5.QtNetwork import QLocalServer, QLocalSocket
from ui.quick_window import QuickWindow
from ui.main_window import MainWindow
from ui.ball import FloatingBall
from ui.action_popup import ActionPopup
from ui.common_tags_manager import CommonTagsManager
from ui.advanced_tag_selector import AdvancedTagSelector
from data.db_manager import DatabaseManager
from core.settings import load_setting
from core.logger import setup_logging, get_logger

SERVER_NAME = "K_KUAIJIBIJI_SINGLE_INSTANCE_SERVER"
logger = get_logger('Main')

# --- 新增：内置高清图标生成函数 ---
def create_internal_icon():
    """
    动态绘制高清(128x128)的“笔记本+钢笔”图标
    用于托盘、任务栏和窗口图标，保持视觉统一且无锯齿
    """
    size = 128
    pixmap = QPixmap(size, size)
    pixmap.fill(Qt.transparent)
    
    p = QPainter(pixmap)
    p.setRenderHint(QPainter.Antialiasing)
    p.setRenderHint(QPainter.HighQualityAntialiasing)
    p.setRenderHint(QPainter.SmoothPixmapTransform)
    
    # 居中坐标系
    p.translate(size / 2, size / 2)
    # 适当缩放以填满正方形空间
    p.scale(1.1, 1.1) 

    # 1. 绘制笔记本
    w, h = 56, 76
    
    # 页厚 (暖灰)
    p.setBrush(QColor(192, 192, 192)) 
    p.setPen(Qt.NoPen)
    p.drawRoundedRect(QRectF(-w/2+5, -h/2+4, w, h), 3, 3)
    
    # 封面 (Mocha Theme)
    grad = QLinearGradient(-w, -h, w, h)
    grad.setColorAt(0, QColor(70, 40, 35))   
    grad.setColorAt(1, QColor(100, 60, 50))  
    p.setBrush(grad)
    p.drawRoundedRect(QRectF(-w/2, -h/2, w, h), 3, 3)
    
    # 书签带
    p.setBrush(QColor(160, 30, 40))
    p.drawRect(QRectF(w/2 - 14, -h/2, 8, h))

    # 2. 绘制钢笔
    p.rotate(-45)
    p.translate(0, -8) 
    
    w_pen, h_pen = 14, 48 
    body_grad = QLinearGradient(-w_pen/2, 0, w_pen/2, 0)
    body_grad.setColorAt(0.0, QColor(200, 70, 80)) 
    body_grad.setColorAt(1.0, QColor(80, 10, 20)) 

    path_body = QPainterPath()
    path_body.addRoundedRect(QRectF(-w_pen/2, -h_pen/2, w_pen, h_pen), 6, 6)
    p.setBrush(body_grad)
    p.drawPath(path_body)
    
    # 笔尖
    path_tip = QPainterPath()
    tip_h = 16
    path_tip.moveTo(-w_pen/2 + 3, h_pen/2)
    path_tip.lineTo(w_pen/2 - 3, h_pen/2)
    path_tip.lineTo(0, h_pen/2 + tip_h)
    path_tip.closeSubpath()
    
    p.setBrush(QColor(255, 220, 100))
    p.drawPath(path_tip)
    
    # 笔环
    p.setBrush(QColor(255, 215, 0))
    p.drawRect(QRectF(-w_pen/2, h_pen/2 - 5, w_pen, 5))
    
    p.end()
    return QIcon(pixmap)


class AppManager(QObject):

    def __init__(self, app):
        super().__init__()
        self.app = app
        self.db_manager = None
        self.main_window = None
        self.quick_window = None
        self.ball = None
        self.popup = None 
        self.tray_icon = None
        self.tags_manager_dialog = None

    def start(self):
        logger.info("AppManager: 正在启动...")
        try:
            self.db_manager = DatabaseManager()
        except Exception as e:
            logger.critical(f"DB Error: {e}")
            sys.exit(1)

        # --- 核心修改：使用内置高清图标 ---
        # 优先使用生成的图标，不再依赖本地文件，确保样式统一且高清
        app_icon = create_internal_icon()
        self.app.setWindowIcon(app_icon)
        
        self.app.setApplicationName("RapidNotes")
        self.app.setApplicationDisplayName("RapidNotes")

        self._init_tray_icon(app_icon)

        self.main_window = MainWindow()
        self.main_window.closing.connect(self.on_main_window_closing)

        self.ball = FloatingBall(self.main_window)
        
        self.ball.request_show_quick_window.connect(self.show_quick_window)
        self.ball.double_clicked.connect(self.show_quick_window)
        self.ball.request_show_main_window.connect(self.show_main_window)
        self.ball.request_quit_app.connect(self.quit_application)
        self.ball.request_manage_tags.connect(self._open_common_tags_manager) 
        
        ball_pos = load_setting('floating_ball_pos')
        if ball_pos and isinstance(ball_pos, dict) and 'x' in ball_pos and 'y' in ball_pos:
            self.ball.move(ball_pos['x'], ball_pos['y'])
        else:
            g = QApplication.desktop().screenGeometry()
            self.ball.move(g.width()-80, g.height()//2)
            
        self.ball.show()

        self.quick_window = QuickWindow(self.db_manager)
        self.quick_window.toggle_main_window_requested.connect(self.toggle_main_window)
        
        self.popup = ActionPopup() 
        self.popup.request_favorite.connect(self._handle_popup_favorite)
        self.popup.request_tag_toggle.connect(self._handle_popup_tag_toggle)
        self.popup.request_manager.connect(self._open_common_tags_manager)
        
        self.quick_window.cm.data_captured.connect(self._on_clipboard_data_captured)
        
        self.show_quick_window()
        logger.info("AppManager: 启动完成")

    def _init_tray_icon(self, icon):
        self.tray_icon = QSystemTrayIcon(self.app)
        self.tray_icon.setIcon(icon)
        self.tray_icon.setToolTip("快速笔记")
        
        menu = QMenu()
        menu.setStyleSheet("""
            QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; }
            QMenu::item { padding: 6px 24px; }
            QMenu::item:selected { background-color: #4a90e2; color: white; }
        """)
        
        action_show = menu.addAction("显示主界面")
        action_show.triggered.connect(self.show_main_window)
        
        action_quick = menu.addAction("显示快速笔记")
        action_quick.triggered.connect(self.show_quick_window)
        
        menu.addSeparator()
        
        action_quit = menu.addAction("退出程序")
        action_quit.triggered.connect(self.quit_application)
        
        self.tray_icon.setContextMenu(menu)
        self.tray_icon.activated.connect(self._on_tray_icon_activated)
        self.tray_icon.show()

    def _on_tray_icon_activated(self, reason):
        if reason == QSystemTrayIcon.Trigger:
            self.show_quick_window()

    def _open_common_tags_manager(self):
        try:
            if self.tags_manager_dialog and self.tags_manager_dialog.isVisible():
                self._force_activate(self.tags_manager_dialog)
                return

            self.tags_manager_dialog = CommonTagsManager()
            self.tags_manager_dialog.finished.connect(self._on_tags_manager_closed)
            self.tags_manager_dialog.show()
            self._force_activate(self.tags_manager_dialog)
        except Exception as e:
            logger.error(f"TagManager Error: {e}")

    def _on_tags_manager_closed(self, result):
        if result == QDialog.Accepted:
            if self.popup:
                self.popup.common_tags_bar.reload_tags()
        self.tags_manager_dialog = None

    def _on_clipboard_data_captured(self, idea_id):
        try:
            logger.info(f"Clipboard Captured: ID {idea_id}")
            self.ball.trigger_clipboard_feedback()
            if self.popup:
                self.popup.show_at_mouse(idea_id)
        except Exception as e:
            logger.error(f"Capture Handler Error: {e}")

    def _handle_popup_favorite(self, idea_id, is_favorite):
        try:
            self.db_manager.set_favorite(idea_id, is_favorite)
            if self.main_window.isVisible():
                self.main_window._refresh_all()
            if self.quick_window.isVisible():
                self.quick_window._update_list()
        except Exception as e:
            logger.error(f"Fav Error: {e}")

    def _handle_popup_tag_toggle(self, idea_id, tag_name, checked):
        try:
            if checked:
                self.db_manager.add_tags_to_multiple_ideas([idea_id], [tag_name])
            else:
                self.db_manager.remove_tag_from_multiple_ideas([idea_id], tag_name)
                
            if self.main_window.isVisible():
                self.main_window._refresh_all()
            if self.quick_window.isVisible():
                self.quick_window._update_list()
        except Exception as e:
            logger.error(f"Tag Toggle Error: {e}")

    def _force_activate(self, window):
        if not window: return
        window.show()
        if window.isMinimized():
            window.setWindowState(window.windowState() & ~Qt.WindowMinimized | Qt.WindowActive)
            window.showNormal()
        window.raise_()
        window.activateWindow()

    def show_quick_window(self):
        self._force_activate(self.quick_window)

    def toggle_quick_window(self):
        if self.quick_window and self.quick_window.isVisible():
            self.quick_window.hide()
        else:
            self.show_quick_window()

    def show_main_window(self):
        self._force_activate(self.main_window)

    def toggle_main_window(self):
        if self.main_window.isVisible() and not self.main_window.isMinimized():
            self.main_window.hide()
        else:
            self.show_main_window()

    def on_main_window_closing(self):
        if self.main_window:
            self.main_window.hide()
            
    def quit_application(self):
        logger.info("App: 准备退出...")
        if self.quick_window:
            try: self.quick_window.save_state()
            except: pass
        if self.main_window:
            try: self.main_window.save_state()
            except: pass
        self.app.quit()

def main():
    setup_logging()
    
    app = QApplication(sys.argv)
    
    socket = QLocalSocket()
    socket.connectToServer(SERVER_NAME)
    if socket.waitForConnected(500):
        socket.write(b'SHOW')
        socket.flush()
        socket.waitForBytesWritten(1000)
        socket.disconnectFromServer()
        sys.exit(0)
    else:
        QLocalServer.removeServer(SERVER_NAME)

    server = QLocalServer()
    if not server.listen(SERVER_NAME):
        pass
    
    manager = AppManager(app)

    def handle_new_connection():
        conn = server.nextPendingConnection()
        if conn and conn.waitForReadyRead(500):
            msg = conn.readAll().data().decode()
            if msg == 'SHOW':
                manager.show_quick_window()
            elif msg == 'EXIT':
                manager.quit_application()
    server.newConnection.connect(handle_new_connection)
    
    manager.start()
    
    exit_code = app.exec_()
    logger.info(f"App: 退出码 {exit_code}")
    sys.exit(exit_code)

if __name__ == '__main__':
    main()
```

## 文件: core\config.py

```python
# core/config.py
DB_NAME = 'ideas.db'
BACKUP_DIR = 'backups'

COLORS = {
    'primary': '#4a90e2',   # 核心蓝 (UI按钮、高亮)
    'success': '#2ecc71',   # 成功绿
    'warning': '#f39c12',   # 警告黄 (偏橙黄)
    'danger':  '#e74c3c',   # 危险红
    'info':    '#9b59b6',   # 信息紫
    'teal':    '#1abc9c',   # 青色
    
    # 【新增】明确定义的橙色 - 用于新建编辑窗口默认
    'orange':  '#FF8C00',   # 深橙色
    
    # 【修改】默认笔记颜色 (深灰色) - 用于剪贴板自动抓取
    'default_note': '#2d2d2d', 
    
    # 【新增】状态颜色定义
    'trash': '#2d2d2d',          # 回收站默认颜色 (同默认深灰)
    'uncategorized': '#0A362F',  # 还原/未分类默认颜色 (深青色)

    'bg_dark': '#1e1e1e',   # 窗口背景 (最深)
    'bg_mid':  '#252526',   # 侧边栏/输入框背景 (次深)
    'bg_light': '#333333',  # 边框/分割线
    
    'text':    '#cccccc',   # 主文本
    'text_sub': '#858585'   # 副文本
}

STYLES = {
    # === 主窗口结构 ===
    'main_window': f"""
        QWidget {{ background-color: {COLORS['bg_dark']}; color: {COLORS['text']}; font-family: "Microsoft YaHei", "Segoe UI", sans-serif; }}
        QSplitter::handle {{ background-color: {COLORS['bg_light']}; }}
        /* 滚动条美化 V2 */
        QScrollBar:vertical {{
            border: none;
            background: transparent; /* 背景透明 */
            width: 8px; /* 变细一点 */
            margin: 0px;
        }}
        QScrollBar::handle:vertical {{
            background: #555; /* 滑块颜色 */
            min-height: 25px;
            border-radius: 4px; /* 圆角 */
        }}
        QScrollBar::handle:vertical:hover {{
            background: #666; /* 悬停时颜色 */
        }}
        QScrollBar::handle:vertical:pressed {{
            background: {COLORS['primary']}; /* 按下时颜色 */
        }}
        /* 上下箭头按钮不显示 */
        QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {{
            height: 0px;
        }}
        /* 滑道不显示 */
        QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {{
            background: none;
        }}
    """,
    
    # === 侧边栏 ===
    'sidebar': f"""
        QTreeWidget {{
            background-color: {COLORS['bg_mid']};
            color: #ddd;
            border: none;
            font-size: 13px;
            padding: 8px;
            outline: none;
        }}
        QTreeWidget::item {{
            height: 30px;
            padding: 2px 4px;
            border-radius: 4px;
            margin-bottom: 2px;
        }}
        QTreeWidget::item:hover {{ background-color: #2a2d2e; }}
        QTreeWidget::item:selected {{ background-color: #37373d; color: white; }}
    """,
    
    # === 弹窗通用样式 ===
    'dialog': f"""
        QDialog {{ background-color: {COLORS['bg_dark']}; color: {COLORS['text']}; }}
        QLabel {{
            color: {COLORS['text_sub']};
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 4px;
        }}
        QLineEdit, QTextEdit, QComboBox {{
            background-color: {COLORS['bg_mid']};
            border: 1px solid #333;
            border-radius: 4px;
            padding: 8px;
            color: #eee;
            font-size: 13px;
            selection-background-color: {COLORS['primary']};
        }}
        QLineEdit:focus, QTextEdit:focus, QComboBox:focus {{
            border: 1px solid {COLORS['primary']};
            background-color: #2a2a2a;
        }}
        QComboBox {{ padding-right: 20px; }}
        QComboBox::drop-down {{
            subcontrol-origin: padding;
            subcontrol-position: top right;
            width: 20px;
            border-left-width: 0px;
            border-top-right-radius: 4px;
            border-bottom-right-radius: 4px;
        }}
        QComboBox::down-arrow {{
            width: 0; 
            height: 0; 
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 5px solid #888;
            margin-right: 6px;
        }}
        QComboBox QAbstractItemView {{
            border: 1px solid {COLORS['primary']};
            background-color: {COLORS['bg_mid']};
            color: #eee;
            selection-background-color: {COLORS['primary']};
            selection-color: white;
            outline: none;
            padding: 4px;
        }}
    """,
    
    'btn_primary': f"""
        QPushButton {{
            background-color: {COLORS['primary']};
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 13px;
        }}
        QPushButton:hover {{ background-color: #357abd; }}
        QPushButton:pressed {{ background-color: #2a5d8f; }}
    """,

    'btn_icon': f"""
        QPushButton {{
            background-color: {COLORS['bg_light']};
            border: 1px solid #444;
            border-radius: 4px;
            min-width: 32px;
            min-height: 32px;
        }}
        QPushButton:hover {{ background-color: {COLORS['primary']}; border-color: {COLORS['primary']}; }}
        QPushButton:pressed {{ background-color: #2a5d8f; }}
        QPushButton:disabled {{ background-color: #252526; color: #555; border-color: #333; }}
    """,
    
    'input': f"""
        QLineEdit {{
            background-color: {COLORS['bg_mid']};
            border: 1px solid {COLORS['bg_light']};
            border-radius: 16px;
            padding: 6px 12px;
            color: #eee;
            font-size: 13px;
        }}
        QLineEdit:focus {{ border: 1px solid {COLORS['primary']}; }}
        QLineEdit::clear-button {{
            background: transparent;
            border-radius: 9px;
            margin-right: 4px;
        }}
        QLineEdit::clear-button:hover {{
            background: #555;
        }}
    """,
    
    'card_base': "border-radius: 12px;"
}
```

## 文件: core\enums.py

```python
# core/enums.py
from enum import Enum

class FilterType(Enum):
    ALL = "all"
    TODAY = "today"
    CATEGORY = "category"
    CLIPBOARD = "clipboard"
    UNCATEGORIZED = "uncategorized"
    UNTAGGED = "untagged"
    FAVORITE = "favorite"
    TRASH = "trash"
```

## 文件: core\logger.py

```python

import logging
import sys
from logging.handlers import RotatingFileHandler

def setup_logging():
    logger = logging.getLogger('RapidNotes')
    logger.setLevel(logging.DEBUG)

    # Prevent adding handlers multiple times
    if logger.hasHandlers():
        logger.handlers.clear()

    # Formatter
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - [%(filename)s:%(lineno)d] - %(message)s'
    )

    # Console Handler
    stdout_handler = logging.StreamHandler(sys.stdout)
    stdout_handler.setLevel(logging.DEBUG)
    stdout_handler.setFormatter(formatter)
    logger.addHandler(stdout_handler)

    # File Handler
    file_handler = RotatingFileHandler(
        'app_run.log', maxBytes=1024 * 1024 * 5, backupCount=5, encoding='utf-8'
    )
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)

    logger.info("日志服务初始化成功。")

def get_logger(name):
    return logging.getLogger(name)

```

## 文件: core\settings.py

```python
# core/settings.py
import json
import os

SETTINGS_FILE = 'settings.json'

def save_setting(key, value):
    """保存单个设置项到 JSON 文件"""
    settings = {}
    if os.path.exists(SETTINGS_FILE):
        try:
            with open(SETTINGS_FILE, 'r', encoding='utf-8') as f:
                settings = json.load(f)
        except (json.JSONDecodeError, IOError):
            # 如果文件存在但为空或损坏，则忽略
            pass
    
    settings[key] = value
    
    try:
        with open(SETTINGS_FILE, 'w', encoding='utf-8') as f:
            json.dump(settings, f, indent=4)
        # print(f"[Settings] 已保存 '{key}': {value}")
        pass
    except IOError as e:
        # print(f"[Settings] 错误：无法写入设置文件 {SETTINGS_FILE}: {e}")
        pass

def load_setting(key, default=None):
    """从 JSON 文件加载单个设置项"""
    if not os.path.exists(SETTINGS_FILE):
        return default
        
    try:
        with open(SETTINGS_FILE, 'r', encoding='utf-8') as f:
            settings = json.load(f)
            value = settings.get(key, default)
            # print(f"[Settings] 已加载 '{key}': {value}")
            pass
            return value
    except (json.JSONDecodeError, IOError) as e:
        # print(f"[Settings] 错误：无法读取设置文件 {SETTINGS_FILE}: {e}")
        pass
        return default
```

## 文件: core\__init__.py

```python
﻿# -*- coding: utf-8 -*-

```

## 文件: data\db_manager.py

```python
# -*- coding: utf-8 -*-
# data/db_manager.py
import sqlite3
import hashlib
import os
import random
from core.config import DB_NAME, COLORS

class DatabaseManager:
    def __init__(self):
        self.conn = sqlite3.connect(DB_NAME)
        self._init_schema()
        # 【维护】启动时仅修正回收站数据的格式
        self._fix_trash_consistency()

    def _init_schema(self):
        c = self.conn.cursor()
        
        c.execute(f'''CREATE TABLE IF NOT EXISTS ideas (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            title TEXT NOT NULL, content TEXT, color TEXT DEFAULT '{COLORS['default_note']}',
            is_pinned INTEGER DEFAULT 0, is_favorite INTEGER DEFAULT 0,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            category_id INTEGER, is_deleted INTEGER DEFAULT 0
        )''')
        c.execute('CREATE TABLE IF NOT EXISTS tags (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT UNIQUE NOT NULL)')
        c.execute('''CREATE TABLE IF NOT EXISTS categories (
            id INTEGER PRIMARY KEY AUTOINCREMENT, 
            name TEXT NOT NULL, 
            parent_id INTEGER, 
            color TEXT DEFAULT "#808080",
            sort_order INTEGER DEFAULT 0
        )''')
        c.execute('CREATE TABLE IF NOT EXISTS idea_tags (idea_id INTEGER, tag_id INTEGER, PRIMARY KEY (idea_id, tag_id))')
        
        # 检查并补充字段
        c.execute("PRAGMA table_info(ideas)")
        cols = [i[1] for i in c.fetchall()]
        
        updates = [
            ('category_id', 'INTEGER'),
            ('is_deleted', 'INTEGER DEFAULT 0'),
            ('item_type', "TEXT DEFAULT 'text'"),
            ('data_blob', 'BLOB'),
            ('content_hash', 'TEXT'),
            ('is_locked', 'INTEGER DEFAULT 0')
        ]
        
        for col, type_def in updates:
            if col not in cols:
                try: c.execute(f'ALTER TABLE ideas ADD COLUMN {col} {type_def}')
                except: pass
        
        if 'content_hash' not in cols:
            try: c.execute('CREATE INDEX IF NOT EXISTS idx_content_hash ON ideas(content_hash)')
            except: pass
        
        c.execute("PRAGMA table_info(categories)")
        cat_cols = [i[1] for i in c.fetchall()]
        if 'sort_order' not in cat_cols:
            try: c.execute('ALTER TABLE categories ADD COLUMN sort_order INTEGER DEFAULT 0')
            except: pass
        if 'preset_tags' not in cat_cols:
            try: c.execute('ALTER TABLE categories ADD COLUMN preset_tags TEXT')
            except: pass

        # --- FTS5 全文搜索支持 ---
        try:
            # 1. 创建虚拟表
            c.execute('''CREATE VIRTUAL TABLE IF NOT EXISTS ideas_fts USING fts5(
                title, content, content_rowid='id'
            )''')
            
            # 2. 检查是否需要重建索引
            c.execute("SELECT COUNT(*) FROM ideas_fts")
            fts_count = c.fetchone()[0]
            c.execute("SELECT COUNT(*) FROM ideas")
            ideas_count = c.fetchone()[0]
            
            if ideas_count > 0 and fts_count == 0:
                print("Building FTS index...")
                c.execute("INSERT INTO ideas_fts(rowid, title, content) SELECT id, title, content FROM ideas")

            # 3. 创建触发器：插入时同步
            c.execute('''CREATE TRIGGER IF NOT EXISTS ideas_ai AFTER INSERT ON ideas BEGIN
                INSERT INTO ideas_fts(rowid, title, content) VALUES (new.id, new.title, new.content);
            END''')
            
            # 4. 创建触发器：删除时同步
            c.execute('''CREATE TRIGGER IF NOT EXISTS ideas_ad AFTER DELETE ON ideas BEGIN
                INSERT INTO ideas_fts(ideas_fts, rowid, title, content) VALUES('delete', old.id, old.title, old.content);
            END''')
            
            # 5. 创建触发器：更新时同步
            c.execute('''CREATE TRIGGER IF NOT EXISTS ideas_au AFTER UPDATE ON ideas BEGIN
                INSERT INTO ideas_fts(ideas_fts, rowid, title, content) VALUES('delete', old.id, old.title, old.content);
                INSERT INTO ideas_fts(rowid, title, content) VALUES (new.id, new.title, new.content);
            END''')
            
        except Exception as e:
            # 如果环境不支持 FTS5，静默失败
            pass
            
        self.conn.commit()

    def _fix_trash_consistency(self):
        try:
            c = self.conn.cursor()
            trash_color = COLORS.get('trash', '#2d2d2d')
            c.execute('''
                UPDATE ideas 
                SET category_id = NULL, color = ? 
                WHERE is_deleted = 1 AND (category_id IS NOT NULL OR color != ?)
            ''', (trash_color, trash_color))
            self.conn.commit()
        except Exception as e:
            pass

    def empty_trash(self):
        c = self.conn.cursor()
        c.execute('DELETE FROM idea_tags WHERE idea_id IN (SELECT id FROM ideas WHERE is_deleted=1)')
        c.execute('DELETE FROM ideas WHERE is_deleted=1')
        self.conn.commit()

    def set_locked(self, idea_ids, state):
        if not idea_ids: return
        c = self.conn.cursor()
        val = 1 if state else 0
        placeholders = ','.join('?' * len(idea_ids))
        c.execute(f'UPDATE ideas SET is_locked=? WHERE id IN ({placeholders})', (val, *idea_ids))
        self.conn.commit()

    def get_lock_status(self, idea_ids):
        if not idea_ids: return {}
        c = self.conn.cursor()
        placeholders = ','.join('?' * len(idea_ids))
        c.execute(f'SELECT id, is_locked FROM ideas WHERE id IN ({placeholders})', tuple(idea_ids))
        return dict(c.fetchall())

    def add_idea(self, title, content, color=None, tags=[], category_id=None, item_type='text', data_blob=None):
        if color is None: color = COLORS['default_note']
        c = self.conn.cursor()
        c.execute(
            'INSERT INTO ideas (title, content, color, category_id, item_type, data_blob) VALUES (?,?,?,?,?,?)',
            (title, content, color, category_id, item_type, data_blob)
        )
        iid = c.lastrowid
        self._update_tags(iid, tags)
        self.conn.commit()
        return iid

    def update_idea(self, iid, title, content, color, tags, category_id=None, item_type='text', data_blob=None):
        c = self.conn.cursor()
        c.execute(
            'UPDATE ideas SET title=?, content=?, color=?, category_id=?, item_type=?, data_blob=?, updated_at=CURRENT_TIMESTAMP WHERE id=?',
            (title, content, color, category_id, item_type, data_blob, iid)
        )
        self._update_tags(iid, tags)
        self.conn.commit()

    def _update_tags(self, iid, tags):
        c = self.conn.cursor()
        c.execute('DELETE FROM idea_tags WHERE idea_id=?', (iid,))
        if not tags: return
        for t in tags:
            t = t.strip()
            if t:
                c.execute('INSERT OR IGNORE INTO tags (name) VALUES (?)', (t,))
                c.execute('SELECT id FROM tags WHERE name=?', (t,))
                tid = c.fetchone()[0]
                c.execute('INSERT INTO idea_tags VALUES (?,?)', (iid, tid))

    def _append_tags(self, iid, tags):
        c = self.conn.cursor()
        for t in tags:
            t = t.strip()
            if t:
                c.execute('INSERT OR IGNORE INTO tags (name) VALUES (?)', (t,))
                c.execute('SELECT id FROM tags WHERE name=?', (t,))
                tid = c.fetchone()[0]
                c.execute('INSERT OR IGNORE INTO idea_tags VALUES (?,?)', (iid, tid))

    def add_tags_to_multiple_ideas(self, idea_ids, tags_list):
        if not idea_ids or not tags_list: return
        c = self.conn.cursor()
        for tag_name in tags_list:
            tag_name = tag_name.strip()
            if not tag_name: continue
            c.execute('INSERT OR IGNORE INTO tags (name) VALUES (?)', (tag_name,))
            c.execute('SELECT id FROM tags WHERE name=?', (tag_name,))
            tid = c.fetchone()[0]
            for iid in idea_ids:
                c.execute('INSERT OR IGNORE INTO idea_tags (idea_id, tag_id) VALUES (?,?)', (iid, tid))
        self.conn.commit()

    def remove_tag_from_multiple_ideas(self, idea_ids, tag_name):
        if not idea_ids or not tag_name: return
        c = self.conn.cursor()
        c.execute('SELECT id FROM tags WHERE name=?', (tag_name,))
        res = c.fetchone()
        if not res: return
        tid = res[0]
        placeholders = ','.join('?' * len(idea_ids))
        sql = f'DELETE FROM idea_tags WHERE tag_id=? AND idea_id IN ({placeholders})'
        c.execute(sql, (tid, *idea_ids))
        self.conn.commit()

    def get_union_tags(self, idea_ids):
        if not idea_ids: return []
        c = self.conn.cursor()
        placeholders = ','.join('?' * len(idea_ids))
        sql = f'''
            SELECT DISTINCT t.name 
            FROM tags t 
            JOIN idea_tags it ON t.id = it.tag_id 
            WHERE it.idea_id IN ({placeholders})
            ORDER BY t.name ASC
        '''
        c.execute(sql, tuple(idea_ids))
        return [r[0] for r in c.fetchall()]

    def add_clipboard_item(self, item_type, content, data_blob=None, category_id=None):
        c = self.conn.cursor()
        hasher = hashlib.sha256()
        if item_type == 'text' or item_type == 'file':
            hasher.update(content.encode('utf-8'))
        elif item_type == 'image' and data_blob:
            hasher.update(data_blob)
        content_hash = hasher.hexdigest()

        c.execute("SELECT id FROM ideas WHERE content_hash = ?", (content_hash,))
        existing_idea = c.fetchone()

        if existing_idea:
            idea_id = existing_idea[0]
            c.execute("UPDATE ideas SET updated_at = CURRENT_TIMESTAMP WHERE id = ?", (idea_id,))
            self.conn.commit()
            return idea_id, False 
        else:
            if item_type == 'text':
                title = content.strip().split('\n')[0][:50]
            elif item_type == 'image':
                title = "[图片]"
            elif item_type == 'file':
                title = f"[文件] {os.path.basename(content.split(';')[0])}"
            else:
                title = "未命名"

            default_color = COLORS['default_note']
            c.execute(
                'INSERT INTO ideas (title, content, item_type, data_blob, category_id, content_hash, color) VALUES (?,?,?,?,?,?,?)',
                (title, content, item_type, data_blob, category_id, content_hash, default_color)
            )
            idea_id = c.lastrowid
            
            self._update_tags(idea_id, ["剪贴板"])
            self.conn.commit()
            return idea_id, True

    def toggle_field(self, iid, field):
        c = self.conn.cursor()
        c.execute(f'UPDATE ideas SET {field} = NOT {field} WHERE id=?', (iid,))
        self.conn.commit()

    def set_deleted(self, iid, state):
        c = self.conn.cursor()
        if state:
            trash_color = COLORS.get('trash', '#2d2d2d')
            c.execute(
                'UPDATE ideas SET is_deleted=1, category_id=NULL, color=?, updated_at=CURRENT_TIMESTAMP WHERE id=?', 
                (trash_color, iid)
            )
        else:
            uncat_color = COLORS.get('uncategorized', '#0A362F')
            c.execute(
                'UPDATE ideas SET is_deleted=0, category_id=NULL, color=?, updated_at=CURRENT_TIMESTAMP WHERE id=?', 
                (uncat_color, iid)
            )
        self.conn.commit()

    def set_favorite(self, iid, state):
        c = self.conn.cursor()
        c.execute('UPDATE ideas SET is_favorite=? WHERE id=?', (1 if state else 0, iid))
        self.conn.commit()

    def move_category(self, iid, cat_id):
        c = self.conn.cursor()
        c.execute('UPDATE ideas SET category_id=?, is_deleted=0 WHERE id=?', (cat_id, iid))
        if cat_id is not None:
            c.execute('SELECT color, preset_tags FROM categories WHERE id=?', (cat_id,))
            result = c.fetchone()
            if result:
                cat_color = result[0]
                preset_tags_str = result[1]
                if cat_color:
                    c.execute('UPDATE ideas SET color=? WHERE id=?', (cat_color, iid))
                if preset_tags_str:
                    tags_list = [t.strip() for t in preset_tags_str.split(',') if t.strip()]
                    if tags_list:
                        self._append_tags(iid, tags_list)
        else:
            uncat_color = COLORS.get('uncategorized', '#0A362F')
            c.execute('UPDATE ideas SET color=? WHERE id=?', (uncat_color, iid))
        self.conn.commit()

    def delete_permanent(self, iid):
        c = self.conn.cursor()
        c.execute('DELETE FROM ideas WHERE id=?', (iid,))
        self.conn.commit()

    def get_idea(self, iid, include_blob=False):
        c = self.conn.cursor()
        if include_blob:
            c.execute('SELECT * FROM ideas WHERE id=?', (iid,))
        else:
            c.execute('''
                SELECT id, title, content, color, is_pinned, is_favorite, 
                       created_at, updated_at, category_id, is_deleted, item_type, 
                       NULL as data_blob, NULL as content_hash, is_locked 
                FROM ideas WHERE id=?
            ''', (iid,))
        return c.fetchone()

    def get_ideas(self, search, f_type, f_val, page=None, page_size=20, tag_filter=None):
        c = self.conn.cursor()
        
        # 使用 FTS 优化查询逻辑
        q = """
            SELECT DISTINCT 
                i.id, i.title, i.content, i.color, i.is_pinned, i.is_favorite, 
                i.created_at, i.updated_at, i.category_id, i.is_deleted, 
                i.item_type, i.data_blob, i.content_hash, i.is_locked
            FROM ideas i 
            LEFT JOIN idea_tags it ON i.id=it.idea_id 
            LEFT JOIN tags t ON it.tag_id=t.id 
        """
        
        # 如果有搜索词，关联 FTS 表
        if search:
            q += " JOIN ideas_fts f ON i.id = f.rowid "
            
        q += " WHERE 1=1 "
        p = []
        
        if f_type == 'trash': q += ' AND i.is_deleted=1'
        else: q += ' AND (i.is_deleted=0 OR i.is_deleted IS NULL)'
        
        if f_type == 'category':
            if f_val is None: q += ' AND i.category_id IS NULL'
            else: q += ' AND i.category_id=?'; p.append(f_val)
        elif f_type == 'today': q += " AND date(i.updated_at,'localtime')=date('now','localtime')"
        elif f_type == 'clipboard': q += " AND i.id IN (SELECT idea_id FROM idea_tags WHERE tag_id = (SELECT id FROM tags WHERE name = '剪贴板'))"
        elif f_type == 'untagged': q += ' AND i.id NOT IN (SELECT idea_id FROM idea_tags)'
        elif f_type == 'favorite': q += ' AND i.is_favorite=1'
        
        if tag_filter:
            q += " AND i.id IN (SELECT idea_id FROM idea_tags WHERE tag_id = (SELECT id FROM tags WHERE name = ?))"
            p.append(tag_filter)
        
        if search:
            search_query = f'"{search}"' if " " in search else f"{search}*" 
            q += " AND ideas_fts MATCH ?"
            p.append(search_query)
            
        if f_type == 'trash':
            q += ' ORDER BY i.updated_at DESC'
        else:
            q += ' ORDER BY i.is_pinned DESC, i.updated_at DESC'
            
        if page is not None and page_size is not None:
            limit = page_size
            offset = (page - 1) * page_size
            q += ' LIMIT ? OFFSET ?'
            p.extend([limit, offset])
            
        try:
            c.execute(q, p)
            return c.fetchall()
        except sqlite3.OperationalError:
            return self._get_ideas_fallback(search, f_type, f_val, page, page_size, tag_filter)

    def _get_ideas_fallback(self, search, f_type, f_val, page, page_size, tag_filter):
        c = self.conn.cursor()
        q = """
            SELECT DISTINCT 
                i.id, i.title, i.content, i.color, i.is_pinned, i.is_favorite, 
                i.created_at, i.updated_at, i.category_id, i.is_deleted, 
                i.item_type, i.data_blob, i.content_hash, i.is_locked
            FROM ideas i 
            LEFT JOIN idea_tags it ON i.id=it.idea_id 
            LEFT JOIN tags t ON it.tag_id=t.id 
            WHERE 1=1
        """
        p = []
        if f_type == 'trash': q += ' AND i.is_deleted=1'
        else: q += ' AND (i.is_deleted=0 OR i.is_deleted IS NULL)'
        
        if f_type == 'category':
            if f_val is None: q += ' AND i.category_id IS NULL'
            else: q += ' AND i.category_id=?'; p.append(f_val)
        elif f_type == 'today': q += " AND date(i.updated_at,'localtime')=date('now','localtime')"
        elif f_type == 'clipboard': q += " AND i.id IN (SELECT idea_id FROM idea_tags WHERE tag_id = (SELECT id FROM tags WHERE name = '剪贴板'))"
        elif f_type == 'untagged': q += ' AND i.id NOT IN (SELECT idea_id FROM idea_tags)'
        elif f_type == 'favorite': q += ' AND i.is_favorite=1'
        
        if tag_filter:
            q += " AND i.id IN (SELECT idea_id FROM idea_tags WHERE tag_id = (SELECT id FROM tags WHERE name = ?))"
            p.append(tag_filter)
        
        if search:
            q += ' AND (i.title LIKE ? OR i.content LIKE ? OR t.name LIKE ?)'
            p.extend([f'%{search}%']*3)
            
        if f_type == 'trash': q += ' ORDER BY i.updated_at DESC'
        else: q += ' ORDER BY i.is_pinned DESC, i.updated_at DESC'
            
        if page is not None and page_size is not None:
            limit = page_size
            offset = (page - 1) * page_size
            q += ' LIMIT ? OFFSET ?'
            p.extend([limit, offset])
        
        c.execute(q, p)
        return c.fetchall()

    def get_ideas_count(self, search, f_type, f_val, tag_filter=None):
        c = self.conn.cursor()
        
        q = "SELECT COUNT(DISTINCT i.id) FROM ideas i "
        if search: q += " JOIN ideas_fts f ON i.id = f.rowid "
        else: q += " LEFT JOIN idea_tags it ON i.id=it.idea_id LEFT JOIN tags t ON it.tag_id=t.id "
        
        q += " WHERE 1=1 "
        p = []
        
        if f_type == 'trash': q += ' AND i.is_deleted=1'
        else: q += ' AND (i.is_deleted=0 OR i.is_deleted IS NULL)'
        
        if f_type == 'category':
            if f_val is None: q += ' AND i.category_id IS NULL'
            else: q += ' AND i.category_id=?'; p.append(f_val)
        elif f_type == 'today': q += " AND date(i.updated_at,'localtime')=date('now','localtime')"
        elif f_type == 'clipboard': q += " AND i.id IN (SELECT idea_id FROM idea_tags WHERE tag_id = (SELECT id FROM tags WHERE name = '剪贴板'))"
        elif f_type == 'untagged': q += ' AND i.id NOT IN (SELECT idea_id FROM idea_tags)'
        elif f_type == 'favorite': q += ' AND i.is_favorite=1'
        
        if tag_filter:
            q += " AND i.id IN (SELECT idea_id FROM idea_tags WHERE tag_id = (SELECT id FROM tags WHERE name = ?))"
            p.append(tag_filter)
            
        if search:
            search_query = f'"{search}"' if " " in search else f"{search}*" 
            q += " AND ideas_fts MATCH ?"
            p.append(search_query)
        elif search: 
             q += ' AND (i.title LIKE ? OR i.content LIKE ?)'
             p.extend([f'%{search}%']*2)

        try:
            c.execute(q, p)
            return c.fetchone()[0]
        except sqlite3.OperationalError:
            return self._get_ideas_count_fallback(search, f_type, f_val, tag_filter)

    def _get_ideas_count_fallback(self, search, f_type, f_val, tag_filter=None):
        c = self.conn.cursor()
        q = "SELECT COUNT(DISTINCT i.id) FROM ideas i LEFT JOIN idea_tags it ON i.id=it.idea_id LEFT JOIN tags t ON it.tag_id=t.id WHERE 1=1"
        p = []
        if f_type == 'trash': q += ' AND i.is_deleted=1'
        else: q += ' AND (i.is_deleted=0 OR i.is_deleted IS NULL)'
        if f_type == 'category':
            if f_val is None: q += ' AND i.category_id IS NULL'
            else: q += ' AND i.category_id=?'; p.append(f_val)
        elif f_type == 'today': q += " AND date(i.updated_at,'localtime')=date('now','localtime')"
        elif f_type == 'clipboard': q += " AND i.id IN (SELECT idea_id FROM idea_tags WHERE tag_id = (SELECT id FROM tags WHERE name = '剪贴板'))"
        elif f_type == 'untagged': q += ' AND i.id NOT IN (SELECT idea_id FROM idea_tags)'
        elif f_type == 'favorite': q += ' AND i.is_favorite=1'
        if tag_filter:
            q += " AND i.id IN (SELECT idea_id FROM idea_tags WHERE tag_id = (SELECT id FROM tags WHERE name = ?))"
            p.append(tag_filter)
        if search:
            q += ' AND (i.title LIKE ? OR i.content LIKE ? OR t.name LIKE ?)'
            p.extend([f'%{search}%']*3)
        c.execute(q, p)
        return c.fetchone()[0]

    def get_tags(self, iid):
        c = self.conn.cursor()
        c.execute('SELECT t.name FROM tags t JOIN idea_tags it ON t.id=it.tag_id WHERE it.idea_id=?', (iid,))
        return [r[0] for r in c.fetchall()]

    def get_all_tags(self):
        c = self.conn.cursor()
        c.execute('SELECT name FROM tags ORDER BY name')
        return [r[0] for r in c.fetchall()]

    def get_categories(self):
        c = self.conn.cursor()
        c.execute('SELECT * FROM categories ORDER BY sort_order ASC, name ASC')
        return c.fetchall()

    def add_category(self, name, parent_id=None):
        c = self.conn.cursor()
        if parent_id is None:
            c.execute("SELECT MAX(sort_order) FROM categories WHERE parent_id IS NULL")
        else:
            c.execute("SELECT MAX(sort_order) FROM categories WHERE parent_id = ?", (parent_id,))
        max_order = c.fetchone()[0]
        new_order = (max_order or 0) + 1
        
        palette = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEEAD',
            '#D4A5A5', '#9B59B6', '#3498DB', '#E67E22', '#2ECC71',
            '#E74C3C', '#F1C40F', '#1ABC9C', '#34495E', '#95A5A6'
        ]
        chosen_color = random.choice(palette)
        
        c.execute(
            'INSERT INTO categories (name, parent_id, sort_order, color) VALUES (?, ?, ?, ?)', 
            (name, parent_id, new_order, chosen_color)
        )
        self.conn.commit()

    def rename_category(self, cat_id, new_name):
        c = self.conn.cursor()
        c.execute('UPDATE categories SET name=? WHERE id=?', (new_name, cat_id))
        self.conn.commit()
    
    def set_category_color(self, cat_id, color):
        c = self.conn.cursor()
        c.execute('UPDATE categories SET color=? WHERE id=?', (color, cat_id))
        self.conn.commit()

    def set_category_preset_tags(self, cat_id, tags_str):
        c = self.conn.cursor()
        c.execute('UPDATE categories SET preset_tags=? WHERE id=?', (tags_str, cat_id))
        self.conn.commit()

    def get_category_preset_tags(self, cat_id):
        c = self.conn.cursor()
        c.execute('SELECT preset_tags FROM categories WHERE id=?', (cat_id,))
        res = c.fetchone()
        return res[0] if res else ""

    def apply_preset_tags_to_category_items(self, cat_id, tags_list):
        if not tags_list: return
        c = self.conn.cursor()
        c.execute('SELECT id FROM ideas WHERE category_id=? AND is_deleted=0', (cat_id,))
        items = c.fetchall()
        for (iid,) in items:
            self._append_tags(iid, tags_list)
        self.conn.commit()

    def delete_category(self, cid):
        c = self.conn.cursor()
        c.execute('UPDATE ideas SET category_id=NULL WHERE category_id=?', (cid,))
        c.execute('DELETE FROM categories WHERE id=?', (cid,))
        self.conn.commit()

    def get_counts(self):
        c = self.conn.cursor()
        d = {}
        queries = {
            'all': "is_deleted=0 OR is_deleted IS NULL",
            'today': "(is_deleted=0 OR is_deleted IS NULL) AND date(updated_at,'localtime')=date('now','localtime')",
            'clipboard': "(is_deleted=0 OR is_deleted IS NULL) AND id IN (SELECT idea_id FROM idea_tags WHERE tag_id = (SELECT id FROM tags WHERE name = '剪贴板'))",
            'uncategorized': "(is_deleted=0 OR is_deleted IS NULL) AND category_id IS NULL",
            'untagged': "(is_deleted=0 OR is_deleted IS NULL) AND id NOT IN (SELECT idea_id FROM idea_tags)",
            'favorite': "(is_deleted=0 OR is_deleted IS NULL) AND is_favorite=1",
            'trash': "is_deleted=1"
        }
        for k, v in queries.items():
            c.execute(f"SELECT COUNT(*) FROM ideas WHERE {v}")
            d[k] = c.fetchone()[0]
            
        c.execute("SELECT category_id, COUNT(*) FROM ideas WHERE (is_deleted=0 OR is_deleted IS NULL) GROUP BY category_id")
        d['categories'] = dict(c.fetchall())
        return d

    def get_top_tags(self):
        c = self.conn.cursor()
        c.execute('''SELECT t.name, COUNT(it.idea_id) as c FROM tags t 
                     JOIN idea_tags it ON t.id=it.tag_id JOIN ideas i ON it.idea_id=i.id 
                     WHERE i.is_deleted=0 GROUP BY t.id ORDER BY c DESC LIMIT 5''')
        return c.fetchall()

    def get_partitions_tree(self):
        class Partition:
            def __init__(self, id, name, color, parent_id, sort_order):
                self.id = id
                self.name = name
                self.color = color
                self.parent_id = parent_id
                self.sort_order = sort_order
                self.children = []

        c = self.conn.cursor()
        c.execute("SELECT id, name, color, parent_id, sort_order FROM categories ORDER BY sort_order ASC, name ASC")
        
        nodes = {row[0]: Partition(*row) for row in c.fetchall()}
        
        tree = []
        for node_id, node in nodes.items():
            if node.parent_id in nodes:
                nodes[node.parent_id].children.append(node)
            else:
                tree.append(node)
                
        return tree

    def get_partition_item_counts(self):
        c = self.conn.cursor()
        counts = {'partitions': {}}

        c.execute("SELECT COUNT(*) FROM ideas WHERE is_deleted=0")
        counts['total'] = c.fetchone()[0]

        c.execute("SELECT COUNT(*) FROM ideas WHERE is_deleted=0 AND date(updated_at, 'localtime') = date('now', 'localtime')")
        counts['today_modified'] = c.fetchone()[0]
        
        c.execute("SELECT category_id, COUNT(*) FROM ideas WHERE is_deleted=0 GROUP BY category_id")
        for cat_id, count in c.fetchall():
            if cat_id is not None:
                counts['partitions'][cat_id] = count

        # Add missing counts
        c.execute("SELECT COUNT(*) FROM ideas i JOIN idea_tags it ON i.id = it.idea_id JOIN tags t ON it.tag_id = t.id WHERE t.name = '剪贴板' AND i.is_deleted=0")
        counts['clipboard'] = c.fetchone()[0]

        c.execute("SELECT COUNT(*) FROM ideas WHERE is_favorite=1 AND is_deleted=0")
        counts['favorite'] = c.fetchone()[0]

        return counts
    
    def save_category_order(self, update_list):
        c = self.conn.cursor()
        try:
            c.execute("BEGIN TRANSACTION")
            for item in update_list:
                c.execute(
                    "UPDATE categories SET sort_order = ?, parent_id = ? WHERE id = ?",
                    (item['sort_order'], item['parent_id'], item['id'])
                )
            c.execute("COMMIT")
        except Exception as e:
            c.execute("ROLLBACK")
            pass
        finally:
            self.conn.commit()

    def rename_tag(self, old_name, new_name):
        new_name = new_name.strip()
        if not new_name or old_name == new_name: return
        c = self.conn.cursor()
        c.execute("SELECT id FROM tags WHERE name=?", (old_name,))
        old_res = c.fetchone()
        if not old_res: return
        old_id = old_res[0]
        c.execute("SELECT id FROM tags WHERE name=?", (new_name,))
        new_res = c.fetchone()
        try:
            if new_res:
                new_id = new_res[0]
                c.execute("UPDATE OR IGNORE idea_tags SET tag_id=? WHERE tag_id=?", (new_id, old_id))
                c.execute("DELETE FROM idea_tags WHERE tag_id=?", (old_id,))
                c.execute("DELETE FROM tags WHERE id=?", (old_id,))
            else:
                c.execute("UPDATE tags SET name=? WHERE id=?", (new_name, old_id))
            self.conn.commit()
        except Exception as e:
            self.conn.rollback()

    def delete_tag(self, tag_name):
        c = self.conn.cursor()
        c.execute("SELECT id FROM tags WHERE name=?", (tag_name,))
        res = c.fetchone()
        if res:
            tag_id = res[0]
            c.execute("DELETE FROM idea_tags WHERE tag_id=?", (tag_id,))
            c.execute("DELETE FROM tags WHERE id=?", (tag_id,))
            self.conn.commit()
```

## 文件: data\schema_migrations.py

```python
# data/schema_migrations.py
import logging

logger = logging.getLogger(__name__)

class SchemaMigration:
    @staticmethod
    def _get_db_version(conn):
        c = conn.cursor()
        try:
            c.execute("PRAGMA user_version")
            version = c.fetchone()[0]
            return version
        except Exception:
            # If user_version does not exist, it's a very old db, treat as version 0
            return 0

    @staticmethod
    def _set_db_version(conn, version):
        c = conn.cursor()
        c.execute(f"PRAGMA user_version = {version}")
        conn.commit()

    @staticmethod
    def apply(conn):
        logger.info("开始检查数据库结构迁移...")
        current_version = SchemaMigration._get_db_version(conn)
        logger.info(f"当前数据库版本: {current_version}")

        if current_version < 1:
            SchemaMigration._migrate_to_v1(conn)
            SchemaMigration._set_db_version(conn, 1)
            logger.info("数据库迁移到 v1")
        
        # Add future migrations here
        # if current_version < 2:
        #     SchemaMigration._migrate_to_v2(conn)
        #     SchemaMigration._set_db_version(conn, 2)
        #     logger.info("数据库迁移到 v2")
            
        logger.info("数据库结构检查完成。")

    @staticmethod
    def _migrate_to_v1(conn):
        c = conn.cursor()
        
        logger.info("v1 迁移: 创建初始表结构...")
        c.execute('''CREATE TABLE IF NOT EXISTS ideas (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            title TEXT NOT NULL, content TEXT, color TEXT DEFAULT '#4a90e2',
            is_pinned INTEGER DEFAULT 0, is_favorite INTEGER DEFAULT 0,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            category_id INTEGER, is_deleted INTEGER DEFAULT 0,
            item_type TEXT DEFAULT 'text', data_blob BLOB,
            content_hash TEXT
        )''')
        c.execute('CREATE TABLE IF NOT EXISTS tags (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT UNIQUE NOT NULL)')
        c.execute('''CREATE TABLE IF NOT EXISTS categories (
            id INTEGER PRIMARY KEY AUTOINCREMENT, 
            name TEXT NOT NULL, 
            parent_id INTEGER, 
            color TEXT DEFAULT "#808080",
            sort_order INTEGER DEFAULT 0
        )''')
        c.execute('CREATE TABLE IF NOT EXISTS idea_tags (idea_id INTEGER, tag_id INTEGER, PRIMARY KEY (idea_id, tag_id))')
        c.execute('CREATE INDEX IF NOT EXISTS idx_content_hash ON ideas(content_hash)')
        
        # This part is for migrating from even older, pre-versioning schemas
        logger.info("v1 迁移: 检查并添加旧版本可能缺失的列...")
        c.execute("PRAGMA table_info(ideas)")
        cols = [i[1] for i in c.fetchall()]
        if 'category_id' not in cols:
            try: c.execute('ALTER TABLE ideas ADD COLUMN category_id INTEGER')
            except: pass
        if 'is_deleted' not in cols:
            try: c.execute('ALTER TABLE ideas ADD COLUMN is_deleted INTEGER DEFAULT 0')
            except: pass
        if 'item_type' not in cols:
            try: c.execute("ALTER TABLE ideas ADD COLUMN item_type TEXT DEFAULT 'text'")
            except: pass
        if 'data_blob' not in cols:
            try: c.execute('ALTER TABLE ideas ADD COLUMN data_blob BLOB')
            except: pass
        if 'content_hash' not in cols:
            try: c.execute('ALTER TABLE ideas ADD COLUMN content_hash TEXT')
            except: pass
        
        c.execute("PRAGMA table_info(categories)")
        cat_cols = [i[1] for i in c.fetchall()]
        if 'sort_order' not in cat_cols:
            try: c.execute('ALTER TABLE categories ADD COLUMN sort_order INTEGER DEFAULT 0')
            except: pass
            
        conn.commit()
```

## 文件: data\__init__.py

```python
﻿# -*- coding: utf-8 -*-

```

## 文件: data\repositories\category_repository.py

```python
# data/repositories/category_repository.py

class CategoryRepository:
    def __init__(self, conn):
        self.conn = conn

    def get_all(self):
        c = self.conn.cursor()
        c.execute('SELECT * FROM categories ORDER BY sort_order ASC, name ASC')
        return c.fetchall()

    def add(self, name, parent_id=None):
        c = self.conn.cursor()
        if parent_id is None:
            c.execute("SELECT MAX(sort_order) FROM categories WHERE parent_id IS NULL")
        else:
            c.execute("SELECT MAX(sort_order) FROM categories WHERE parent_id = ?", (parent_id,))
        max_order = c.fetchone()[0]
        new_order = (max_order or 0) + 1
        
        c.execute('INSERT INTO categories (name, parent_id, sort_order) VALUES (?, ?, ?)', (name, parent_id, new_order))
        self.conn.commit()

    def rename(self, cat_id, new_name):
        c = self.conn.cursor()
        c.execute('UPDATE categories SET name=? WHERE id=?', (new_name, cat_id))
        self.conn.commit()

    def delete(self, cid):
        c = self.conn.cursor()
        # Note: Moving ideas should be a service-level concern
        c.execute('UPDATE ideas SET category_id=NULL WHERE category_id=?', (cid,))
        c.execute('DELETE FROM categories WHERE id=?', (cid,))
        self.conn.commit()

    def get_tree(self):
        class Partition:
            def __init__(self, id, name, color, parent_id, sort_order):
                self.id = id
                self.name = name
                self.color = color
                self.parent_id = parent_id
                self.sort_order = sort_order
                self.children = []

        c = self.conn.cursor()
        c.execute("SELECT id, name, color, parent_id, sort_order FROM categories ORDER BY sort_order ASC, name ASC")
        
        nodes = {row[0]: Partition(*row) for row in c.fetchall()}
        
        tree = []
        for node_id, node in nodes.items():
            if node.parent_id in nodes:
                nodes[node.parent_id].children.append(node)
            else:
                tree.append(node)
                
        return tree

    def save_order(self, update_list):
        c = self.conn.cursor()
        try:
            c.execute("BEGIN TRANSACTION")
            for item in update_list:
                c.execute(
                    "UPDATE categories SET sort_order = ?, parent_id = ? WHERE id = ?",
                    (item['sort_order'], item['parent_id'], item['id'])
                )
            c.execute("COMMIT")
        except Exception as e:
            c.execute("ROLLBACK")
            # Should raise this exception to be handled by the service layer
            raise e
```

## 文件: data\repositories\idea_repository.py

```python
# data/repositories/idea_repository.py
import sqlite3
import hashlib
import os
from core.enums import FilterType

class IdeaRepository:
    def __init__(self, conn):
        self.conn = conn

    def add(self, title, content, color, category_id=None, item_type='text', data_blob=None, content_hash=None):
        c = self.conn.cursor()
        c.execute(
            'INSERT INTO ideas (title, content, color, category_id, item_type, data_blob, content_hash) VALUES (?,?,?,?,?,?,?)',
            (title, content, color, category_id, item_type, data_blob, content_hash)
        )
        self.conn.commit()
        return c.lastrowid

    def update(self, iid, title, content, color, category_id=None, item_type='text', data_blob=None):
        c = self.conn.cursor()
        c.execute(
            'UPDATE ideas SET title=?, content=?, color=?, category_id=?, item_type=?, data_blob=?, updated_at=CURRENT_TIMESTAMP WHERE id=?',
            (title, content, color, category_id, item_type, data_blob, iid)
        )
        self.conn.commit()

    def find_by_hash(self, content_hash):
        c = self.conn.cursor()
        c.execute("SELECT id FROM ideas WHERE content_hash = ?", (content_hash,))
        return c.fetchone()

    def update_timestamp(self, iid):
        c = self.conn.cursor()
        c.execute("UPDATE ideas SET updated_at = CURRENT_TIMESTAMP WHERE id = ?", (iid,))
        self.conn.commit()

    def toggle_field(self, iid, field):
        if field not in ['is_pinned', 'is_favorite']:
            raise ValueError("Invalid field for toggling")
        c = self.conn.cursor()
        c.execute(f'UPDATE ideas SET {field} = NOT {field} WHERE id=?', (iid,))
        self.conn.commit()

    def set_deleted(self, iid, state):
        c = self.conn.cursor()
        c.execute('UPDATE ideas SET is_deleted=? WHERE id=?', (1 if state else 0, iid))
        self.conn.commit()

    def move_category(self, iid, cat_id):
        c = self.conn.cursor()
        c.execute('UPDATE ideas SET category_id=? WHERE id=?', (cat_id, iid))
        self.conn.commit()

    def delete_permanent(self, iid):
        c = self.conn.cursor()
        c.execute('DELETE FROM ideas WHERE id=?', (iid,))
        c.execute('DELETE FROM idea_tags WHERE idea_id=?', (iid,))
        self.conn.commit()

    def get_by_id(self, iid, include_blob=False):
        c = self.conn.cursor()
        if include_blob:
            c.execute('SELECT * FROM ideas WHERE id=?', (iid,))
        else:
            c.execute('SELECT id, title, content, color, is_pinned, is_favorite, created_at, updated_at, category_id, item_type FROM ideas WHERE id=?', (iid,))
        return c.fetchone()

    def get_all(self, search: str, f_type: FilterType, f_val):
        c = self.conn.cursor()
        q = "SELECT DISTINCT i.* FROM ideas i LEFT JOIN idea_tags it ON i.id=it.idea_id LEFT JOIN tags t ON it.tag_id=t.id WHERE 1=1"
        p = []
        
        if f_type == FilterType.TRASH:
            q += ' AND i.is_deleted=1'
        else:
            q += ' AND (i.is_deleted=0 OR i.is_deleted IS NULL)'
        
        if f_type == FilterType.CATEGORY:
            if f_val is None: q += ' AND i.category_id IS NULL'
            else: q += ' AND i.category_id=?'; p.append(f_val)
        elif f_type == FilterType.TODAY:
            q += " AND date(i.updated_at,'localtime')=date('now','localtime')"
        elif f_type == FilterType.CLIPBOARD:
            q += " AND i.id IN (SELECT idea_id FROM idea_tags WHERE tag_id = (SELECT id FROM tags WHERE name = '剪贴板'))"
        elif f_type == FilterType.UNTAGGED:
            q += ' AND i.id NOT IN (SELECT idea_id FROM idea_tags)'
        elif f_type == FilterType.FAVORITE:
            q += ' AND i.is_favorite=1'
        elif f_type == FilterType.UNCATEGORIZED:
            q += ' AND i.category_id IS NULL'
        
        if search:
            q += ' AND (i.title LIKE ? OR i.content LIKE ? OR t.name LIKE ?)'
            p.extend([f'%{search}%']*3)
            
        q += ' ORDER BY i.is_pinned DESC, i.updated_at DESC'
        c.execute(q, p)
        return c.fetchall()

    def get_counts(self):
        c = self.conn.cursor()
        d = {}
        queries = {
            FilterType.ALL: "is_deleted=0 OR is_deleted IS NULL",
            FilterType.TODAY: "(is_deleted=0 OR is_deleted IS NULL) AND date(updated_at,'localtime')=date('now','localtime')",
            FilterType.CLIPBOARD: "(is_deleted=0 OR is_deleted IS NULL) AND id IN (SELECT idea_id FROM idea_tags WHERE tag_id = (SELECT id FROM tags WHERE name = '剪贴板'))",
            FilterType.UNCATEGORIZED: "(is_deleted=0 OR is_deleted IS NULL) AND category_id IS NULL",
            FilterType.UNTAGGED: "(is_deleted=0 OR is_deleted IS NULL) AND id NOT IN (SELECT idea_id FROM idea_tags)",
            FilterType.FAVORITE: "(is_deleted=0 OR is_deleted IS NULL) AND is_favorite=1",
            FilterType.TRASH: "is_deleted=1"
        }
        for k, v in queries.items():
            c.execute(f"SELECT COUNT(*) FROM ideas WHERE {v}")
            d[k.value] = c.fetchone()[0]
            
        c.execute("SELECT category_id, COUNT(*) FROM ideas WHERE (is_deleted=0 OR is_deleted IS NULL) GROUP BY category_id")
        d['categories'] = dict(c.fetchall())
        return d
```

## 文件: data\repositories\tag_repository.py

```python
# data/repositories/tag_repository.py

class TagRepository:
    def __init__(self, conn):
        self.conn = conn

    def update_tags_for_idea(self, iid, tags):
        c = self.conn.cursor()
        c.execute('DELETE FROM idea_tags WHERE idea_id=?', (iid,))
        if not tags:
            self.conn.commit()
            return
            
        for t in tags:
            t = t.strip()
            if t:
                c.execute('INSERT OR IGNORE INTO tags (name) VALUES (?)', (t,))
                c.execute('SELECT id FROM tags WHERE name=?', (t,))
                tid = c.fetchone()[0]
                c.execute('INSERT INTO idea_tags VALUES (?,?)', (iid, tid))
        self.conn.commit()

    def get_tags_for_idea(self, iid):
        c = self.conn.cursor()
        c.execute('SELECT t.name FROM tags t JOIN idea_tags it ON t.id=it.tag_id WHERE it.idea_id=?', (iid,))
        return [r[0] for r in c.fetchall()]

    def get_all_tags_with_counts(self):
        c = self.conn.cursor()
        c.execute('''
            SELECT t.name, COUNT(it.idea_id) as cnt 
            FROM tags t 
            JOIN idea_tags it ON t.id = it.tag_id 
            JOIN ideas i ON it.idea_id = i.id 
            WHERE i.is_deleted = 0 
            GROUP BY t.id 
            ORDER BY cnt DESC, t.name ASC
        ''')
        return c.fetchall()
```

## 文件: services\backup_service.py

```python
﻿# -*- coding: utf-8 -*-

# services/backup_service.py
import os
import shutil
from datetime import datetime
from core.config import DB_NAME, BACKUP_DIR

class BackupService:
    @staticmethod
    def run_backup():
        """执行数据库备份并清理旧文件"""
        if not os.path.exists(BACKUP_DIR):
            os.makedirs(BACKUP_DIR)
        
        if os.path.exists(DB_NAME):
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            target = os.path.join(BACKUP_DIR, f'ideas_{timestamp}.db')
            try:
                shutil.copy2(DB_NAME, target)
                BackupService._clean_old_backups()
                print(f"[System] Backup created: {target}")
            except Exception as e:
                print(f"[System] Backup failed: {e}")

    @staticmethod
    def _clean_old_backups(keep=20):
        try:
            files = sorted(
                [os.path.join(BACKUP_DIR, f) for f in os.listdir(BACKUP_DIR)],
                key=os.path.getmtime
            )
            while len(files) > keep:
                os.remove(files.pop(0))
        except Exception:
            pass
```

## 文件: services\clipboard.py

```python
# -*- coding: utf-8 -*-
# services/clipboard.py
import datetime
import os
import uuid
import hashlib
from PyQt5.QtCore import QObject, pyqtSignal, QBuffer
from PyQt5.QtGui import QImage
from PyQt5.QtWidgets import QApplication

class ClipboardManager(QObject):
    """
    管理剪贴板数据，处理数据并将其存入数据库。
    """
    data_captured = pyqtSignal(int)

    def __init__(self, db_manager):
        super().__init__()
        self.db = db_manager
        self._last_hash = None

    def _hash_data(self, data):
        """为数据创建一个简单的哈希值以检查重复。"""
        if isinstance(data, QImage):
            return hash(data.bits().tobytes())
        return hashlib.md5(str(data).encode('utf-8')).hexdigest()

    def process_clipboard(self, mime_data, category_id=None):
        """
        处理来自剪贴板的 MIME 数据。
        """
        # 1. 屏蔽内部操作
        if QApplication.activeWindow() is not None:
            return

        extra_tags = set() # 用于收集智能分析的标签

        try:
            # --- 优先处理 文件/文件夹 ---
            if mime_data.hasUrls():
                urls = mime_data.urls()
                filepaths = [url.toLocalFile() for url in urls if url.isLocalFile()]
                
                if filepaths:
                    content = ";".join(filepaths)
                    current_hash = self._hash_data(content)
                    
                    if current_hash != self._last_hash:
                        
                        # 【智能打标逻辑：文件与文件夹】
                        for path in filepaths:
                            if os.path.isdir(path):
                                extra_tags.add("文件夹")
                            elif os.path.isfile(path):
                                # 提取扩展名，转小写，去点
                                ext = os.path.splitext(path)[1].lower().lstrip('.')
                                if ext:
                                    extra_tags.add(ext)

                        result = self.db.add_clipboard_item(item_type='file', content=content, category_id=category_id)
                        self._last_hash = current_hash
                        
                        if result:
                            idea_id, is_new = result
                            if is_new:
                                # 【应用智能标签】
                                if extra_tags:
                                    self.db.add_tags_to_multiple_ideas([idea_id], list(extra_tags))
                                self.data_captured.emit(idea_id)
                        return

            # --- 处理图片 ---
            if mime_data.hasImage():
                image = mime_data.imageData()
                buffer = QBuffer()
                buffer.open(QBuffer.ReadWrite)
                image.save(buffer, "PNG")
                image_bytes = buffer.data()
                
                current_hash = hashlib.md5(image_bytes).hexdigest()
                
                if current_hash != self._last_hash:
                    result = self.db.add_clipboard_item(item_type='image', content='[Image Data]', data_blob=image_bytes, category_id=category_id)
                    self._last_hash = current_hash
                    
                    if result:
                        idea_id, is_new = result
                        if is_new:
                            self.data_captured.emit(idea_id)
                    return

            # --- 处理文本 (含网址识别) ---
            if mime_data.hasText():
                text = mime_data.text()
                if not text.strip(): return
                
                current_hash = self._hash_data(text)
                if current_hash != self._last_hash:
                    
                    # 【智能打标逻辑：网址】
                    stripped_text = text.strip()
                    if stripped_text.startswith(('http://', 'https://')):
                        extra_tags.add("网址")
                        extra_tags.add("链接")
                    
                    result = self.db.add_clipboard_item(item_type='text', content=text, category_id=category_id)
                    self._last_hash = current_hash
                    
                    if result:
                        idea_id, is_new = result
                        if is_new:
                            # 【应用智能标签】
                            if extra_tags:
                                self.db.add_tags_to_multiple_ideas([idea_id], list(extra_tags))
                            self.data_captured.emit(idea_id)
                    return

        except Exception as e:
            pass
```

## 文件: services\clipboard_service.py

```python
# services/clipboard_service.py
import os
from PyQt5.QtCore import QObject, pyqtSignal, QBuffer
from PyQt5.QtGui import QImage

class ClipboardService(QObject):
    data_captured = pyqtSignal()

    def __init__(self, idea_repo, tag_repo, hash_calculator):
        super().__init__()
        self.idea_repo = idea_repo
        self.tag_repo = tag_repo
        self.hasher = hash_calculator

    def process_mime_data(self, mime_data, category_id=None):
        try:
            if mime_data.hasUrls():
                urls = mime_data.urls()
                filepaths = [url.toLocalFile() for url in urls if url.isLocalFile()]
                if filepaths:
                    content = ";".join(filepaths)
                    self._save_clipboard_item('file', content, category_id=category_id)
                    return

            if mime_data.hasImage():
                image = mime_data.imageData()
                buffer = QBuffer()
                buffer.open(QBuffer.ReadWrite)
                image.save(buffer, "PNG")
                image_bytes = buffer.data()
                self._save_clipboard_item('image', '[Image Data]', data_blob=image_bytes, category_id=category_id)
                return

            if mime_data.hasText():
                text = mime_data.text()
                if text:
                    self._save_clipboard_item('text', text, category_id=category_id)
                    return
        except Exception as e:
            # Proper logging should be added here
            pass

    def _save_clipboard_item(self, item_type, content, data_blob=None, category_id=None):
        content_hash = self.hasher.compute(content, data_blob)
        if not content_hash:
            return

        existing_idea = self.idea_repo.find_by_hash(content_hash)

        if existing_idea:
            idea_id = existing_idea[0]
            self.idea_repo.update_timestamp(idea_id)
            return idea_id
        else:
            if item_type == 'text':
                title = content.strip().split('\\n')[0][:50]
            elif item_type == 'image':
                title = "[图片]"
            elif item_type == 'file':
                title = f"[文件] {os.path.basename(content.split(';')[0])}"
            else:
                title = "未命名"
            
            idea_id = self.idea_repo.add(
                title=title,
                content=content,
                color=None, # Use default color
                category_id=category_id,
                item_type=item_type,
                data_blob=data_blob,
                content_hash=content_hash
            )
            
            # Automatically add "剪贴板" tag
            existing_tags = self.tag_repo.get_tags_for_idea(idea_id)
            if "剪贴板" not in existing_tags:
                existing_tags.append("剪贴板")
                self.tag_repo.update_tags_for_idea(idea_id, existing_tags)
            
            self.data_captured.emit()
            return idea_id
```

## 文件: services\hash_calculator.py

```python
# services/hash_calculator.py
import hashlib

class HashCalculator:
    def compute(self, content, data_blob=None):
        """
        Computes the SHA256 hash for the given content.
        """
        hasher = hashlib.sha256()
        if data_blob:
            hasher.update(data_blob)
        elif content:
            hasher.update(str(content).encode('utf-8'))
        else:
            return None
        return hasher.hexdigest()
```

## 文件: services\idea_service.py

```python
# services/idea_service.py
from core.enums import FilterType

class IdeaService:
    def __init__(self, idea_repo, tag_repo, category_repo):
        self.idea_repo = idea_repo
        self.tag_repo = tag_repo
        self.category_repo = category_repo

    def add_idea(self, title, content, color, tags, category_id=None, item_type='text', data_blob=None):
        idea_id = self.idea_repo.add(title, content, color, category_id, item_type, data_blob)
        self.tag_repo.update_tags_for_idea(idea_id, tags)
        return idea_id

    def update_idea(self, iid, title, content, color, tags, category_id=None, item_type='text', data_blob=None):
        self.idea_repo.update(iid, title, content, color, category_id, item_type, data_blob)
        self.tag_repo.update_tags_for_idea(iid, tags)

    def update_tags_for_idea(self, idea_id, tags):
        self.tag_repo.update_tags_for_idea(idea_id, tags)

    def get_ideas_for_filter(self, search_text: str, filter_type_str: str, filter_value):
        try:
            filter_type_enum = FilterType(filter_type_str)
        except ValueError:
            filter_type_enum = FilterType.ALL
        return self.idea_repo.get_all(search_text, filter_type_enum, filter_value)

    def toggle_favorite(self, idea_id):
        self.idea_repo.toggle_field(idea_id, 'is_favorite')

    def toggle_pinned(self, idea_id):
        self.idea_repo.toggle_field(idea_id, 'is_pinned')

    def move_to_trash(self, idea_ids):
        for iid in idea_ids:
            self.idea_repo.set_deleted(iid, True)
    
    def restore_from_trash(self, idea_ids):
        for iid in idea_ids:
            self.idea_repo.set_deleted(iid, False)

    def delete_permanently(self, idea_ids):
        for iid in idea_ids:
            self.idea_repo.delete_permanent(iid)

    def move_to_category(self, idea_ids, category_id):
        for iid in idea_ids:
            self.idea_repo.move_category(iid, category_id)

    # --- Pass-through methods to repositories ---
    
    def get_idea_with_blob(self, iid):
        return self.idea_repo.get_by_id(iid, include_blob=True)

    def get_idea_tags(self, iid):
        return self.tag_repo.get_tags_for_idea(iid)

    def get_all_categories(self):
        return self.category_repo.get_all()

    def get_category_tree(self):
        return self.category_repo.get_tree()

    def get_all_tags_with_counts(self):
        return self.tag_repo.get_all_tags_with_counts()

    def get_stats_counts(self):
        return self.idea_repo.get_counts()

    def add_category(self, name, parent_id=None):
        self.category_repo.add(name, parent_id)

    def rename_category(self, cat_id, new_name):
        self.category_repo.rename(cat_id, new_name)

    def delete_category(self, cat_id):
        self.category_repo.delete(cat_id)

    def save_category_order(self, order_list):
        self.category_repo.save_order(order_list)
```

## 文件: services\preview_service.py

```python
﻿# -*- coding: utf-8 -*-
# services/preview_service.py
import os
from PyQt5.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QLabel, QTextEdit, 
                             QWidget, QDesktopWidget, QShortcut, QPushButton, 
                             QGraphicsDropShadowEffect, QSizePolicy, QStyle)
from PyQt5.QtCore import Qt, QPoint, QSize, QEvent, QRect
from PyQt5.QtGui import QPixmap, QKeySequence, QFont, QColor, QPainter, QIcon
from core.config import COLORS, STYLES

class ScalableImageLabel(QLabel):
    """
    智能图片标签：
    支持随窗口大小变化自动缩放图片，保持比例并居中。
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self._original_pixmap = None
        self.setSizePolicy(QSizePolicy.Ignored, QSizePolicy.Ignored)
        self.setAlignment(Qt.AlignCenter)
        self.setMinimumSize(200, 200)

    def set_pixmap(self, pixmap):
        self._original_pixmap = pixmap
        self.update()

    def paintEvent(self, event):
        if not self._original_pixmap or self._original_pixmap.isNull():
            text = "无法加载图片"
            painter = QPainter(self)
            painter.setPen(QColor("#666"))
            painter.drawText(self.rect(), Qt.AlignCenter, text)
            return

        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        painter.setRenderHint(QPainter.SmoothPixmapTransform)

        # 计算缩放后的尺寸，保持纵横比
        scaled_size = self._original_pixmap.size().scaled(self.size(), Qt.KeepAspectRatio)
        
        # 计算居中位置
        x = (self.width() - scaled_size.width()) // 2
        y = (self.height() - scaled_size.height()) // 2
        
        # 绘制
        target_rect = QRect(x, y, scaled_size.width(), scaled_size.height())
        painter.drawPixmap(target_rect, self._original_pixmap)

class PreviewDialog(QDialog):
    """
    增强版预览窗口：支持拖动、最大化、最小化、自适应缩放、多图切换
    """
    def __init__(self, mode, data_list, parent=None):
        """
        :param mode: 'text' 或 'gallery' (图片集合)
        :param data_list: 数据列表。如果是文本则是 [text_str]，如果是画廊则是 [path1, path2, blob...]
        """
        super().__init__(parent)
        # 普通无边框窗口
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.Window)
        self.setAttribute(Qt.WA_TranslucentBackground)
        self.setAttribute(Qt.WA_DeleteOnClose) 
        
        # 状态变量
        self.mode = mode
        self.data_list = data_list
        self.current_index = 0
        self._drag_pos = None
        
        self._init_ui()
        self._setup_shortcuts()
        self._load_current_content()

    def _init_ui(self):
        # 1. 根布局
        root_layout = QVBoxLayout(self)
        root_layout.setContentsMargins(10, 10, 10, 10)

        # 2. 主容器
        self.container = QWidget()
        self.container.setObjectName("PreviewContainer")
        self.container.setStyleSheet(f"""
            QWidget#PreviewContainer {{
                background-color: {COLORS['bg_dark']};
                border: 1px solid {COLORS['bg_light']};
                border-radius: 8px;
            }}
        """)
        
        shadow = QGraphicsDropShadowEffect(self)
        shadow.setBlurRadius(20)
        shadow.setXOffset(0)
        shadow.setYOffset(5)
        shadow.setColor(QColor(0, 0, 0, 150))
        self.container.setGraphicsEffect(shadow)
        root_layout.addWidget(self.container)

        # 3. 内容布局
        self.main_layout = QVBoxLayout(self.container)
        self.main_layout.setContentsMargins(0, 0, 0, 0)
        self.main_layout.setSpacing(0)

        # 4. 标题栏
        self.title_bar = self._create_title_bar()
        self.main_layout.addWidget(self.title_bar)

        # 5. 内容显示区域
        self.content_area = QWidget()
        self.content_layout = QVBoxLayout(self.content_area)
        self.content_layout.setContentsMargins(15, 5, 15, 5)
        self.main_layout.addWidget(self.content_area, 1)

        # 初始化显示控件
        self.text_edit = None
        self.image_label = None

        if self.mode == 'text':
            self._init_text_widget()
        else:
            self._init_image_widget()

        # 6. 底部控制栏 (仅多图模式显示)
        self.control_bar = QWidget()
        ctrl_layout = QHBoxLayout(self.control_bar)
        ctrl_layout.setContentsMargins(20, 5, 20, 10)
        
        self.btn_prev = QPushButton("◀ 上一张")
        self.btn_next = QPushButton("下一张 ▶")
        
        btn_style = f"""
            QPushButton {{
                background-color: {COLORS['bg_mid']};
                border: 1px solid {COLORS['bg_light']};
                color: #ddd;
                padding: 6px 15px;
                border-radius: 4px;
            }}
            QPushButton:hover {{ background-color: {COLORS['primary']}; border-color: {COLORS['primary']}; color: white; }}
        """
        self.btn_prev.setStyleSheet(btn_style)
        self.btn_next.setStyleSheet(btn_style)
        
        self.btn_prev.clicked.connect(self._prev_image)
        self.btn_next.clicked.connect(self._next_image)
        
        ctrl_layout.addWidget(self.btn_prev)
        ctrl_layout.addStretch()
        
        # 提示文字
        hint = QLabel("按 [Space] 关闭 | [←/→] 切换")
        hint.setStyleSheet(f"color: {COLORS['text_sub']}; font-size: 11px;")
        ctrl_layout.addWidget(hint)
        
        ctrl_layout.addStretch()
        ctrl_layout.addWidget(self.btn_next)
        
        self.main_layout.addWidget(self.control_bar)
        
        # 如果只有一张图或文本模式，隐藏控制栏
        if len(self.data_list) <= 1:
            self.control_bar.hide()

    def _init_text_widget(self):
        self.text_edit = QTextEdit()
        self.text_edit.setReadOnly(True)
        self.text_edit.setFont(QFont("Microsoft YaHei", 12))
        self.text_edit.setStyleSheet(f"""
            QTextEdit {{
                background-color: transparent;
                border: none;
                color: {COLORS['text']};
                selection-background-color: {COLORS['primary']};
                padding: 10px;
            }}
        """ + STYLES.get('main_window', '').split('/* 滚动条美化 V2 */')[1] if '/* 滚动条美化 V2 */' in STYLES.get('main_window', '') else "")
        self.content_layout.addWidget(self.text_edit)
        self.resize(1130, 740)

    def _init_image_widget(self):
        self.image_label = ScalableImageLabel()
        self.content_layout.addWidget(self.image_label)
        self.resize(1130, 740)

    def _create_title_bar(self):
        title_bar = QWidget()
        title_bar.setFixedHeight(36)
        title_bar.setStyleSheet(f"""
            QWidget {{
                background-color: {COLORS['bg_mid']};
                border-top-left-radius: 8px;
                border-top-right-radius: 8px;
                border-bottom: 1px solid {COLORS['bg_light']};
            }}
        """)
        
        layout = QHBoxLayout(title_bar)
        layout.setContentsMargins(10, 0, 10, 0)
        
        self.title_label = QLabel("预览")
        self.title_label.setStyleSheet("font-weight: bold; color: #ddd; border: none; background: transparent;")
        layout.addWidget(self.title_label)
        layout.addStretch()

        btn_style = "QPushButton { background: transparent; border: none; color: #aaa; border-radius: 4px; font-family: Arial; font-size: 14px; } QPushButton:hover { background-color: rgba(255, 255, 255, 0.1); color: white; }"
        
        btn_min = QPushButton("─")
        btn_min.setFixedSize(28, 28)
        btn_min.setStyleSheet(btn_style)
        btn_min.clicked.connect(self.showMinimized)
        
        self.btn_max = QPushButton("□")
        self.btn_max.setFixedSize(28, 28)
        self.btn_max.setStyleSheet(btn_style)
        self.btn_max.clicked.connect(self._toggle_maximize)

        btn_close = QPushButton("×")
        btn_close.setFixedSize(28, 28)
        btn_close.setStyleSheet("QPushButton { background: transparent; border: none; color: #aaa; border-radius: 4px; font-size: 16px; } QPushButton:hover { background-color: #e74c3c; color: white; }")
        btn_close.clicked.connect(self.close)

        layout.addWidget(btn_min)
        layout.addWidget(self.btn_max)
        layout.addWidget(btn_close)
        return title_bar

    def _load_current_content(self):
        """核心方法：根据 index 加载数据"""
        if not self.data_list: return
        
        current_data = self.data_list[self.current_index]
        total = len(self.data_list)
        
        # 更新标题
        if self.mode == 'text':
            self.title_label.setText("📝 文本预览")
            self.text_edit.setText(str(current_data))
        else:
            self.title_label.setText(f"🖼️ 图片预览 [{self.current_index + 1}/{total}]")
            self._show_image(current_data)

        # 居中窗口 (仅在第一次显示时)
        if not self.isVisible():
            self._center_on_screen()

    def _show_image(self, data):
        """显示单张图片，支持路径或二进制数据"""
        pixmap = QPixmap()
        
        if isinstance(data, bytes):
            pixmap.loadFromData(data)
        elif isinstance(data, str) and os.path.exists(data):
            pixmap.load(data)
        
        self.image_label.set_pixmap(pixmap)

    def _center_on_screen(self):
        screen = QDesktopWidget().screenNumber(QDesktopWidget().cursor().pos())
        center = QDesktopWidget().screenGeometry(screen).center()
        self.move(center.x() - self.width() // 2, center.y() - self.height() // 2)

    def _toggle_maximize(self):
        if self.isMaximized():
            self.showNormal()
            self.btn_max.setText("□")
            self.layout().setContentsMargins(10, 10, 10, 10)
        else:
            self.showMaximized()
            self.btn_max.setText("❐")
            self.layout().setContentsMargins(0, 0, 0, 0)

    def _prev_image(self):
        if self.current_index > 0:
            self.current_index -= 1
            self._load_current_content()

    def _next_image(self):
        if self.current_index < len(self.data_list) - 1:
            self.current_index += 1
            self._load_current_content()

    def _setup_shortcuts(self):
        QShortcut(QKeySequence(Qt.Key_Escape), self, self.close)
        QShortcut(QKeySequence(Qt.Key_Space), self, self.close)
        
        # 左右键切换图片
        QShortcut(QKeySequence(Qt.Key_Left), self, self._prev_image)
        QShortcut(QKeySequence(Qt.Key_Right), self, self._next_image)

    # --- 拖动逻辑 ---
    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton and event.y() < 50:
            self._drag_pos = event.globalPos() - self.frameGeometry().topLeft()
            event.accept()
        else:
            super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        if event.buttons() == Qt.LeftButton and self._drag_pos:
            if not self.isMaximized():
                self.move(event.globalPos() - self._drag_pos)
                event.accept()
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        self._drag_pos = None
        super().mouseReleaseEvent(event)
        
    def mouseDoubleClickEvent(self, event):
        if event.y() < 50:
            self._toggle_maximize()


class PreviewService:
    def __init__(self, db_manager, parent_window):
        self.db = db_manager
        self.parent = parent_window
        self.current_dialog = None

    def toggle_preview(self, selected_ids):
        if self.current_dialog and self.current_dialog.isVisible():
            self.current_dialog.close()
            self.current_dialog = None
            return

        if not selected_ids: return
        if len(selected_ids) != 1:
            self._show_tooltip('⚠️ 只能预览单个项目')
            return

        idea_id = list(selected_ids)[0]
        self._open_preview(idea_id)

    def _open_preview(self, idea_id):
        idea = self.db.get_idea(idea_id, include_blob=True)
        if not idea: return

        # 解析数据
        # 字段: 2=content, 10=item_type, 11=data_blob
        content = idea[2]
        try:
            item_type = idea[10] if len(idea) > 10 else 'text'
            data_blob = idea[11] if len(idea) > 11 else None
        except IndexError:
            item_type = 'text'
            data_blob = None

        mode = 'text'
        data_list = []

        # 1. 数据库 Blob 图片
        if item_type == 'image' and data_blob:
            mode = 'gallery'
            data_list = [data_blob]
        
        # 2. 文本内容分析 (核心修复逻辑)
        elif content:
            # 检查是否包含分号 (多文件路径特征)
            potential_paths = content.split(';')
            valid_images = []
            img_exts = {'.png', '.jpg', '.jpeg', '.bmp', '.gif', '.webp', '.ico', '.svg', '.tif'}
            
            for p in potential_paths:
                p = p.strip()
                if p and os.path.exists(p):
                    ext = os.path.splitext(p)[1].lower()
                    if ext in img_exts:
                        valid_images.append(p)
            
            if valid_images:
                mode = 'gallery'
                data_list = valid_images
            else:
                mode = 'text'
                data_list = [content]
        else:
            self._show_tooltip('⚠️ 内容为空')
            return

        # 创建窗口
        self.current_dialog = PreviewDialog(mode, data_list, self.parent)
        self.current_dialog.finished.connect(self._on_dialog_closed)
        self.current_dialog.show()

    def _on_dialog_closed(self):
        self.current_dialog = None

    def _show_tooltip(self, msg):
        if hasattr(self.parent, '_show_tooltip'):
            self.parent._show_tooltip(msg, 1500)
```

## 文件: services\selection_service.py

```python
﻿# services/selection_service.py
from PyQt5.QtCore import QObject, pyqtSignal, QPoint
from pynput import mouse
import threading

class SelectionMonitor(QObject):
    # 定义信号：当检测到可能的划选动作时，发送鼠标当前的坐标
    text_selected = pyqtSignal(QPoint)

    def __init__(self):
        super().__init__()
        self.press_pos = None
        self._is_running = True

    def start(self):
        # 在独立线程中启动监听，避免阻塞主界面
        self.thread = threading.Thread(target=self._run_listener, daemon=True)
        self.thread.start()

    def _run_listener(self):
        with mouse.Listener(on_click=self._on_click) as listener:
            listener.join()

    def _on_click(self, x, y, button, pressed):
        if button == mouse.Button.left:
            if pressed:
                # 记录按下时的位置
                self.press_pos = (x, y)
            else:
                # 鼠标松开时，计算移动距离
                if self.press_pos:
                    dx = abs(x - self.press_pos[0])
                    dy = abs(y - self.press_pos[1])
                    # 如果移动距离超过 15 像素，判定为划选动作
                    if dx > 15 or dy > 15:
                        self.text_selected.emit(QPoint(int(x), int(y)))
                self.press_pos = None
```

## 文件: services\__init__.py

```python
﻿# -*- coding: utf-8 -*-

```

## 文件: ui\action_popup.py

```python
﻿# -*- coding: utf-8 -*-
# ui/action_popup.py

from PyQt5.QtWidgets import QWidget, QHBoxLayout, QPushButton, QLabel, QGraphicsDropShadowEffect, QFrame
from PyQt5.QtCore import Qt, pyqtSignal, QTimer, QPoint, QSize, QRectF
from PyQt5.QtGui import (QCursor, QColor, QPainter, QLinearGradient, 
                         QPainterPath, QPen, QBrush, QFont)
from core.config import COLORS
from ui.common_tags import CommonTags
from core.logger import get_logger

logger = get_logger('ActionPopup')

class MiniBookIcon(QWidget):
    """
    微型图标组件：专业版 (32x32)
    保留抗锯齿优化和舒适的视觉比例
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFixedSize(32, 32) 

    def paintEvent(self, e):
        p = QPainter(self)
        p.setRenderHint(QPainter.Antialiasing)
        p.setRenderHint(QPainter.HighQualityAntialiasing)
        
        # 居中并进行亚像素偏移，消除边缘模糊
        p.translate(self.width() / 2 + 0.5, self.height() / 2 + 0.5)
        
        # 缩放系数 0.28
        p.scale(0.28, 0.28) 
        p.translate(0, 2)

        # 1. 绘制笔记本
        w, h = 56, 76
        
        # 阴影
        p.save()
        p.translate(2, 3)
        p.setBrush(QColor(0, 0, 0, 100))
        p.setPen(Qt.NoPen)
        p.drawRoundedRect(QRectF(-w/2, -h/2, w, h), 4, 4)
        p.restore()

        # 页厚 (米白)
        p.setBrush(QColor(224, 224, 224)) 
        p.setPen(Qt.NoPen)
        p.drawRoundedRect(QRectF(-w/2+5, -h/2+4, w, h), 3, 3)
        
        # 封面
        grad = QLinearGradient(-w, -h, w, h)
        grad.setColorAt(0, QColor(70, 40, 35))   
        grad.setColorAt(1, QColor(100, 60, 50))  
        p.setBrush(grad)
        p.drawRoundedRect(QRectF(-w/2, -h/2, w, h), 3, 3)
        
        # 书签
        p.setBrush(QColor(160, 30, 40))
        p.drawRect(QRectF(w/2 - 14, -h/2, 8, h))

        # 2. 绘制钢笔
        p.rotate(-45)
        p.translate(0, -8) 
        w_pen, h_pen = 14, 48 
        body_grad = QLinearGradient(-w_pen/2, 0, w_pen/2, 0)
        body_grad.setColorAt(0.0, QColor(200, 70, 80)) 
        body_grad.setColorAt(1.0, QColor(80, 10, 20)) 
        path_body = QPainterPath()
        path_body.addRoundedRect(QRectF(-w_pen/2, -h_pen/2, w_pen, h_pen), 6, 6)
        p.setBrush(body_grad)
        p.drawPath(path_body)
        
        path_tip = QPainterPath()
        tip_h = 16
        path_tip.moveTo(-w_pen/2 + 3, h_pen/2)
        path_tip.lineTo(w_pen/2 - 3, h_pen/2)
        path_tip.lineTo(0, h_pen/2 + tip_h)
        path_tip.closeSubpath()
        p.setBrush(QColor(255, 220, 100))
        p.drawPath(path_tip)
        p.setBrush(QColor(255, 215, 0))
        p.drawRect(QRectF(-w_pen/2, h_pen/2 - 5, w_pen, 5))


class ActionPopup(QWidget):
    """
    复制成功后在鼠标附近弹出的快捷操作条
    布局：专业舒适间距 | 逻辑：智能多选开关
    """
    request_favorite = pyqtSignal(int, bool)
    # 【恢复】多选逻辑信号 (id, tag, checked)
    request_tag_toggle = pyqtSignal(int, str, bool) 
    request_manager = pyqtSignal() 

    def __init__(self, parent=None): 
        super().__init__(parent)
        self.current_idea_id = None
        self.is_favorited = False 
        
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint | Qt.Tool)
        self.setAttribute(Qt.WA_TranslucentBackground)
        self.setAttribute(Qt.WA_ShowWithoutActivating)
        
        self._init_ui()
        
        self.hide_timer = QTimer(self)
        self.hide_timer.setSingleShot(True)
        self.hide_timer.timeout.connect(self._animate_hide)

    def _init_ui(self):
        self.container = QWidget(self)
        self.container.setStyleSheet(f"""
            QWidget {{
                background-color: #2D2D2D;
                border: 1px solid #444;
                border-radius: 18px;
            }}
        """)
        
        layout = QHBoxLayout(self.container)
        # 【保持】舒适的专业布局参数
        layout.setContentsMargins(12, 6, 12, 6)
        layout.setSpacing(10)
        
        self.icon_widget = MiniBookIcon()
        layout.addWidget(self.icon_widget)
        
        line = QFrame()
        line.setFixedWidth(1)
        line.setFixedHeight(16)
        line.setStyleSheet("background-color: #555; border: none;")
        layout.addWidget(line)

        self.btn_fav = QPushButton("☆")
        self.btn_fav.setToolTip("收藏 / 取消")
        self.btn_fav.setCursor(Qt.PointingHandCursor)
        self.btn_fav.setStyleSheet(f"""
            QPushButton {{
                background: transparent; color: #BBB; border: none; 
                font-size: 16px; font-weight: bold; padding: 0px;
            }}
            QPushButton:hover {{ color: {COLORS['warning']}; }}
        """)
        self.btn_fav.clicked.connect(self._on_fav_clicked)
        layout.addWidget(self.btn_fav)

        self.common_tags_bar = CommonTags()
        # 【恢复】连接多选 Toggle 信号
        self.common_tags_bar.tag_toggled.connect(self._on_tag_toggled)
        self.common_tags_bar.manager_requested.connect(self._on_manager_clicked)
        self.common_tags_bar.refresh_requested.connect(self._adjust_size_dynamically)
        
        layout.addWidget(self.common_tags_bar)
        
        shadow = QGraphicsDropShadowEffect(self)
        shadow.setBlurRadius(15)
        shadow.setXOffset(0)
        shadow.setYOffset(4)
        shadow.setColor(QColor(0, 0, 0, 120))
        self.container.setGraphicsEffect(shadow)

    def _adjust_size_dynamically(self):
        if self.isVisible():
            self.container.adjustSize()
            self.resize(self.container.size() + QSize(10, 10))

    def show_at_mouse(self, idea_id):
        logger.debug(f"Popup Show: ID={idea_id}")
        self.current_idea_id = idea_id
        
        try:
            self.common_tags_bar.reload_tags()
            # 【恢复】重置标签选中状态
            self.common_tags_bar.reset_selection()
            
            self.is_favorited = False
            self._update_fav_style()
            
            self.container.adjustSize()
            self.resize(self.container.size() + QSize(10, 10))
            
            cursor_pos = QCursor.pos()
            x = cursor_pos.x() - self.width() // 2
            y = cursor_pos.y() - 60 
            
            self.move(x, y)
            self.show()
            self.hide_timer.start(3500)
        except Exception as e:
            logger.error(f"Popup Show Error: {e}")

    def _on_fav_clicked(self):
        self.is_favorited = not self.is_favorited
        if self.current_idea_id:
            try:
                self._update_fav_style()
                self.request_favorite.emit(self.current_idea_id, self.is_favorited)
                self.hide_timer.start(2500)
            except Exception as e:
                logger.error(f"Fav Error: {e}")

    def _update_fav_style(self):
        if self.is_favorited:
            self.btn_fav.setText("★")
            self.btn_fav.setStyleSheet(f"""
                QPushButton {{
                    background: transparent; color: #FFD700; border: none; 
                    font-size: 16px; font-weight: bold; padding: 0px;
                }}
                QPushButton:hover {{ color: #FFEA00; }}
            """)
        else:
            self.btn_fav.setText("☆")
            self.btn_fav.setStyleSheet(f"""
                QPushButton {{
                    background: transparent; color: #BBB; border: none; 
                    font-size: 16px; font-weight: bold; padding: 0px;
                }}
                QPushButton:hover {{ color: {COLORS['warning']}; }}
            """)

    # 【恢复】标签多选逻辑处理
    def _on_tag_toggled(self, tag_name, checked):
        logger.info(f"Tag Toggled: {tag_name} -> {checked}")
        if self.current_idea_id:
            try:
                self.request_tag_toggle.emit(self.current_idea_id, tag_name, checked)
                # 关键：点击标签后不关闭窗口，重置倒计时，允许连续操作
                self.hide_timer.start(2500) 
            except Exception as e:
                logger.error(f"Tag Toggle Error: {e}")

    def _on_manager_clicked(self):
        self.request_manager.emit()
        self.hide() 

    def _animate_hide(self):
        self.hide()

    def enterEvent(self, event):
        self.hide_timer.stop()
        super().enterEvent(event)

    def leaveEvent(self, event):
        self.hide_timer.start(1500)
        super().leaveEvent(event)

    def closeEvent(self, event):
        self.hide_timer.stop()
        super().closeEvent(event)
```

## 文件: ui\advanced_tag_selector.py

```python
# -*- coding: utf-8 -*-
# ui/advanced_tag_selector.py

from PyQt5.QtWidgets import (QApplication, QWidget, QVBoxLayout, QHBoxLayout, QPushButton, 
                             QLineEdit, QScrollArea, QLabel, QLayout, QSizePolicy)
from PyQt5.QtCore import Qt, pyqtSignal, QPoint, QRect, QSize
from PyQt5.QtGui import QCursor, QColor
from core.config import COLORS

class FlowLayout(QLayout):
    def __init__(self, parent=None, margin=0, spacing=-1):
        super(FlowLayout, self).__init__(parent)
        if parent is not None:
            self.setContentsMargins(margin, margin, margin, margin)
        self.setSpacing(spacing)
        self.itemList = []

    def __del__(self):
        item = self.takeAt(0)
        while item:
            item = self.takeAt(0)

    def addItem(self, item):
        self.itemList.append(item)

    def count(self):
        return len(self.itemList)

    def itemAt(self, index):
        if 0 <= index < len(self.itemList):
            return self.itemList[index]
        return None

    def takeAt(self, index):
        if 0 <= index < len(self.itemList):
            return self.itemList.pop(index)
        return None

    def expandingDirections(self):
        return Qt.Orientations(Qt.Orientation(0))

    def hasHeightForWidth(self):
        return True

    def heightForWidth(self, width):
        height = self.doLayout(QRect(0, 0, width, 0), True)
        return height

    def setGeometry(self, rect):
        super(FlowLayout, self).setGeometry(rect)
        self.doLayout(rect, False)

    def sizeHint(self):
        return self.minimumSize()

    def minimumSize(self):
        size = QSize()
        for item in self.itemList:
            size = size.expandedTo(item.minimumSize())
        margin = self.contentsMargins()
        size += QSize(margin.left() + margin.right(), margin.top() + margin.bottom())
        return size

    def doLayout(self, rect, testOnly):
        x = rect.x()
        y = rect.y()
        lineHeight = 0
        spacing = self.spacing()

        for item in self.itemList:
            wid = item.widget()
            spaceX = spacing + wid.style().layoutSpacing(QSizePolicy.PushButton, QSizePolicy.PushButton, Qt.Horizontal)
            spaceY = spacing + wid.style().layoutSpacing(QSizePolicy.PushButton, QSizePolicy.PushButton, Qt.Vertical)
            
            nextX = x + item.sizeHint().width() + spaceX
            if nextX - spaceX > rect.right() and lineHeight > 0:
                x = rect.x()
                y = y + lineHeight + spaceY
                nextX = x + item.sizeHint().width() + spaceX
                lineHeight = 0

            if not testOnly:
                item.setGeometry(QRect(QPoint(x, y), item.sizeHint()))

            x = nextX
            lineHeight = max(lineHeight, item.sizeHint().height())

        return y + lineHeight - rect.y()

class AdvancedTagSelector(QWidget):
    """
    功能强大的悬浮标签选择面板
    支持两种模式：
    1. 绑定模式 (传入 idea_id): 直接修改数据库，即时保存
    2. 选择模式 (传入 initial_tags): 仅作为选择器，返回结果，不直接修改数据库
    """
    tags_confirmed = pyqtSignal(list)

    # 【核心修改】增加 initial_tags 参数，允许传入初始标签列表
    def __init__(self, db, idea_id=None, initial_tags=None, parent=None):
        super().__init__(parent)
        self.db = db
        self.idea_id = idea_id
        
        # 初始化选中状态
        self.selected_tags = set()
        if initial_tags:
            self.selected_tags = set(initial_tags)
            
        self.tag_buttons = {} 
        self._is_closing = False 

        self.setWindowFlags(Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint | Qt.Tool)
        self.setAttribute(Qt.WA_TranslucentBackground)
        
        self._init_ui()
        self._load_tags()
        
        QApplication.instance().focusChanged.connect(self._on_focus_changed)

    def _init_ui(self):
        container = QWidget()
        container.setObjectName("mainContainer")
        container.setStyleSheet(f"""
            #mainContainer {{
                background-color: #1E1E1E; 
                border: 1px solid #333;
                border-radius: 8px;
                color: #EEE;
            }}
        """)

        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.addWidget(container)

        layout = QVBoxLayout(container)
        layout.setContentsMargins(12, 12, 12, 12)
        layout.setSpacing(10)

        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("🔍 搜索或新建...")
        self.search_input.setStyleSheet(f"""
            QLineEdit {{
                background-color: #2D2D2D; 
                border: none;
                border-bottom: 1px solid #444;
                border-radius: 4px; 
                padding: 8px; 
                font-size: 13px; 
                color: #DDD;
            }}
            QLineEdit:focus {{ border-bottom: 1px solid {COLORS['primary']}; }}
        """)
        self.search_input.textChanged.connect(self._filter_tags)
        self.search_input.returnPressed.connect(self._on_search_return)
        layout.addWidget(self.search_input)

        self.recent_label = QLabel("最近使用")
        self.recent_label.setStyleSheet("color: #888; font-size: 12px; font-weight: bold; margin-top: 5px;")
        layout.addWidget(self.recent_label)

        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setStyleSheet("""
            QScrollArea { border: none; background: transparent; }
            QWidget { background: transparent; }
            QScrollBar:vertical {
                border: none; background: #2D2D2D; width: 6px; margin: 0;
            }
            QScrollBar::handle:vertical { background: #555; border-radius: 3px; }
        """)
        
        self.scroll_content = QWidget()
        self.flow_layout = FlowLayout(self.scroll_content, margin=0, spacing=8)
        
        scroll.setWidget(self.scroll_content)
        layout.addWidget(scroll)
        
        self.setFixedSize(360, 450)

    def _load_tags(self):
        # 如果有 idea_id，从数据库加载该 idea 的标签并合并到当前选中
        if self.idea_id:
            self.selected_tags = set(self.db.get_tags(self.idea_id))
        
        c = self.db.conn.cursor()
        c.execute('''
            SELECT t.name, COUNT(it.idea_id) as cnt, MAX(i.updated_at) as last_used
            FROM tags t
            LEFT JOIN idea_tags it ON t.id = it.tag_id
            LEFT JOIN ideas i ON it.idea_id = i.id AND i.is_deleted = 0
            GROUP BY t.id 
            ORDER BY last_used DESC, cnt DESC, t.name ASC
        ''')
        all_tags = c.fetchall()
        
        self.recent_label.setText(f"最近使用 ({len(all_tags)})")

        while self.flow_layout.count():
            item = self.flow_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
        self.tag_buttons.clear()

        for row in all_tags:
            name = row[0]
            count = row[1]
            self._create_tag_chip(name, count)

    def _create_tag_chip(self, name, count=0):
        btn = QPushButton()
        btn.setCheckable(True)
        btn.setChecked(name in self.selected_tags)
        btn.setCursor(Qt.PointingHandCursor)
        
        btn.setProperty("tag_name", name)
        btn.setProperty("tag_count", count)
        
        self._update_chip_state(btn)
        
        btn.toggled.connect(lambda checked, b=btn, n=name: self._on_tag_toggled(b, n, checked))
        
        self.flow_layout.addWidget(btn)
        self.tag_buttons[name] = btn

    def _update_chip_state(self, btn):
        name = btn.property("tag_name")
        count = btn.property("tag_count")
        checked = btn.isChecked()
        
        icon = "✓" if checked else "🕒"
        text = f"{icon} {name}"
        if count > 0:
            text += f" ({count})"
        
        btn.setText(text)
        
        if checked:
            btn.setStyleSheet(f"""
                QPushButton {{
                    background-color: {COLORS['primary']};
                    color: white;
                    border: 1px solid {COLORS['primary']};
                    border-radius: 14px;
                    padding: 6px 12px;
                    font-size: 12px;
                    font-family: "Segoe UI", "Microsoft YaHei";
                }}
            """)
        else:
            btn.setStyleSheet("""
                QPushButton {
                    background-color: #2D2D2D;
                    color: #BBB;
                    border: 1px solid #444;
                    border-radius: 14px;
                    padding: 6px 12px;
                    font-size: 12px;
                    font-family: "Segoe UI", "Microsoft YaHei";
                }
                QPushButton:hover {
                    background-color: #383838;
                    border-color: #666;
                    color: white;
                }
            """)

    def _on_tag_toggled(self, button, name, checked):
        if checked:
            self.selected_tags.add(name)
        else:
            self.selected_tags.discard(name)
        self._update_chip_state(button)

    def _filter_tags(self):
        term = self.search_input.text().lower().strip()
        for name, btn in self.tag_buttons.items():
            if term in name.lower():
                btn.show()
            else:
                btn.hide()

    def _on_search_return(self):
        text = self.search_input.text().strip()
        if not text:
            self._handle_close()
            return

        found_existing = False
        for name, btn in self.tag_buttons.items():
            if name.lower() == text.lower():
                if not btn.isChecked():
                    btn.setChecked(True)
                found_existing = True
                break
        
        if not found_existing:
            self.selected_tags.add(text)
            self._create_tag_chip(text, 0)
            new_btn = self.tag_buttons.get(text)
            if new_btn: 
                new_btn.setChecked(True)
        
        self.search_input.clear()
        self._filter_tags()

    def _save_tags(self):
        """仅在绑定模式下保存到数据库"""
        # 【核心修改】如果 self.idea_id 为空，说明是纯选择模式，不进行数据库绑定操作
        if not self.idea_id:
            return

        c = self.db.conn.cursor()
        c.execute('DELETE FROM idea_tags WHERE idea_id = ?', (self.idea_id,))
        for tag_name in self.selected_tags:
            c.execute('INSERT OR IGNORE INTO tags (name) VALUES (?)', (tag_name,))
            c.execute('SELECT id FROM tags WHERE name = ?', (tag_name,))
            result = c.fetchone()
            if result:
                tag_id = result[0]
                c.execute('INSERT INTO idea_tags (idea_id, tag_id) VALUES (?, ?)', (self.idea_id, tag_id))
        self.db.conn.commit()

    def _is_child_widget(self, widget):
        if widget is None: return False
        current = widget
        while current:
            if current is self: return True
            current = current.parent()
        return False

    def _on_focus_changed(self, old_widget, new_widget):
        if self._is_closing or not self.isVisible(): return
        if not self._is_child_widget(new_widget):
            self._handle_close()

    def _handle_close(self):
        if self._is_closing: return
        self._is_closing = True
        try:
            QApplication.instance().focusChanged.disconnect(self._on_focus_changed)
        except: pass
        
        self._save_tags()
        self.tags_confirmed.emit(list(self.selected_tags))
        self.close()

    def show_at_cursor(self):
        cursor_pos = QCursor.pos()
        screen_geo = QApplication.desktop().screenGeometry()
        x, y = cursor_pos.x() + 15, cursor_pos.y() + 15
        if x + self.width() > screen_geo.right(): x = cursor_pos.x() - self.width() - 15
        if y + self.height() > screen_geo.bottom(): y = screen_geo.bottom() - self.height() - 15
        self.move(x, y)
        self.show()
        self.activateWindow()
        self.search_input.setFocus()
```

## 文件: ui\ball.py

```python
# -*- coding: utf-8 -*-
# ui/ball.py
import math
import random
from PyQt5.QtWidgets import QWidget, QMenu
from PyQt5.QtCore import Qt, pyqtSignal, QPoint, QTimer, QRectF, QMimeData, QUrl
from PyQt5.QtGui import (QPainter, QColor, QPen, QBrush, QDrag,
                         QLinearGradient, QPainterPath, QPolygonF, QFont)
from core.settings import save_setting
from core.logger import get_logger

logger = get_logger('FloatingBall')

class FloatingBall(QWidget):
    request_show_quick_window = pyqtSignal()
    request_show_main_window = pyqtSignal()
    request_quit_app = pyqtSignal()
    request_manage_tags = pyqtSignal() 
    double_clicked = pyqtSignal()

    # --- 皮肤枚举 ---
    SKIN_MOCHA = 0
    SKIN_CLASSIC = 1
    SKIN_ROYAL = 2
    SKIN_MATCHA = 3
    SKIN_OPEN = 4

    def __init__(self, main_window):
        super().__init__()
        self.mw = main_window 
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint | Qt.Tool)
        self.setAttribute(Qt.WA_TranslucentBackground)
        self.setFixedSize(120, 120) 
        self.setAcceptDrops(True)

        self.dragging = False
        self.is_hovering = False 
        
        self.current_skin = self.SKIN_MOCHA 
        self.is_writing = False 
        self.write_timer = 0     
        self.offset = QPoint()
        self.transit_files = [] 
        
        # 动画参数
        self.time_step = 0.0
        self.pen_x = 0.0
        self.pen_y = 0.0
        self.pen_angle = -45.0 
        self.book_y = 0.0
        self.particles = [] 

        self.timer = QTimer(self)
        self.timer.timeout.connect(self._update_physics)
        self.timer.start(16) 
        logger.info("FloatingBall: initialized")

    def trigger_clipboard_feedback(self):
        self.is_writing = True
        self.write_timer = 0

    def switch_skin(self, skin_id):
        self.current_skin = skin_id
        self.update()

    def _update_physics(self):
        try:
            self.time_step += 0.05
            
            idle_pen_y = math.sin(self.time_step * 0.5) * 4
            idle_book_y = math.sin(self.time_step * 0.5 - 1.0) * 2
            
            target_pen_angle = -45
            target_pen_x = 0
            target_pen_y = idle_pen_y
            
            if self.is_writing or self.is_hovering:
                self.write_timer += 1
                target_pen_angle = -65 
                write_speed = self.time_step * 3.0
                flow_x = math.sin(write_speed) * 8     
                flow_y = math.cos(write_speed * 2) * 2 
                
                target_pen_x = flow_x
                target_pen_y = 5 + flow_y 
                idle_book_y = -3

                if self.is_writing and self.write_timer > 90: 
                    self.is_writing = False
            
            easing = 0.1
            self.pen_angle += (target_pen_angle - self.pen_angle) * easing
            self.pen_x += (target_pen_x - self.pen_x) * easing
            self.pen_y += (target_pen_y - self.pen_y) * easing
            self.book_y += (idle_book_y - self.book_y) * easing

            self._update_particles()
            self.update()
        except Exception:
            pass

    def _update_particles(self):
        if (self.is_writing or self.is_hovering) and len(self.particles) < 15:
            if random.random() < 0.3:
                rad = math.radians(self.pen_angle)
                tip_len = 35 
                is_gold = random.random() > 0.3
                
                type_str = 'file' if self.transit_files else ('gold' if is_gold else 'ink')
                
                self.particles.append({
                    'x': self.width()/2 + self.pen_x - math.sin(rad)*tip_len,
                    'y': self.height()/2 + self.pen_y + math.cos(rad)*tip_len,
                    'vx': random.uniform(-0.5, 0.5),
                    'vy': random.uniform(0.5, 1.5),
                    'life': 1.0,
                    'size': random.uniform(1, 3),
                    'type': type_str
                })

        alive = []
        for p in self.particles:
            p['x'] += p['vx']
            p['y'] += p['vy']
            p['life'] -= 0.03
            p['size'] *= 0.96
            if p['life'] > 0:
                alive.append(p)
        self.particles = alive

    def paintEvent(self, e):
        try:
            p = QPainter(self)
            p.setRenderHint(QPainter.Antialiasing)
            
            w, h = self.width(), self.height()
            cx, cy = w / 2, h / 2
            
            # 1. 阴影
            p.save()
            p.translate(cx, cy + self.book_y + 15)
            p.setPen(Qt.NoPen)
            p.setBrush(QColor(0, 0, 0, 40))
            p.drawEllipse(QRectF(-35, -10, 70, 20))
            p.restore()

            # 2. 笔记本
            p.save()
            p.translate(cx, cy + self.book_y)
            if self.current_skin != self.SKIN_OPEN:
                p.rotate(-6)
            
            if self.current_skin == self.SKIN_MOCHA: self._draw_book_mocha(p)
            elif self.current_skin == self.SKIN_CLASSIC: self._draw_book_classic(p)
            elif self.current_skin == self.SKIN_ROYAL: self._draw_book_royal(p)
            elif self.current_skin == self.SKIN_MATCHA: self._draw_book_matcha(p)
            elif self.current_skin == self.SKIN_OPEN: self._draw_book_open(p)
            p.restore()

            # 中转状态
            if self.transit_files:
                p.save()
                p.translate(cx, cy + self.book_y - 35)
                offset_y = math.sin(self.time_step * 0.2) * 3
                p.translate(0, offset_y)
                p.setFont(QFont('Segoe UI Emoji', 24))
                p.setPen(QColor(0,0,0,100))
                p.drawText(QRectF(-20, -20, 40, 40).translated(1,1), Qt.AlignCenter, "📂")
                p.setPen(QColor(255,255,255))
                p.drawText(QRectF(-20, -20, 40, 40), Qt.AlignCenter, "📂")
                p.restore()

            # 3. 笔影
            p.save()
            p.translate(cx + self.pen_x + 5, cy + self.book_y - 2 + self.pen_y * 0.5) 
            p.rotate(self.pen_angle)
            p.setPen(Qt.NoPen)
            p.setBrush(QColor(40, 30, 20, 50)) 
            p.drawRoundedRect(QRectF(-4, -15, 8, 40), 4, 4)
            p.restore()

            # 4. 钢笔
            p.save()
            p.translate(cx + self.pen_x, cy + self.pen_y - 15)
            p.rotate(self.pen_angle)
            self._draw_universal_pen(p)
            p.restore()
            
            # 5. 粒子
            for pt in self.particles:
                alpha = int(255 * pt['life'])
                if alpha <= 0: continue
                
                if pt['type'] == 'file': c = QColor(0, 255, 127, alpha)
                elif pt['type'] == 'gold': c = QColor(255, 215, 0, alpha)
                else:
                    if self.current_skin == self.SKIN_ROYAL: c = QColor(25, 25, 112, int(alpha*0.8))
                    else: c = QColor(60, 0, 0, int(alpha*0.8))
                p.setPen(Qt.NoPen)
                p.setBrush(c)
                p.drawEllipse(QRectF(pt['x']-pt['size']/2, pt['y']-pt['size']/2, pt['size'], pt['size']))
        except Exception:
            pass

    def _draw_universal_pen(self, p):
        w_pen, h_pen = 12, 46
        if self.current_skin == self.SKIN_ROYAL:
            c_light, c_mid, c_dark = QColor(60, 60, 70), QColor(20, 20, 25), QColor(0, 0, 0)
        elif self.current_skin == self.SKIN_CLASSIC:
            c_light, c_mid, c_dark = QColor(80, 80, 80), QColor(30, 30, 30), QColor(10, 10, 10)
        elif self.current_skin == self.SKIN_MATCHA:
            c_light, c_mid, c_dark = QColor(255, 255, 250), QColor(240, 240, 230), QColor(200, 200, 190)
        else:
            c_light, c_mid, c_dark = QColor(180, 60, 70), QColor(140, 20, 30), QColor(60, 5, 10)

        body_grad = QLinearGradient(-w_pen/2, 0, w_pen/2, 0)
        body_grad.setColorAt(0.0, c_light) 
        body_grad.setColorAt(0.5, c_mid) 
        body_grad.setColorAt(1.0, c_dark) 

        path_body = QPainterPath()
        path_body.addRoundedRect(QRectF(-w_pen/2, -h_pen/2, w_pen, h_pen), 5, 5)
        p.setPen(Qt.NoPen)
        p.setBrush(body_grad)
        p.drawPath(path_body)
        
        path_tip = QPainterPath()
        tip_h = 14
        path_tip.moveTo(-w_pen/2 + 3, h_pen/2)
        path_tip.lineTo(w_pen/2 - 3, h_pen/2)
        path_tip.lineTo(0, h_pen/2 + tip_h)
        path_tip.closeSubpath()
        
        tip_grad = QLinearGradient(-5, 0, 5, 0)
        tip_grad.setColorAt(0, QColor(240, 230, 180)) 
        tip_grad.setColorAt(1, QColor(190, 170, 100)) 
        p.setBrush(tip_grad)
        p.drawPath(path_tip)
        
        p.setBrush(QColor(220, 200, 140))
        p.drawRect(QRectF(-w_pen/2, h_pen/2 - 4, w_pen, 4))
        p.setBrush(QColor(210, 190, 130)) 
        p.drawRoundedRect(QRectF(-1.5, -h_pen/2 + 6, 3, 24), 1.5, 1.5)

    def _draw_book_mocha(self, p):
        w, h = 56, 76
        p.setBrush(QColor(245, 240, 225))
        p.drawRoundedRect(QRectF(-w/2+6, -h/2+6, w, h), 3, 3)
        grad = QLinearGradient(-w, -h, w, h)
        grad.setColorAt(0, QColor(90, 60, 50))
        grad.setColorAt(1, QColor(50, 30, 25))
        p.setBrush(grad)
        p.drawRoundedRect(QRectF(-w/2, -h/2, w, h), 3, 3)
        p.setBrush(QColor(120, 20, 30))
        p.drawRect(QRectF(w/2 - 15, -h/2, 8, h))

    def _draw_book_classic(self, p):
        w, h = 54, 74
        p.setBrush(QColor(235, 235, 230))
        p.drawRoundedRect(QRectF(-w/2+6, -h/2+6, w, h), 3, 3)
        grad = QLinearGradient(-w, -h, w, h)
        grad.setColorAt(0, QColor(60, 60, 65))
        grad.setColorAt(1, QColor(20, 20, 25))
        p.setBrush(grad)
        p.drawRoundedRect(QRectF(-w/2, -h/2, w, h), 3, 3)
        p.setBrush(QColor(10, 10, 10, 200))
        p.drawRect(QRectF(w/2 - 12, -h/2, 6, h))

    def _draw_book_royal(self, p):
        w, h = 58, 76
        p.setBrush(QColor(240, 240, 235))
        p.drawRoundedRect(QRectF(-w/2+6, -h/2+6, w, h), 2, 2)
        grad = QLinearGradient(-w, -h, w, 0)
        grad.setColorAt(0, QColor(40, 40, 100))
        grad.setColorAt(1, QColor(10, 10, 50))
        p.setBrush(grad)
        p.drawRoundedRect(QRectF(-w/2, -h/2, w, h), 2, 2)
        p.setBrush(QColor(218, 165, 32))
        c_size = 12
        p.drawPolygon(QPolygonF([QPoint(int(w/2), int(-h/2)), QPoint(int(w/2-c_size), int(-h/2)), QPoint(int(w/2), int(-h/2+c_size))]))

    def _draw_book_matcha(self, p):
        w, h = 54, 74
        p.setBrush(QColor(250, 250, 245))
        p.drawRoundedRect(QRectF(-w/2+5, -h/2+5, w, h), 3, 3)
        grad = QLinearGradient(-w, -h, w, h)
        grad.setColorAt(0, QColor(160, 190, 150))
        grad.setColorAt(1, QColor(100, 130, 90))
        p.setBrush(grad)
        p.drawRoundedRect(QRectF(-w/2, -h/2, w, h), 3, 3)
        p.setBrush(QColor(255, 255, 255, 200))
        p.drawRoundedRect(QRectF(-w/2+10, -20, 34, 15), 2, 2)

    def _draw_book_open(self, p):
        w, h = 80, 50
        p.rotate(-5)
        path = QPainterPath()
        path.moveTo(-w/2, -h/2); path.lineTo(0, -h/2 + 4)
        path.lineTo(w/2, -h/2); path.lineTo(w/2, h/2)
        path.lineTo(0, h/2 + 4); path.lineTo(-w/2, h/2); path.closeSubpath()
        p.setBrush(QColor(248, 248, 245))
        p.setPen(Qt.NoPen)
        p.drawPath(path)
        grad = QLinearGradient(-10, 0, 10, 0)
        grad.setColorAt(0, QColor(0,0,0,0)); grad.setColorAt(0.5, QColor(0,0,0,20)); grad.setColorAt(1, QColor(0,0,0,0))
        p.setBrush(grad)
        p.drawRect(QRectF(-5, -h/2+4, 10, h-4))
        p.setPen(QPen(QColor(200, 200, 200), 1))
        for y in range(int(-h/2)+15, int(h/2), 7):
            p.drawLine(int(-w/2+5), y, -5, y+2)
            p.drawLine(5, y+2, int(w/2-5), y)

    def dragEnterEvent(self, e):
        if e.mimeData().hasUrls():
            e.accept()
            self.is_hovering = True
            self.update()
        elif e.mimeData().hasText():
            e.accept()
            self.is_hovering = True
            self.update()
        else:
            e.ignore()

    def dragLeaveEvent(self, e):
        self.is_hovering = False
        self.update()

    def dropEvent(self, e):
        self.is_hovering = False
        if e.mimeData().hasUrls():
            urls = e.mimeData().urls()
            files = [u.toLocalFile() for u in urls if u.isLocalFile()]
            if files:
                self.transit_files = files
                self.trigger_clipboard_feedback()
            e.accept()
            self.update()
            return
        text = e.mimeData().text()
        if text.strip():
            self.mw.quick_add_idea(text)
            self.trigger_clipboard_feedback()
            e.acceptProposedAction()
        self.update()

    def mousePressEvent(self, e):
        if e.button() == Qt.LeftButton:
            if self.transit_files:
                drag = QDrag(self)
                mime = QMimeData()
                urls = [QUrl.fromLocalFile(f) for f in self.transit_files]
                mime.setUrls(urls)
                drag.setMimeData(mime)
                drag.setPixmap(self.grab())
                drag.exec_(Qt.CopyAction)
                self.transit_files = [] 
                self.update()
                return
            self.dragging = True
            self.offset = e.pos()
            self.pen_y += 3

    def mouseMoveEvent(self, e):
        if self.dragging:
            self.move(self.mapToGlobal(e.pos() - self.offset))

    def mouseReleaseEvent(self, e):
        if self.dragging:
            self.dragging = False
            pos = self.pos()
            save_setting('floating_ball_pos', {'x': pos.x(), 'y': pos.y()})

    def mouseDoubleClickEvent(self, e):
        if e.button() == Qt.LeftButton:
            self.double_clicked.emit()

    def contextMenuEvent(self, e):
        m = QMenu(self)
        m.setStyleSheet("""
            QMenu { background-color: #2b2b2b; color: #f0f0f0; border: 1px solid #444; border-radius: 5px; }
            QMenu::item { padding: 6px 25px; }
            QMenu::item:selected { background-color: #5D4037; color: #fff; }
            QMenu::separator { background-color: #444; height: 1px; margin: 4px 0; }
        """)
        
        skin_menu = m.addMenu("🎨  切换外观")
        skins = [
            ("☕  摩卡·勃艮第", self.SKIN_MOCHA),
            ("♟️  经典黑金", self.SKIN_CLASSIC),
            ("📘  皇家蓝", self.SKIN_ROYAL),
            ("🍵  抹茶绿", self.SKIN_MATCHA),
            ("📖  摊开手稿", self.SKIN_OPEN)
        ]
        for name, sid in skins:
            act = skin_menu.addAction(name)
            act.triggered.connect(lambda _, s=sid: self.switch_skin(s))
        
        m.addSeparator()
        if self.transit_files:
             m.addAction('🗑️ 清空暂存文件', self._clear_transit)
             m.addSeparator()

        m.addAction('⚡ 打开快速笔记', self.request_show_quick_window.emit)
        m.addAction('💻 打开主界面', self.request_show_main_window.emit)
        m.addAction('➕ 新建灵感', self.mw.new_idea)
        m.addSeparator()
        m.addAction('🏷️ 管理常用标签', self.request_manage_tags.emit)
        m.addSeparator()
        m.addAction('❌ 退出', self.request_quit_app.emit)
        
        m.exec_(e.globalPos())

    def _clear_transit(self):
        self.transit_files = []
        self.update()
```

## 文件: ui\cards.py

```python
# -*- coding: utf-8 -*-
# ui/cards.py
import sys
from PyQt5.QtWidgets import QFrame, QVBoxLayout, QHBoxLayout, QLabel, QApplication, QSizePolicy
from PyQt5.QtCore import Qt, pyqtSignal, QMimeData, QSize
from PyQt5.QtGui import QDrag, QPixmap, QImage
from core.config import STYLES

class IdeaCard(QFrame):
    # (id, is_ctrl, is_shift)
    selection_requested = pyqtSignal(int, bool, bool)
    double_clicked = pyqtSignal(int)

    def __init__(self, data, db, parent=None):
        super().__init__(parent)
        self.setAttribute(Qt.WA_StyledBackground)
        
        self.data = data
        self.db = db
        self.id = data[0]
        self.setCursor(Qt.PointingHandCursor)
        
        # --- 状态变量 ---
        self._drag_start_pos = None
        self._is_potential_click = False
        
        # 这是一个占位符，会在 main_window 中被赋值
        self.get_selected_ids_func = None
        
        self._init_ui()

    def _init_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(15, 12, 15, 12)
        layout.setSpacing(8) # 增加一点内部间距
        
        # --- 1. 顶部：标题 + 图标 ---
        top = QHBoxLayout()
        top.setSpacing(8)
        
        # 标题 (对于图片，如果标题是默认的"[图片]"，可以显示得淡一点，或者保持原样)
        title_text = self.data[1]
        title = QLabel(title_text)
        title.setStyleSheet("font-size:15px; font-weight:bold; background:transparent; color:white;")
        title.setWordWrap(False)
        top.addWidget(title, stretch=1)
        
        # 图标区域 (置顶/收藏/锁定)
        icon_layout = QHBoxLayout()
        icon_layout.setSpacing(4)
        
        # 锁定状态判断: 数据列最后一位是 is_locked
        # 假设数据列顺序: 0-id ... 13-is_locked (如果表结构是新建的)
        # 为稳健起见，尝试获取最后一位，如果是 1 则显示锁
        is_locked = False
        if len(self.data) >= 14:
            is_locked = self.data[13]
        
        if is_locked:
            lock_icon = QLabel('🔒')
            lock_icon.setStyleSheet("background:transparent; font-size:12px;")
            icon_layout.addWidget(lock_icon)

        if self.data[4]:  # is_pinned
            pin_icon = QLabel('📌')
            pin_icon.setStyleSheet("background:transparent; font-size:12px;")
            icon_layout.addWidget(pin_icon)
        if self.data[5]:  # is_favorite
            fav_icon = QLabel('⭐')
            fav_icon.setStyleSheet("background:transparent; font-size:12px;")
            icon_layout.addWidget(fav_icon)
            
        top.addLayout(icon_layout)
        layout.addLayout(top)
        
        # --- 2. 中部：内容预览 (文本 或 图片) ---
        # 解析数据类型
        # data结构: 0:id, 1:title, 2:content ... 10:item_type, 11:data_blob
        item_type = self.data[10] if len(self.data) > 10 and self.data[10] else 'text'
        
        if item_type == 'image':
            # === 图片模式 ===
            blob_data = self.data[11] if len(self.data) > 11 else None
            if blob_data:
                pixmap = QPixmap()
                pixmap.loadFromData(blob_data)
                
                if not pixmap.isNull():
                    img_label = QLabel()
                    # 限制最大显示高度，防止卡片过大
                    max_height = 160
                    if pixmap.height() > max_height:
                        pixmap = pixmap.scaledToHeight(max_height, Qt.SmoothTransformation)
                    
                    # 如果宽度也太宽，限制宽度
                    if pixmap.width() > 400: # 假设卡片大概这么宽
                        pixmap = pixmap.scaledToWidth(400, Qt.SmoothTransformation)
                        
                    img_label.setPixmap(pixmap)
                    img_label.setAlignment(Qt.AlignLeft | Qt.AlignTop)
                    img_label.setStyleSheet("background: transparent; border-radius: 4px;")
                    layout.addWidget(img_label)
                else:
                    err_label = QLabel("[图片无法加载]")
                    err_label.setStyleSheet("color: #666; font-style: italic;")
                    layout.addWidget(err_label)
        else:
            # === 文本/文件模式 ===
            if self.data[2]:
                content_str = self.data[2].strip()
                
                # 获取一段较长的文本，让 Label 自动换行
                preview_text = content_str[:300].replace('\n', ' ').replace('\r', '')
                if len(content_str) > 300:
                    preview_text += "..."
                    
                content = QLabel(preview_text)
                content.setStyleSheet("""
                    color: rgba(255,255,255,180); 
                    margin-top: 2px; 
                    background: transparent; 
                    font-size: 13px;
                    line-height: 1.4;
                """)
                content.setWordWrap(True)
                content.setAlignment(Qt.AlignTop | Qt.AlignLeft)
                # 限制高度，大概显示 3 行文字的高度
                content.setMaximumHeight(65) 
                layout.addWidget(content)
            
        # --- 3. 底部：时间 + 标签 ---
        bot = QHBoxLayout()
        bot.setSpacing(6)
        
        # 时间
        time_str = self.data[7][:16] # YYYY-MM-DD HH:mm
        time_label = QLabel(f'🕒 {time_str}')
        time_label.setStyleSheet("color:rgba(255,255,255,100); font-size:11px; background:transparent;")
        bot.addWidget(time_label)
        
        bot.addStretch()
        
        # 标签
        tags = self.db.get_tags(self.id)
        visible_tags = tags[:3]
        remaining = len(tags) - 3
        
        for tag in visible_tags:
            tag_label = QLabel(f"#{tag}")
            tag_label.setStyleSheet("""
                background: rgba(255,255,255,0.1); 
                border-radius: 4px; 
                padding: 2px 6px; 
                font-size: 10px; 
                color: rgba(255,255,255,180);
            """)
            bot.addWidget(tag_label)
            
        if remaining > 0:
            more_label = QLabel(f'+{remaining}')
            more_label.setStyleSheet("""
                background: rgba(74,144,226,0.3); 
                border-radius: 4px; 
                padding: 2px 6px; 
                font-size: 10px; 
                color: #4a90e2;
                font-weight:bold;
            """)
            bot.addWidget(more_label)
            
        layout.addLayout(bot)
        self.update_selection(False)

    def update_selection(self, selected):
        bg_color = self.data[3]
        
        # 基础样式
        base_style = f"""
            IdeaCard {{
                background-color: {bg_color};
                {STYLES['card_base']}
                padding: 0px;
            }}
            QLabel {{
                background-color: transparent;
                border: none;
            }}
        """

        if selected:
            # 选中状态：白色粗边框
            border_style = "border: 2px solid white;"
        else:
            # 未选中状态：透明微弱边框，悬停变亮
            border_style = """
                border: 1px solid rgba(255,255,255,0.1);
            """
            
        # 合并 hover 效果到样式表中
        final_style = base_style + f"""
            IdeaCard {{ {border_style} }}
            IdeaCard:hover {{
                border: 2px solid rgba(255,255,255,0.4);
            }}
        """
        
        # 如果选中了，需要覆盖 hover 样式，保持选中状态的边框
        if selected:
            final_style += """
                IdeaCard:hover {
                    border: 2px solid white;
                }
            """
            
        self.setStyleSheet(final_style)

    def mousePressEvent(self, e):
        if e.button() == Qt.LeftButton:
            self._drag_start_pos = e.pos()
            self._is_potential_click = True
        super().mousePressEvent(e)

    def mouseMoveEvent(self, e):
        if not (e.buttons() & Qt.LeftButton) or not self._drag_start_pos:
            return
        
        if (e.pos() - self._drag_start_pos).manhattanLength() < QApplication.startDragDistance():
            return
        
        # 拖拽开始，取消点击判定
        self._is_potential_click = False
        
        drag = QDrag(self)
        mime = QMimeData()
        
        # --- 批量拖拽支持 ---
        ids_to_move = [self.id]
        if self.get_selected_ids_func:
            selected_ids = self.get_selected_ids_func()
            if self.id in selected_ids:
                ids_to_move = selected_ids
        
        mime.setData('application/x-idea-ids', (','.join(map(str, ids_to_move))).encode('utf-8'))
        mime.setData('application/x-idea-id', str(self.id).encode())
        
        drag.setMimeData(mime)
        
        pixmap = self.grab().scaledToWidth(200, Qt.SmoothTransformation)
        drag.setPixmap(pixmap)
        drag.setHotSpot(e.pos())
        
        drag.exec_(Qt.MoveAction)
        
    def mouseReleaseEvent(self, e):
        if self._is_potential_click and e.button() == Qt.LeftButton:
            modifiers = QApplication.keyboardModifiers()
            is_ctrl = bool(modifiers & Qt.ControlModifier)
            is_shift = bool(modifiers & Qt.ShiftModifier)
            self.selection_requested.emit(self.id, is_ctrl, is_shift)

        self._drag_start_pos = None
        self._is_potential_click = False
        super().mouseReleaseEvent(e)

    def mouseDoubleClickEvent(self, e):
        if e.button() == Qt.LeftButton:
            self.double_clicked.emit(self.id)
        super().mouseDoubleClickEvent(e)
```

## 文件: ui\common_tags.py

```python
# -*- coding: utf-8 -*-
# ui/common_tags.py

from PyQt5.QtWidgets import (QWidget, QPushButton, QMenu, QInputDialog, 
                             QSizePolicy, QHBoxLayout)
from PyQt5.QtCore import Qt, pyqtSignal
from core.config import COLORS
from core.settings import load_setting, save_setting

class CommonTags(QWidget):
    # 修改信号：传递 (标签名, 是否选中)
    tag_toggled = pyqtSignal(str, bool) 
    manager_requested = pyqtSignal()
    refresh_requested = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.limit = load_setting('common_tags_limit', 5)
        self.tag_buttons = [] 
        
        self._init_ui()
        self.reload_tags()

    def _init_ui(self):
        self.layout = QHBoxLayout(self)
        self.layout.setContentsMargins(0, 0, 0, 0)
        self.layout.setSpacing(8)
        
        self.setAttribute(Qt.WA_TranslucentBackground)
        self.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Minimum)
        
        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self._show_context_menu)

    def reload_tags(self):
        # 清理旧组件
        while self.layout.count():
            item = self.layout.takeAt(0)
            if item and item.widget():
                item.widget().deleteLater()
        
        self.tag_buttons.clear()

        raw_tags = load_setting('manual_common_tags', ['工作', '待办', '重要'])
        limit = load_setting('common_tags_limit', 5)

        processed_tags = []
        for item in raw_tags:
            if isinstance(item, str):
                processed_tags.append({'name': item, 'visible': True})
            elif isinstance(item, dict):
                processed_tags.append(item)
        
        visible_tags = [t for t in processed_tags if t.get('visible', True)]
        display_tags = visible_tags[:limit]

        for tag in display_tags:
            name = tag['name']
            btn = QPushButton(name)
            # --- 核心修改：启用 Checkable (开关模式) ---
            btn.setCheckable(True) 
            btn.setCursor(Qt.PointingHandCursor)
            btn.setFixedHeight(26)
            
            # --- 样式逻辑：增加 :checked 状态 ---
            btn.setStyleSheet(f"""
                QPushButton {{
                    background-color: rgba(255, 255, 255, 0.08);
                    color: #CCC;
                    border: 1px solid rgba(255, 255, 255, 0.15);
                    border-radius: 13px;
                    padding: 0px 12px;
                    font-size: 12px;
                    font-family: "Segoe UI", "Microsoft YaHei";
                }}
                /* 悬停 */
                QPushButton:hover {{
                    background-color: rgba(255, 255, 255, 0.15);
                    color: #FFF;
                    border: 1px solid rgba(255, 255, 255, 0.3);
                }}
                /* --- 选中高亮状态 (蓝色) --- */
                QPushButton:checked {{
                    background-color: {COLORS['primary']}; 
                    border: 1px solid {COLORS['primary']}; 
                    color: white;
                    font-weight: bold;
                }}
            """)
            
            # 连接 Toggle 信号
            btn.toggled.connect(lambda checked, n=name: self.tag_toggled.emit(n, checked))
            
            self.layout.addWidget(btn)
            self.tag_buttons.append(btn)

        # 管理按钮
        btn_edit = QPushButton("⚙")
        btn_edit.setToolTip("管理标签")
        btn_edit.setCursor(Qt.PointingHandCursor)
        btn_edit.setFixedSize(26, 26)
        btn_edit.setStyleSheet(f"""
            QPushButton {{
                background-color: transparent;
                color: #666;
                border: none;
                border-radius: 13px;
                font-size: 16px;
                padding-bottom: 1px;
            }}
            QPushButton:hover {{
                background-color: rgba(255,255,255,0.1);
                color: #EEE;
            }}
        """)
        btn_edit.clicked.connect(self.manager_requested.emit)
        self.layout.addWidget(btn_edit)
        
        self.refresh_requested.emit()

    def reset_selection(self):
        """重置所有按钮为未选中状态（防止下一个弹窗继承上一个的状态）"""
        for btn in self.tag_buttons:
            # 阻断信号，防止重置时触发数据库操作
            btn.blockSignals(True)
            btn.setChecked(False)
            btn.blockSignals(False)

    def _show_context_menu(self, pos):
        menu = QMenu(self)
        menu.setStyleSheet(f"""
            QMenu {{ background-color: #2D2D2D; color: #EEE; border: 1px solid #444; border-radius: 6px; padding: 4px; }}
            QMenu::item {{ padding: 6px 20px; border-radius: 4px; }}
            QMenu::item:selected {{ background-color: {COLORS['primary']}; color: white; }}
        """)
        action_set_num = menu.addAction(f"🔢 显示数量 (当前: {self.limit})")
        action_set_num.triggered.connect(self._set_tag_limit)
        menu.exec_(self.mapToGlobal(pos))

    def _set_tag_limit(self):
        num, ok = QInputDialog.getInt(self, "设置", "显示数量:", value=self.limit, min=1, max=20)
        if ok:
            self.limit = num
            save_setting('common_tags_limit', num)
            self.reload_tags()
```

## 文件: ui\common_tags_manager.py

```python
﻿# -*- coding: utf-8 -*-
# ui/common_tags_manager.py

from PyQt5.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QListWidget, 
                             QLineEdit, QPushButton, QLabel, QListWidgetItem, 
                             QMessageBox, QAbstractItemView, QSpinBox, QCheckBox, QWidget, QGraphicsDropShadowEffect)
from PyQt5.QtCore import Qt, QSize
from PyQt5.QtGui import QColor
from core.config import COLORS
from core.settings import load_setting, save_setting

class CommonTagsManager(QDialog):
    """
    常用标签管理界面 (现代卡片风格版)
    - 视觉升级：独立的圆角卡片列表，去除传统网格感
    - 修复：滚动条样式统一为现代极简风格
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        
        # 加载数据
        raw_tags = load_setting('manual_common_tags', ['工作', '待办', '重要'])
        self.tags_data = []
        for item in raw_tags:
            if isinstance(item, str):
                self.tags_data.append({'name': item, 'visible': True})
            elif isinstance(item, dict):
                self.tags_data.append(item)
                
        self.limit = load_setting('common_tags_limit', 5)
        
        self.setWindowTitle("🏷️ 管理常用标签")
        self.setWindowFlags(Qt.Dialog | Qt.FramelessWindowHint)
        self.setAttribute(Qt.WA_TranslucentBackground)
        self.setFixedSize(340, 520) 
        
        self._init_ui()
        self._refresh_list()

    def _init_ui(self):
        # 主容器
        container = QWidget(self)
        container.setGeometry(10, 10, 320, 500) 
        container.setStyleSheet(f"""
            QWidget {{
                background-color: #1E1E1E;
                border: 1px solid #333;
                border-radius: 12px;
                color: #EEE;
            }}
        """)
        
        # 窗口阴影
        shadow = QGraphicsDropShadowEffect(self)
        shadow.setBlurRadius(20)
        shadow.setXOffset(0)
        shadow.setYOffset(5)
        shadow.setColor(QColor(0, 0, 0, 100))
        container.setGraphicsEffect(shadow)

        # --- 主布局 ---
        layout = QVBoxLayout(container)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)
        
        # 1. 顶部标题栏 (标题 + 关闭按钮)
        header_layout = QHBoxLayout()
        header_layout.setContentsMargins(0, 0, 0, 0)
        
        title = QLabel("管理常用标签")
        title.setStyleSheet("font-weight: bold; font-size: 15px; border: none; color: #DDD;")
        header_layout.addWidget(title)
        
        header_layout.addStretch()
        
        self.btn_close = QPushButton("×")
        self.btn_close.setFixedSize(32, 32)
        self.btn_close.setCursor(Qt.PointingHandCursor)
        self.btn_close.setToolTip("保存并关闭")
        self.btn_close.clicked.connect(self._save_and_close)
        self.btn_close.setStyleSheet("""
            QPushButton { 
                background-color: transparent; 
                border: none; 
                font-size: 20px; 
                color: #888; 
                font-family: Arial;
                border-radius: 4px;
            } 
            QPushButton:hover { 
                background-color: #E81123; 
                color: white; 
            }
        """)
        header_layout.addWidget(self.btn_close)
        
        layout.addLayout(header_layout)
        
        # 2. 输入区
        input_container = QWidget()
        input_container.setStyleSheet("background: transparent; border: none;")
        input_layout = QHBoxLayout(input_container)
        input_layout.setContentsMargins(0, 0, 0, 0)
        input_layout.setSpacing(8)
        
        self.inp_tag = QLineEdit()
        self.inp_tag.setPlaceholderText("输入新标签...")
        self.inp_tag.setStyleSheet(f"""
            QLineEdit {{
                background-color: #2D2D2D; 
                border: 1px solid #444; 
                border-radius: 6px; 
                padding: 8px 10px; 
                color: white;
                font-size: 13px;
            }}
            QLineEdit:focus {{ border-color: {COLORS['primary']}; background-color: #333; }}
        """)
        self.inp_tag.returnPressed.connect(self._add_tag)
        
        btn_add = QPushButton("添加")
        btn_add.setCursor(Qt.PointingHandCursor)
        btn_add.setStyleSheet(f"""
            QPushButton {{
                background-color: {COLORS['primary']}; 
                color: white; 
                border: none; 
                border-radius: 6px; 
                padding: 8px 16px;
                font-weight: bold;
                font-size: 13px;
            }}
            QPushButton:hover {{ background-color: #357ABD; }}
        """)
        btn_add.clicked.connect(self._add_tag)
        
        input_layout.addWidget(self.inp_tag)
        input_layout.addWidget(btn_add)
        layout.addWidget(input_container)
        
        # 3. 数量限制
        limit_layout = QHBoxLayout()
        lbl_limit = QLabel("悬浮条最大显示数量:")
        lbl_limit.setStyleSheet("color: #AAA; font-size: 12px; border:none;")
        
        self.spin_limit = QSpinBox()
        self.spin_limit.setRange(1, 10)
        self.spin_limit.setValue(self.limit)
        self.spin_limit.setFixedWidth(60)
        self.spin_limit.setStyleSheet("""
            QSpinBox { 
                background-color: #2D2D2D; 
                border: 1px solid #444; 
                color: white; 
                padding: 4px; 
                border-radius: 4px; 
            }
            QSpinBox:focus { border-color: #555; }
            QSpinBox::up-button, QSpinBox::down-button { background: none; border: none; }
        """)
        
        limit_layout.addWidget(lbl_limit)
        limit_layout.addWidget(self.spin_limit)
        limit_layout.addStretch()
        layout.addLayout(limit_layout)
        
        # 4. 列表区
        lbl_hint = QLabel("💡 拖拽调整顺序，勾选控制显示")
        lbl_hint.setStyleSheet("color: #666; font-size: 11px; border:none; margin-bottom: 5px;")
        layout.addWidget(lbl_hint)

        self.list_widget = QListWidget()
        # 【关键修复】在此处注入 QScrollBar 样式，覆盖系统默认
        self.list_widget.setStyleSheet(f"""
            QListWidget {{ 
                background-color: transparent; 
                border: none; 
                outline: none; 
            }}
            QListWidget::item {{ 
                background-color: #2D2D2D; 
                color: #DDD; 
                border: 1px solid #3A3A3A;
                border-radius: 8px; 
                margin-bottom: 6px; 
                padding: 8px 10px; 
            }}
            QListWidget::item:hover {{ 
                background-color: #333333; 
                border: 1px solid #555;
            }}
            QListWidget::item:selected {{ 
                background-color: #2D2D2D; 
                border: 1px solid {COLORS['primary']}; 
                color: white; 
            }}
            QListWidget::indicator {{ 
                width: 16px; height: 16px; 
                border-radius: 4px; 
                border: 1px solid #666; 
                background: transparent;
            }}
            QListWidget::indicator:checked {{ 
                background-color: {COLORS['primary']}; 
                border-color: {COLORS['primary']}; 
                image: url(none); 
            }}
            
            /* --- 现代滚动条样式修复 --- */
            QScrollBar:vertical {{
                border: none;
                background: transparent;
                width: 6px;
                margin: 0px;
            }}
            QScrollBar::handle:vertical {{
                background: #444;
                border-radius: 3px;
                min-height: 20px;
            }}
            QScrollBar::handle:vertical:hover {{
                background: #555;
            }}
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {{
                height: 0px;
            }}
            QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {{
                background: none;
            }}
        """)
        
        self.list_widget.setDragDropMode(QAbstractItemView.InternalMove)
        self.list_widget.setDefaultDropAction(Qt.MoveAction)
        self.list_widget.setSelectionMode(QAbstractItemView.SingleSelection)
        self.list_widget.setVerticalScrollMode(QAbstractItemView.ScrollPerPixel) 
        
        layout.addWidget(self.list_widget)
        
        # 5. 底部按钮
        btn_del = QPushButton("删除选中项")
        btn_del.setCursor(Qt.PointingHandCursor)
        btn_del.setStyleSheet(f"""
            QPushButton {{
                background-color: rgba(231, 76, 60, 0.1); 
                color: {COLORS['danger']}; 
                border: 1px solid {COLORS['danger']}; 
                border-radius: 6px; 
                padding: 8px;
                font-size: 13px;
            }}
            QPushButton:hover {{ 
                background-color: {COLORS['danger']}; 
                color: white; 
            }}
        """)
        btn_del.clicked.connect(self._del_tag)
        layout.addWidget(btn_del)
        
        # 拖拽窗口支持
        self.drag_pos = None

    def _refresh_list(self):
        """将数据渲染到列表"""
        self.list_widget.clear()
        for tag_data in self.tags_data:
            item = QListWidgetItem(tag_data['name'])
            item.setFlags(item.flags() | Qt.ItemIsUserCheckable | Qt.ItemIsDragEnabled)
            state = Qt.Checked if tag_data.get('visible', True) else Qt.Unchecked
            item.setCheckState(state)
            self.list_widget.addItem(item)

    def _add_tag(self):
        text = self.inp_tag.text().strip()
        if not text: return
        
        for i in range(self.list_widget.count()):
            if self.list_widget.item(i).text() == text:
                QMessageBox.warning(self, "提示", "该标签已存在")
                return
        
        item = QListWidgetItem(text)
        item.setFlags(item.flags() | Qt.ItemIsUserCheckable | Qt.ItemIsDragEnabled)
        item.setCheckState(Qt.Checked)
        self.list_widget.addItem(item)
        self.inp_tag.clear()
        self.list_widget.scrollToBottom()

    def _del_tag(self):
        row = self.list_widget.currentRow()
        if row >= 0:
            self.list_widget.takeItem(row)

    def _save_and_close(self):
        new_tags_data = []
        for i in range(self.list_widget.count()):
            item = self.list_widget.item(i)
            new_tags_data.append({
                'name': item.text(),
                'visible': (item.checkState() == Qt.Checked)
            })
            
        save_setting('manual_common_tags', new_tags_data)
        save_setting('common_tags_limit', self.spin_limit.value())
        self.accept()

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.drag_pos = event.globalPos() - self.frameGeometry().topLeft()
            event.accept()

    def mouseMoveEvent(self, event):
        if event.buttons() == Qt.LeftButton and self.drag_pos:
            self.move(event.globalPos() - self.drag_pos)
            event.accept()
```

## 文件: ui\dialogs.py

```python
# -*- coding: utf-8 -*-
# ui/dialogs.py
import sys
import json
from PyQt5.QtWidgets import QCompleter
from PyQt5.QtWidgets import (QDialog, QVBoxLayout, QGridLayout, QHBoxLayout,
                              QLabel, QLineEdit, QTextEdit, QComboBox, QPushButton,
                              QProgressBar, QFrame, QApplication, QMessageBox, QShortcut,
                             QSpacerItem, QSizePolicy, QSplitter, QWidget, QScrollBar,
                             QGraphicsDropShadowEffect, QCheckBox)
from PyQt5.QtGui import QKeySequence, QColor, QCursor, QTextDocument, QTextCursor, QTextListFormat, QTextCharFormat
from PyQt5.QtCore import Qt, QPoint, QRect, QEvent, pyqtSignal
from core.config import STYLES, COLORS
from core.settings import save_setting, load_setting
from .components.rich_text_edit import RichTextEdit
from ui.components.syntax_highlighter import SimpleHighlighter

# 自定义深灰色滚动条样式
SCROLLBAR_STYLE = """
QScrollBar:vertical {
    border: none;
    background: #222222;
    width: 10px;
    margin: 0px 0px 0px 0px;
}
QScrollBar::handle:vertical {
    background: #555555;
    min-height: 20px;
    border-radius: 5px;
}
QScrollBar::handle:vertical:hover {
    background: #666666;
}
QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
    height: 0px;
}
QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {
    background: none;
}
QScrollBar:horizontal {
    border: none;
    background: #222222;
    height: 10px;
    margin: 0px 0px 0px 0px;
}
QScrollBar::handle:horizontal {
    background: #555555;
    min-width: 20px;
    border-radius: 5px;
}
QScrollBar::handle:horizontal:hover {
    background: #666666;
}
QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {
    width: 0px;
}
QScrollBar::add-page:horizontal, QScrollBar::sub-page:horizontal {
    background: none;
}
"""

class BaseDialog(QDialog):
    def __init__(self, parent=None, window_title="快速笔记"):
        super().__init__(parent)
        self.setWindowFlags(Qt.Window | Qt.FramelessWindowHint)
        self.setAttribute(Qt.WA_TranslucentBackground)
        self.setWindowTitle(window_title)
        
        self._setup_container()
    
    def _setup_container(self):
        """设置带阴影的主容器"""
        self.outer_layout = QVBoxLayout(self)
        self.outer_layout.setContentsMargins(15, 15, 15, 15)
        
        self.content_container = QWidget()
        self.content_container.setObjectName("DialogContainer")
        self.content_container.setStyleSheet(f"""
            #DialogContainer {{
                background-color: {COLORS['bg_dark']};
                border-radius: 12px;
            }}
        """ + STYLES['dialog'] + SCROLLBAR_STYLE)
        
        self.outer_layout.addWidget(self.content_container)
        
        shadow = QGraphicsDropShadowEffect(self)
        shadow.setBlurRadius(30)
        shadow.setXOffset(0)
        shadow.setYOffset(6)
        shadow.setColor(QColor(0, 0, 0, 120))
        self.content_container.setGraphicsEffect(shadow)
        
        return self.content_container

class EditDialog(BaseDialog):
    RESIZE_MARGIN = 10
    data_saved = pyqtSignal()

    def __init__(self, db, idea_id=None, parent=None, category_id_for_new=None):
        window_title = "编辑笔记" if idea_id else "新建笔记"
        super().__init__(parent, window_title=window_title)
        self.db = db
        self.idea_id = idea_id
        
        saved_default = load_setting('user_default_color')
        if saved_default:
            self.selected_color = saved_default
            self.is_using_saved_default = True
        else:
            self.selected_color = COLORS['orange']
            self.is_using_saved_default = False
        
        self.category_id = None 
        self.category_id_for_new = category_id_for_new 
        
        self._resize_area = None
        self._drag_pos = None
        self._resize_start_pos = None
        self._resize_start_geometry = None
        
        self.setMouseTracking(True)
        
        self._init_ui()
        if idea_id: 
            self._load_data()
        elif category_id_for_new:
             idx = self.category_combo.findData(category_id_for_new)
             if idx >= 0: self.category_combo.setCurrentIndex(idx)
            
        self.title_inp.installEventFilter(self)
        self.tags_inp.installEventFilter(self)

    def eventFilter(self, obj, event):
        if event.type() == QEvent.KeyPress:
            if event.key() == Qt.Key_Down:
                if obj == self.title_inp:
                    self.tags_inp.setFocus()
                    return True
                elif obj == self.tags_inp:
                    self.content_inp.setFocus()
                    return True
            elif event.key() == Qt.Key_Up:
                if obj == self.tags_inp:
                    self.title_inp.setFocus()
                    return True
        return super().eventFilter(obj, event)
        
    def _init_ui(self):
        self.resize(950, 650)
        
        main_layout = QVBoxLayout(self.content_container)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)
        
        # 1. 自定义标题栏
        self.title_bar = QWidget()
        self.title_bar.setFixedHeight(40)
        self.title_bar.setStyleSheet(f"""
            QWidget {{
                background-color: {COLORS['bg_mid']};
                border-top-left-radius: 12px;
                border-top-right-radius: 12px;
                border-bottom: 1px solid {COLORS['bg_light']};
            }}
        """)
        tb_layout = QHBoxLayout(self.title_bar)
        tb_layout.setContentsMargins(15, 0, 10, 0)
        
        self.win_title = QLabel('✨ 记录灵感' if not self.idea_id else '✏️ 编辑笔记')
        self.win_title.setStyleSheet("font-weight: bold; color: #ddd; font-size: 13px; border: none; background: transparent;")
        tb_layout.addWidget(self.win_title)
        
        tb_layout.addStretch()
        
        ctrl_btn_style = """
            QPushButton { background: transparent; border: none; color: #aaa; border-radius: 4px; font-size: 14px; width: 30px; height: 30px; }
            QPushButton:hover { background-color: rgba(255, 255, 255, 0.1); color: white; }
        """
        close_btn_style = """
            QPushButton { background: transparent; border: none; color: #aaa; border-radius: 4px; font-size: 16px; width: 30px; height: 30px; }
            QPushButton:hover { background-color: #e74c3c; color: white; }
        """
        
        btn_min = QPushButton("─")
        btn_min.setStyleSheet(ctrl_btn_style)
        btn_min.clicked.connect(self.showMinimized)
        
        self.btn_max = QPushButton("□")
        self.btn_max.setStyleSheet(ctrl_btn_style)
        self.btn_max.clicked.connect(self._toggle_maximize)
        
        btn_close = QPushButton("×")
        btn_close.setStyleSheet(close_btn_style)
        btn_close.clicked.connect(self.close) 
        
        tb_layout.addWidget(btn_min)
        tb_layout.addWidget(self.btn_max)
        tb_layout.addWidget(btn_close)
        
        main_layout.addWidget(self.title_bar)
        
        # 2. 内容区域
        content_widget = QWidget()
        content_layout = QHBoxLayout(content_widget)
        content_layout.setContentsMargins(10, 10, 10, 10)
        
        self.splitter = QSplitter(Qt.Horizontal)
        self.splitter.setStyleSheet(f"""
            QSplitter::handle {{
                background-color: {COLORS['bg_mid']};
                width: 2px;
                margin: 0 5px;
            }}
            QSplitter::handle:hover {{
                background-color: {COLORS['primary']};
            }}
        """)
        
        # 左侧容器
        left_container = QWidget()
        left_panel = QVBoxLayout(left_container)
        left_panel.setContentsMargins(5, 5, 5, 5)
        left_panel.setSpacing(12)
        
        # --- 分区选择 ---
        left_panel.addWidget(QLabel('📂 分区'))
        self.category_combo = QComboBox()
        self.category_combo.setFixedHeight(40)
        self.category_combo.setStyleSheet(STYLES['combo_box'] if 'combo_box' in STYLES else f"""
            QComboBox {{
                background-color: {COLORS['bg_mid']};
                border: 1px solid {COLORS['bg_light']};
                border-radius: 6px;
                padding: 5px;
                color: #ddd;
            }}
            QComboBox::drop-down {{ border: none; }}
            QComboBox QAbstractItemView {{
                background-color: {COLORS['bg_dark']};
                selection-background-color: {COLORS['primary']};
            }}
        """)
        
        # 加载分区数据
        self.category_combo.addItem("🚫 未分类", None)
        cats = self.db.get_categories()
        for c in cats:
            self.category_combo.addItem(f"📁 {c[1]}", c[0])
            
        left_panel.addWidget(self.category_combo)

        # --- 标题输入 ---
        left_panel.addWidget(QLabel('📌 标题'))
        self.title_inp = QLineEdit()
        self.title_inp.setPlaceholderText("请输入灵感标题...")
        self.title_inp.setFixedHeight(40)
        left_panel.addWidget(self.title_inp)
        
        # --- 标签输入 ---
        left_panel.addWidget(QLabel('🏷️ 标签 (智能补全)'))
        self.tags_inp = QLineEdit()
        self.tags_inp.setPlaceholderText("使用逗号分隔，如: 工作, 待办")
        self.tags_inp.setFixedHeight(40)
        
        self._init_completer()
        
        left_panel.addWidget(self.tags_inp)
        
        left_panel.addSpacing(10)
        left_panel.addWidget(QLabel('🎨 标记颜色'))
        color_layout = QGridLayout()
        color_layout.setSpacing(10)
        
        self.color_btns = []
        colors = [
            COLORS['orange'],
            COLORS['default_note'],
            COLORS['primary'],
            COLORS['success'],
            COLORS['danger'],
            COLORS['info']
        ]
                  
        for i, c in enumerate(colors):
            btn = QPushButton()
            btn.setFixedSize(34, 34)
            btn.setCursor(Qt.PointingHandCursor)
            btn.setStyleSheet(f"QPushButton {{ background-color: {c}; border-radius: 17px; border: 2px solid transparent; }}")
            btn.clicked.connect(lambda _, x=c: self._set_color(x))
            self.color_btns.append(btn)
            color_layout.addWidget(btn, i // 3, i % 3)
            
        left_panel.addLayout(color_layout)
        
        self.chk_set_default = QCheckBox("设为默认颜色")
        self.chk_set_default.setStyleSheet(f"""
            QCheckBox {{ color: {COLORS['text_sub']}; font-size: 12px; margin-top: 5px; }}
            QCheckBox::indicator {{ width: 14px; height: 14px; border: 1px solid #555; border-radius: 3px; background: transparent; }}
            QCheckBox::indicator:checked {{ background-color: {COLORS['primary']}; border-color: {COLORS['primary']}; }}
        """)
        if self.is_using_saved_default:
            self.chk_set_default.setChecked(True)
        
        left_panel.addWidget(self.chk_set_default)
        
        left_panel.addStretch()
        
        self.save_btn = QPushButton('💾 保存 (Ctrl+S)')
        self.save_btn.setCursor(Qt.PointingHandCursor)
        self.save_btn.setFixedHeight(50)
        self.save_btn.setStyleSheet(STYLES['btn_primary'])
        self.save_btn.clicked.connect(self._save_data)
        left_panel.addWidget(self.save_btn)
        
        # 右侧容器
        right_container = QWidget()
        right_panel = QVBoxLayout(right_container)
        right_panel.setContentsMargins(5, 5, 5, 5)
        right_panel.setSpacing(10)
        
        # 工具栏
        header_layout = QHBoxLayout()
        header_layout.addWidget(QLabel('📝 详细内容'))
        
        btn_style = """
            QPushButton { background: transparent; border: 1px solid #444; border-radius: 4px; color: #ccc; margin-left: 2px; }
            QPushButton:hover { background-color: #444; color: white; }
        """
        
        def _create_tool_btn(text, tooltip, callback):
            btn = QPushButton(text)
            btn.setFixedSize(24, 24)
            btn.setToolTip(tooltip)
            btn.setStyleSheet(btn_style)
            btn.setCursor(Qt.PointingHandCursor)
            btn.clicked.connect(callback)
            header_layout.addWidget(btn)
            return btn

        header_layout.addSpacing(10)
        _create_tool_btn("↩", "撤销 (Ctrl+Z)", lambda: self.content_inp.undo())
        _create_tool_btn("↪", "重做 (Ctrl+Y)", lambda: self.content_inp.redo())
        header_layout.addSpacing(5)
        _create_tool_btn("•", "无序列表", lambda: self.content_inp.toggle_list(QTextListFormat.ListDisc))
        _create_tool_btn("1.", "有序列表", lambda: self.content_inp.toggle_list(QTextListFormat.ListDecimal))
        _create_tool_btn("🧹", "清除格式", lambda: self.content_inp.setCurrentCharFormat(QTextCharFormat()))
        
        # JSON 格式化按钮
        header_layout.addSpacing(5)
        _create_tool_btn("{}", "格式化 JSON", self._format_json_content)

        header_layout.addStretch()
        
        highlight_colors = [
            ('#c0392b', '🔴'), # 红
            ('#d35400', '🟠'), # 橙
            ('#f1c40f', '🟡'), # 黄
            ('#27ae60', '🟢'), # 绿
            ('#2980b9', '🔵'), # 蓝
            ('#8e44ad', '🟣'), # 紫
            (None, '🚫')      # 清除
        ]
        
        for color, icon in highlight_colors:
            btn = QPushButton(icon)
            btn.setFixedSize(24, 24)
            btn.setCursor(Qt.PointingHandCursor)
            btn.setToolTip("清除高亮" if color is None else "高亮文字")
            btn.setStyleSheet(f"""
                QPushButton {{ 
                    background-color: transparent; 
                    border: 1px solid #444; 
                    border-radius: 4px; 
                    margin-left: 2px;
                }}
                QPushButton:hover {{ background-color: #444; }}
            """)
            btn.clicked.connect(lambda _, c=color: self.content_inp.highlight_selection(c))
            header_layout.addWidget(btn)
            
        right_panel.addLayout(header_layout)

        # 搜索栏 (默认隐藏)
        self.search_bar = QWidget()
        self.search_bar.setVisible(False)
        self.search_bar.setStyleSheet(f"background-color: {COLORS['bg_mid']}; border-radius: 6px; padding: 2px;")
        sb_layout = QHBoxLayout(self.search_bar)
        sb_layout.setContentsMargins(5, 2, 5, 2)
        sb_layout.setSpacing(5)
        
        self.search_inp = QLineEdit()
        self.search_inp.setPlaceholderText("查找内容...")
        self.search_inp.setStyleSheet("border: none; background: transparent; color: #fff;")
        self.search_inp.returnPressed.connect(self._find_next)
        
        btn_prev = QPushButton("⬆")
        btn_prev.setFixedSize(24, 24)
        btn_prev.clicked.connect(self._find_prev)
        btn_prev.setStyleSheet("background: transparent; border: none; color: #ccc;")
        
        btn_next = QPushButton("⬇")
        btn_next.setFixedSize(24, 24)
        btn_next.clicked.connect(self._find_next)
        btn_next.setStyleSheet("background: transparent; border: none; color: #ccc;")
        
        btn_cls = QPushButton("×")
        btn_cls.setFixedSize(24, 24)
        btn_cls.clicked.connect(lambda: self.search_bar.hide())
        btn_cls.setStyleSheet("background: transparent; border: none; color: #ccc;")
        
        sb_layout.addWidget(QLabel("🔍"))
        sb_layout.addWidget(self.search_inp)
        sb_layout.addWidget(btn_prev)
        sb_layout.addWidget(btn_next)
        sb_layout.addWidget(btn_cls)
        
        right_panel.addWidget(self.search_bar)

        self.content_inp = RichTextEdit()
        self.content_inp.setPlaceholderText("在这里记录详细内容（支持粘贴图片）...")
        self.content_inp.setStyleSheet("""
            QTextEdit {
                background-color: #2a2a2a;
                border: 1px solid #444;
                border-radius: 8px;
                padding: 10px;
                font-size: 14px;
                color: #eee;
                selection-background-color: #4a90e2; 
            }
        """)
        
        # 启用代码高亮
        self.highlighter = SimpleHighlighter(self.content_inp.document())
        
        shortcut_search = QShortcut(QKeySequence("Ctrl+F"), self.content_inp)
        shortcut_search.activated.connect(self._toggle_search_bar)
        
        right_panel.addWidget(self.content_inp)
        
        self.splitter.addWidget(left_container)
        self.splitter.addWidget(right_container)
        self.splitter.setSizes([300, 650])
        self.splitter.setStretchFactor(0, 0)
        self.splitter.setStretchFactor(1, 1)
        
        content_layout.addWidget(self.splitter)
        main_layout.addWidget(content_widget)
        
        QShortcut(QKeySequence("Ctrl+S"), self, self._save_data)
        QShortcut(QKeySequence("Escape"), self, self.close)
        QShortcut(QKeySequence("Ctrl+W"), self, self.close)
        
        self._set_color(self.selected_color)

    def _format_json_content(self):
        text = self.content_inp.toPlainText()
        if not text: return
        try:
            parsed = json.loads(text)
            formatted = json.dumps(parsed, indent=4, ensure_ascii=False)
            self.content_inp.setText(formatted)
            if hasattr(self, 'highlighter'):
                self.highlighter.rehighlight()
        except json.JSONDecodeError:
            QMessageBox.warning(self, "格式化失败", "内容不是有效的 JSON 格式。")

    def _get_resize_area(self, pos):
        x, y = pos.x(), pos.y()
        w, h = self.width(), self.height()
        m = self.RESIZE_MARGIN
        
        areas = []
        if x < m: areas.append('left')
        elif x > w - m: areas.append('right')
        if y < m: areas.append('top')
        elif y > h - m: areas.append('bottom')
        return areas

    def _set_cursor_for_resize(self, areas):
        if not areas:
            self.setCursor(Qt.ArrowCursor)
            return
        
        if 'left' in areas and 'top' in areas: self.setCursor(Qt.SizeFDiagCursor)
        elif 'right' in areas and 'bottom' in areas: self.setCursor(Qt.SizeFDiagCursor)
        elif 'left' in areas and 'bottom' in areas: self.setCursor(Qt.SizeBDiagCursor)
        elif 'right' in areas and 'top' in areas: self.setCursor(Qt.SizeBDiagCursor)
        elif 'left' in areas or 'right' in areas: self.setCursor(Qt.SizeHorCursor)
        elif 'top' in areas or 'bottom' in areas: self.setCursor(Qt.SizeVerCursor)

    def mousePressEvent(self, e):
        if e.button() == Qt.LeftButton:
            areas = self._get_resize_area(e.pos())
            if areas:
                self._resize_area = areas
                self._resize_start_pos = e.globalPos()
                self._resize_start_geometry = self.geometry()
                self._drag_pos = None
            elif e.pos().y() < 60: 
                self._drag_pos = e.globalPos() - self.frameGeometry().topLeft()
                self._resize_area = None
            e.accept()

    def mouseMoveEvent(self, e):
        if e.buttons() == Qt.NoButton:
            areas = self._get_resize_area(e.pos())
            self._set_cursor_for_resize(areas)
            return

        if e.buttons() == Qt.LeftButton:
            if self._resize_area:
                delta = e.globalPos() - self._resize_start_pos
                rect = self._resize_start_geometry
                min_w, min_h = 600, 400
                new_rect = rect.adjusted(0,0,0,0)
                
                if 'left' in self._resize_area:
                    if rect.right() - (rect.left() + delta.x()) >= min_w:
                        new_rect.setLeft(rect.left() + delta.x())
                if 'right' in self._resize_area:
                    if (rect.width() + delta.x()) >= min_w:
                        new_rect.setWidth(rect.width() + delta.x())
                if 'top' in self._resize_area:
                    if rect.bottom() - (rect.top() + delta.y()) >= min_h:
                        new_rect.setTop(rect.top() + delta.y())
                if 'bottom' in self._resize_area:
                    if (rect.height() + delta.y()) >= min_h:
                        new_rect.setHeight(rect.height() + delta.y())
                
                self.setGeometry(new_rect)
            elif self._drag_pos:
                self.move(e.globalPos() - self._drag_pos)
            e.accept()

    def mouseReleaseEvent(self, e):
        self._drag_pos = None
        self._resize_area = None
        self.setCursor(Qt.ArrowCursor)

    def mouseDoubleClickEvent(self, e):
        if e.pos().y() < 60:
            self._toggle_maximize()

    def _toggle_maximize(self):
        if self.isMaximized():
            self.showNormal()
            self.btn_max.setText('□')
            self.outer_layout.setContentsMargins(15, 15, 15, 15)
            
            self.content_container.setStyleSheet(f"""
                #DialogContainer {{
                    background-color: {COLORS['bg_dark']};
                    border-radius: 12px;
                }}
            """ + STYLES['dialog'] + SCROLLBAR_STYLE)
            
            self.title_bar.setStyleSheet(f"""
                QWidget {{
                    background-color: {COLORS['bg_mid']};
                    border-top-left-radius: 12px;
                    border-top-right-radius: 12px;
                    border-bottom: 1px solid {COLORS['bg_light']};
                }}
            """)
        else:
            self.showMaximized()
            self.btn_max.setText('❐')
            self.outer_layout.setContentsMargins(0, 0, 0, 0)
            
            self.content_container.setStyleSheet(f"""
                #DialogContainer {{
                    background-color: {COLORS['bg_dark']};
                    border-radius: 0px;
                }}
            """ + STYLES['dialog'] + SCROLLBAR_STYLE)
            
            self.title_bar.setStyleSheet(f"""
                QWidget {{
                    background-color: {COLORS['bg_mid']};
                    border-radius: 0px;
                    border-bottom: 1px solid {COLORS['bg_light']};
                }}
            """)

    def _set_color(self, color):
        self.selected_color = color
        
        saved_default = load_setting('user_default_color')
        if saved_default == color:
            self.chk_set_default.setChecked(True)
        else:
            self.chk_set_default.setChecked(False)
        
        for btn in self.color_btns:
            style = btn.styleSheet()
            if color in style:
                new_style = f"background-color: {color}; border-radius: 17px; border: 3px solid white;"
            else:
                bg = style.split('background-color:')[1].split(';')[0].strip()
                new_style = f"background-color: {bg}; border-radius: 17px; border: 2px solid transparent;"
            btn.setStyleSheet(f"QPushButton {{ {new_style} }}")

    def _init_completer(self):
        all_tags = self.db.get_all_tags()
        self.completer = QCompleter(all_tags, self)
        self.completer.setCaseSensitivity(Qt.CaseInsensitive)
        self.completer.setFilterMode(Qt.MatchContains)
        
        self.completer.setWidget(self.tags_inp)
        self.completer.activated.connect(self._on_completion_activated)
        self.tags_inp.textEdited.connect(self._update_completion_prefix)

    def _update_completion_prefix(self, text):
        cursor_pos = self.tags_inp.cursorPosition()
        text_before = text[:cursor_pos]
        
        last_comma = text_before.rfind(',')
        if last_comma != -1:
            prefix = text_before[last_comma+1:].strip()
        else:
            prefix = text_before.strip()
            
        if prefix:
            self.completer.setCompletionPrefix(prefix)
            if self.completer.completionCount() > 0:
                cr = self.tags_inp.cursorRect()
                cr.setWidth(self.completer.popup().sizeHintForColumn(0) + self.completer.popup().verticalScrollBar().sizeHint().width())
                self.completer.complete(cr)
            else:
                self.completer.popup().hide()
        else:
            self.completer.popup().hide()

    def _on_completion_activated(self, text):
        current_text = self.tags_inp.text()
        cursor_pos = self.tags_inp.cursorPosition()
        
        text_before = current_text[:cursor_pos]
        last_comma = text_before.rfind(',')
        
        start_replace = last_comma + 1 if last_comma != -1 else 0
        
        prefix = current_text[:start_replace]
        suffix = current_text[cursor_pos:]
        
        new_text = prefix + text + ", " + suffix
        self.tags_inp.setText(new_text)
        self.tags_inp.setCursorPosition(len(prefix) + len(text) + 2)

    def _toggle_search_bar(self):
        self.search_bar.setVisible(not self.search_bar.isVisible())
        if self.search_bar.isVisible():
            self.search_inp.setFocus()
            sel = self.content_inp.textCursor().selectedText()
            if sel: self.search_inp.setText(sel)
        else:
            self.content_inp.setFocus()

    def _find_next(self):
        text = self.search_inp.text()
        if not text: return
        
        found = self.content_inp.find(text)
        if not found:
            curr = self.content_inp.textCursor()
            self.content_inp.moveCursor(QTextCursor.Start)
            if not self.content_inp.find(text):
                self.content_inp.setTextCursor(curr)

    def _find_prev(self):
        text = self.search_inp.text()
        if not text: return
        
        found = self.content_inp.find(text, QTextDocument.FindBackward)
        if not found:
            curr = self.content_inp.textCursor()
            self.content_inp.moveCursor(QTextCursor.End)
            if not self.content_inp.find(text, QTextDocument.FindBackward):
                self.content_inp.setTextCursor(curr)

    def _load_data(self):
        d = self.db.get_idea(self.idea_id, include_blob=True)
        if d:
            self.title_inp.setText(d[1])
            # 索引: 0:id, 1:title, 2:content, 3:color, 4:pinned, 5:fav, 6:created, 7:updated, 8:cat_id, 9:is_deleted, 10:item_type, 11:data_blob
            item_type = d[10] if len(d) > 10 else 'text'
            
            if item_type != 'image':
                self.content_inp.setText(d[2])
            else:
                self.content_inp.clear() 
            
            self._set_color(d[3])
            self.category_id = d[8]
            if self.category_id is not None:
                idx = self.category_combo.findData(self.category_id)
                if idx >= 0:
                    self.category_combo.setCurrentIndex(idx)
            
            data_blob = d[11] if len(d) > 11 else None
            if item_type == 'image' and data_blob:
                self.content_inp.set_image_data(data_blob)

            self.tags_inp.setText(','.join(self.db.get_tags(self.idea_id)))

    def _save_data(self):
        title = self.title_inp.text().strip()
        if not title:
            self.title_inp.setPlaceholderText("⚠️ 标题不能为空!")
            self.title_inp.setFocus()
            return

        tags = [t.strip() for t in self.tags_inp.text().split(',') if t.strip()]
        content = self.content_inp.toPlainText()
        color = self.selected_color
        
        if self.chk_set_default.isChecked():
            save_setting('user_default_color', color)
        
        item_type = 'text'
        data_blob = self.content_inp.get_image_data()
        if data_blob:
            item_type = 'image'

        cat_id = self.category_combo.currentData()

        if self.idea_id:
            self.db.update_idea(self.idea_id, title, content, color, tags, cat_id, item_type, data_blob)
        else:
            self.db.add_idea(title, content, color, tags, cat_id, item_type, data_blob)
        
        self.data_saved.emit()
        self.accept()

# === 看板窗口 ===
class StatsDialog(BaseDialog):
    def __init__(self, db, parent=None):
        super().__init__(parent)
        self.setWindowTitle('📊 数据看板')
        self.resize(550, 450)
        
        layout = QVBoxLayout(self.content_container)
        layout.setContentsMargins(30, 30, 30, 30)
        layout.setSpacing(20)
        
        counts = db.get_counts()
        grid = QGridLayout()
        grid.setSpacing(15)
        grid.addWidget(self._box("📚 总灵感", counts['all'], COLORS['primary']), 0, 0)
        grid.addWidget(self._box("📅 今日新增", counts['today'], COLORS['success']), 0, 1)
        grid.addWidget(self._box("⭐ 我的收藏", counts['favorite'], COLORS['warning']), 1, 0)
        grid.addWidget(self._box("🏷️ 待整理", counts['untagged'], COLORS['danger']), 1, 1)
        layout.addLayout(grid)
        
        layout.addSpacing(10)
        layout.addWidget(QLabel("🔥 热门标签 Top 5"))
        
        stats = db.get_top_tags()
        if not stats:
            layout.addWidget(QLabel("暂无标签数据", styleSheet="color:#666; font-style:italic; font-weight:normal;"))
        else:
            max_val = stats[0][1]
            for name, cnt in stats:
                h = QHBoxLayout()
                lbl = QLabel(f"#{name}")
                lbl.setFixedWidth(80)
                lbl.setStyleSheet("color:#eee; font-weight:bold; margin:0;")
                h.addWidget(lbl)
                
                p = QProgressBar()
                p.setMaximum(max_val)
                p.setValue(cnt)
                p.setFixedHeight(18)
                p.setFormat(f" {cnt}")
                p.setStyleSheet(f"""
                    QProgressBar {{
                        background-color: {COLORS['bg_mid']};
                        border: none;
                        border-radius: 9px;
                        color: white;
                        text-align: center;
                    }}
                    QProgressBar::chunk {{
                        background-color: {COLORS['primary']};
                        border-radius: 9px;
                    }}
                """)
                h.addWidget(p)
                layout.addLayout(h)
                
        layout.addStretch()
        close_btn = QPushButton("关闭")
        close_btn.setFixedHeight(40)
        close_btn.setStyleSheet(f"background-color:{COLORS['bg_mid']}; border:1px solid #444; color:#ccc; border-radius:5px;")
        close_btn.clicked.connect(self.accept)
        layout.addWidget(close_btn)

    def _box(self, t, v, c):
        f = QFrame()
        f.setStyleSheet(f"QFrame {{ background-color: {c}15; border: 1px solid {c}40; border-radius: 10px; }}")
        vl = QVBoxLayout(f)
        vl.setContentsMargins(15, 15, 15, 15)
        lbl_title = QLabel(t)
        lbl_title.setStyleSheet(f"color:{c}; font-size:13px; font-weight:bold; border:none; margin:0;")
        lbl_val = QLabel(str(v))
        lbl_val.setStyleSheet(f"color:{c}; font-size:28px; font-weight:bold; border:none; margin-top:5px;")
        vl.addWidget(lbl_title)
        vl.addWidget(lbl_val)
        return f

# === 提取窗口 ===
class ExtractDialog(BaseDialog):
    def __init__(self, db, parent=None):
        super().__init__(parent)
        self.setWindowTitle('📋 提取内容')
        self.resize(700, 600)
        
        layout = QVBoxLayout(self.content_container)
        layout.setContentsMargins(20, 20, 20, 20)
        
        self.txt = QTextEdit()
        self.txt.setReadOnly(True)
        self.txt.setPlaceholderText("暂无数据...")
        layout.addWidget(self.txt)
        
        data = db.get_ideas('', 'all', None)
        text = '\n' + '-'*60 + '\n'
        text += '\n'.join([f"【{d[1]}】\n{d[2]}\n" + '-'*60 for d in data])
        self.txt.setText(text)
        
        layout.addSpacing(10)
        btn = QPushButton('📋 复制全部到剪贴板')
        btn.setFixedHeight(45)
        btn.setStyleSheet(STYLES['btn_primary'])
        btn.clicked.connect(lambda: (QApplication.clipboard().setText(text), QMessageBox.information(self,'成功','✅ 内容已复制')))
        layout.addWidget(btn)

# === 预览窗口 ===
from PyQt5.QtGui import QPixmap, QImage
from PyQt5.QtWidgets import QDesktopWidget

class PreviewDialog(QDialog):
    def __init__(self, item_type, data, parent=None):
        super().__init__(parent)
        self.setWindowFlags(Qt.Dialog | Qt.FramelessWindowHint | Qt.Popup)
        self.setAttribute(Qt.WA_TranslucentBackground)
        
        self._init_ui(item_type, data)

        QShortcut(QKeySequence(Qt.Key_Escape), self, self.close)
        QShortcut(QKeySequence(Qt.Key_Space), self, self.close)

    def _init_ui(self, item_type, data):
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        
        container = QWidget()
        container.setStyleSheet(f"""
            QWidget {{
                background-color: {COLORS['bg_dark']};
                border: 2px solid {COLORS['bg_mid']};
                border-radius: 12px;
            }}
        """)
        container_layout = QVBoxLayout(container)
        main_layout.addWidget(container)

        if item_type == 'text':
            self._setup_text_preview(container_layout, data)
        elif item_type == 'image':
            self._setup_image_preview(container_layout, data)

    def _setup_text_preview(self, layout, text_data):
        self.resize(600, 500)
        
        text_edit = QTextEdit()
        text_edit.setReadOnly(True)
        text_edit.setText(text_data)
        text_edit.setStyleSheet(f"""
            QTextEdit {{
                background-color: transparent;
                border: none;
                padding: 15px;
                color: #ddd;
                font-size: 14px;
            }}
            {SCROLLBAR_STYLE}
        """)
        layout.addWidget(text_edit)

    def _setup_image_preview(self, layout, image_data):
        pixmap = QPixmap()
        pixmap.loadFromData(image_data)

        if pixmap.isNull():
            label = QLabel("无法加载图片")
            label.setAlignment(Qt.AlignCenter)
            label.setStyleSheet("color: #E81123; font-size: 16px;")
            layout.addWidget(label)
            self.resize(300, 200)
            return
            
        label = QLabel()
        label.setAlignment(Qt.AlignCenter)
        layout.addWidget(label)

        screen_geo = QDesktopWidget().availableGeometry(self)
        max_width = screen_geo.width() * 0.8
        max_height = screen_geo.height() * 0.8

        scaled_pixmap = pixmap.scaled(int(max_width), int(max_height), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        label.setPixmap(scaled_pixmap)
        
        self.resize(scaled_pixmap.width() + 20, scaled_pixmap.height() + 20)

    def mousePressEvent(self, event):
        self.close()
```

## 文件: ui\main_window.py

```python
# -*- coding: utf-8 -*-
# ui/main_window.py
import sys
import math
import json
from PyQt5.QtWidgets import (QWidget, QHBoxLayout, QVBoxLayout, QSplitter, QLineEdit,
                               QPushButton, QLabel, QScrollArea, QShortcut, QMessageBox,
                               QApplication, QToolTip, QMenu, QFrame, QTextEdit, QDialog,
                               QGraphicsDropShadowEffect, QLayout, QSizePolicy, QInputDialog)
from PyQt5.QtCore import Qt, QTimer, QPoint, pyqtSignal, QRect, QSize, QByteArray
from PyQt5.QtGui import QKeySequence, QCursor, QColor, QIntValidator
from core.config import STYLES, COLORS
from core.settings import load_setting, save_setting
from data.db_manager import DatabaseManager
from services.backup_service import BackupService
from ui.sidebar import Sidebar
from ui.cards import IdeaCard
from ui.dialogs import EditDialog
# [修复] 删除了此处错误的 from ui.ball import FloatingBall
from ui.advanced_tag_selector import AdvancedTagSelector
from ui.components.search_line_edit import SearchLineEdit
from services.preview_service import PreviewService
from core.logger import get_logger

logger = get_logger('MainWindow')

# --- 辅助类：流式布局 ---
class FlowLayout(QLayout):
    def __init__(self, parent=None, margin=0, spacing=-1):
        super(FlowLayout, self).__init__(parent)
        if parent is not None:
            self.setContentsMargins(margin, margin, margin, margin)
        self.setSpacing(spacing)
        self.itemList = []

    def addItem(self, item):
        self.itemList.append(item)

    def count(self):
        return len(self.itemList)

    def itemAt(self, index):
        if 0 <= index < len(self.itemList):
            return self.itemList[index]
        return None

    def takeAt(self, index):
        if 0 <= index < len(self.itemList):
            return self.itemList.pop(index)
        return None

    def expandingDirections(self):
        return Qt.Orientations(Qt.Orientation(0))

    def hasHeightForWidth(self):
        return True

    def heightForWidth(self, width):
        height = self.doLayout(QRect(0, 0, width, 0), True)
        return height

    def setGeometry(self, rect):
        super(FlowLayout, self).setGeometry(rect)
        self.doLayout(rect, False)

    def sizeHint(self):
        return self.minimumSize()

    def minimumSize(self):
        size = QSize()
        for item in self.itemList:
            size = size.expandedTo(item.minimumSize())
        margin = self.contentsMargins()
        size += QSize(margin.left() + margin.right(), margin.top() + margin.bottom())
        return size

    def doLayout(self, rect, testOnly):
        x = rect.x()
        y = rect.y()
        lineHeight = 0
        spacing = self.spacing()

        for item in self.itemList:
            wid = item.widget()
            spaceX = spacing + wid.style().layoutSpacing(QSizePolicy.PushButton, QSizePolicy.PushButton, Qt.Horizontal)
            spaceY = spacing + wid.style().layoutSpacing(QSizePolicy.PushButton, QSizePolicy.PushButton, Qt.Vertical)
            
            nextX = x + item.sizeHint().width() + spaceX
            if nextX - spaceX > rect.right() and lineHeight > 0:
                x = rect.x()
                y = y + lineHeight + spaceY
                nextX = x + item.sizeHint().width() + spaceX
                lineHeight = 0

            if not testOnly:
                item.setGeometry(QRect(QPoint(x, y), item.sizeHint()))

            x = nextX
            lineHeight = max(lineHeight, item.sizeHint().height())

        return y + lineHeight - rect.y()

class ContentContainer(QWidget):
    cleared = pyqtSignal()

    def mousePressEvent(self, e):
        if self.childAt(e.pos()) is None:
            self.cleared.emit()
            e.accept() 
        else:
            super().mousePressEvent(e)

class ClickableLineEdit(QLineEdit):
    doubleClicked = pyqtSignal()
    def mouseDoubleClickEvent(self, event):
        self.doubleClicked.emit()
        super().mouseDoubleClickEvent(event)

class MainWindow(QWidget):
    closing = pyqtSignal()
    RESIZE_MARGIN = 8

    def __init__(self):
        super().__init__()
        QApplication.setQuitOnLastWindowClosed(False)
        self.db = DatabaseManager()
        self.preview_service = PreviewService(self.db, self)
        
        self.curr_filter = ('all', None)
        self.selected_ids = set()
        self._drag_pos = None
        self.current_tag_filter = None
        self.last_clicked_id = None 
        self.card_ordered_ids = []  
        self._resize_area = None
        self._resize_start_pos = None
        self._resize_start_geometry = None
        
        self.current_page = 1
        self.page_size = 20
        self.total_pages = 1
        
        self.open_dialogs = [] 
        
        self.setWindowFlags(
            Qt.FramelessWindowHint | 
            Qt.Window | 
            Qt.WindowSystemMenuHint | 
            Qt.WindowMinimizeButtonHint | 
            Qt.WindowMaximizeButtonHint
        )
        self.setAttribute(Qt.WA_TranslucentBackground)
        self.setMouseTracking(True)
        
        self._setup_ui()
        self._load_data()
        
    def _setup_ui(self):
        self.setWindowTitle('数据管理')
        self._restore_window_state()
        
        root_layout = QVBoxLayout(self)
        root_layout.setContentsMargins(12, 12, 12, 12)
        
        self.container = QWidget()
        self.container.setObjectName("MainContainer")
        self.container.setStyleSheet(STYLES['main_window'])
        root_layout.addWidget(self.container)
        
        shadow = QGraphicsDropShadowEffect(self)
        shadow.setBlurRadius(25)
        shadow.setXOffset(0)
        shadow.setYOffset(4)
        shadow.setColor(QColor(0, 0, 0, 100))
        self.container.setGraphicsEffect(shadow)
        
        outer_layout = QVBoxLayout(self.container)
        outer_layout.setContentsMargins(0, 0, 0, 0)
        outer_layout.setSpacing(0)
        
        titlebar = self._create_titlebar()
        outer_layout.addWidget(titlebar)
        
        main_content = QWidget()
        main_layout = QHBoxLayout(main_content)
        main_layout.setContentsMargins(0, 0, 0, 0)
        splitter = QSplitter(Qt.Horizontal)
        
        self.sidebar = Sidebar(self.db)
        self.sidebar.filter_changed.connect(self._set_filter)
        self.sidebar.data_changed.connect(self._load_data)
        self.sidebar.new_data_requested.connect(self._on_new_data_in_category_requested)
        splitter.addWidget(self.sidebar)
        
        middle_panel = self._create_middle_panel()
        splitter.addWidget(middle_panel)
        
        self.tag_panel = self._create_tag_panel()
        splitter.addWidget(self.tag_panel)
        
        splitter.setStretchFactor(0, 1)
        splitter.setStretchFactor(1, 4)
        splitter.setStretchFactor(2, 1)
        
        main_layout.addWidget(splitter)
        outer_layout.addWidget(main_content)
        
        QShortcut(QKeySequence("Ctrl+T"), self, self._handle_extract_key)
        QShortcut(QKeySequence("Ctrl+N"), self, self.new_idea)
        QShortcut(QKeySequence("Ctrl+W"), self, self.close)
        QShortcut(QKeySequence("Ctrl+A"), self, self._select_all)
        QShortcut(QKeySequence("Ctrl+F"), self, self.search.setFocus)
        QShortcut(QKeySequence("Ctrl+E"), self, self._do_fav)
        QShortcut(QKeySequence("Ctrl+B"), self, self._do_edit)
        QShortcut(QKeySequence("Ctrl+P"), self, self._do_pin)
        QShortcut(QKeySequence("Delete"), self, self._handle_del_key)
        QShortcut(QKeySequence("Escape"), self, self._clear_tag_filter)
        QShortcut(QKeySequence("Ctrl+S"), self, self._do_lock)
        
        self.space_shortcut = QShortcut(QKeySequence(Qt.Key_Space), self)
        self.space_shortcut.setContext(Qt.WindowShortcut)
        self.space_shortcut.activated.connect(lambda: self.preview_service.toggle_preview(self.selected_ids))

    def _select_all(self):
        if not self.cards: return
        if len(self.selected_ids) == len(self.cards):
            self.selected_ids.clear()
        else:
            self.selected_ids = set(self.cards.keys())
        self._update_all_card_selections()
        self._update_ui_state()

    def _clear_all_selections(self):
        if not self.selected_ids: return
        self.selected_ids.clear()
        self.last_clicked_id = None
        self._update_all_card_selections()
        self._update_ui_state()

    def _create_titlebar(self):
        titlebar = QWidget()
        titlebar.setFixedHeight(40)
        titlebar.setStyleSheet(f"QWidget {{ background-color: {COLORS['bg_mid']}; border-bottom: 1px solid {COLORS['bg_light']}; border-top-left-radius: 8px; border-top-right-radius: 8px; }}")
        
        layout = QHBoxLayout(titlebar)
        layout.setContentsMargins(15, 0, 10, 0)
        layout.setSpacing(6)
        
        title = QLabel('💡 快速笔记')
        title.setStyleSheet("font-size: 13px; font-weight: bold; color: #4a90e2;")
        layout.addWidget(title)
        
        self.search = SearchLineEdit()
        self.search.setClearButtonEnabled(True)
        self.search.setPlaceholderText('🔍 搜索灵感 (双击查看历史)')
        self.search.setFixedWidth(280)
        self.search.setFixedHeight(28)
        self.search.setStyleSheet(STYLES['input'] + """
            QLineEdit { border-radius: 14px; padding-right: 25px; }
            QLineEdit::clear-button { image: url(assets/clear.png); subcontrol-position: right; margin-right: 5px; }
        """)
        self.search.textChanged.connect(lambda: self._set_page(1))
        self.search.returnPressed.connect(self._add_search_to_history)
        layout.addWidget(self.search)
        
        layout.addSpacing(10)
        
        page_btn_style = """
            QPushButton { background-color: transparent; border: 1px solid #444; color: #aaa; border-radius: 4px; font-size: 11px; padding: 2px 8px; min-width: 20px; }
            QPushButton:hover { background-color: #333; color: white; border-color: #666; }
            QPushButton:disabled { color: #444; border-color: #333; }
        """
        
        self.btn_first = QPushButton("<<")
        self.btn_first.setStyleSheet(page_btn_style)
        self.btn_first.setToolTip("首页")
        self.btn_first.clicked.connect(lambda: self._set_page(1))
        
        self.btn_prev = QPushButton("<")
        self.btn_prev.setStyleSheet(page_btn_style)
        self.btn_prev.setToolTip("上一页")
        self.btn_prev.clicked.connect(lambda: self._set_page(self.current_page - 1))
        
        self.page_input = QLineEdit()
        self.page_input.setFixedWidth(40)
        self.page_input.setAlignment(Qt.AlignCenter)
        self.page_input.setValidator(QIntValidator(1, 9999))
        self.page_input.setStyleSheet("background-color: #2D2D2D; border: 1px solid #444; color: #DDD; border-radius: 4px; padding: 2px;")
        self.page_input.returnPressed.connect(self._jump_to_page)
        
        self.total_page_label = QLabel("/ 1")
        self.total_page_label.setStyleSheet("color: #888; font-size: 12px; margin-left: 2px; margin-right: 5px;")
        
        self.btn_next = QPushButton(">")
        self.btn_next.setStyleSheet(page_btn_style)
        self.btn_next.setToolTip("下一页")
        self.btn_next.clicked.connect(lambda: self._set_page(self.current_page + 1))
        
        self.btn_last = QPushButton(">>")
        self.btn_last.setStyleSheet(page_btn_style)
        self.btn_last.setToolTip("末页")
        self.btn_last.clicked.connect(lambda: self._set_page(self.total_pages))
        
        layout.addWidget(self.btn_first)
        layout.addWidget(self.btn_prev)
        layout.addWidget(self.page_input)
        layout.addWidget(self.total_page_label)
        layout.addWidget(self.btn_next)
        layout.addWidget(self.btn_last)
        
        layout.addStretch()
        
        ctrl_btn_style = f"QPushButton {{ background-color: transparent; border: none; color: #aaa; border-radius: 6px; font-size: 16px; min-width: 30px; max-width: 30px; min-height: 30px; max-height: 30px; }} QPushButton:hover {{ background-color: rgba(255,255,255,0.1); color: white; }}"
        
        extract_btn = QPushButton('📤')
        extract_btn.setToolTip('批量提取全部')
        extract_btn.setStyleSheet(f"QPushButton {{ background-color: {COLORS['primary']}; border: none; color: white; border-radius: 6px; font-size: 18px; min-width: 30px; max-width: 30px; min-height: 30px; max-height: 30px; }} QPushButton:hover {{ background-color: #357abd; }}")
        extract_btn.clicked.connect(self._extract_all)
        layout.addWidget(extract_btn)
        
        new_btn = QPushButton('➕')
        new_btn.setToolTip('新建灵感 (Ctrl+N)')
        new_btn.setStyleSheet(f"QPushButton {{ background-color: {COLORS['primary']}; border: none; color: white; border-radius: 6px; font-size: 18px; min-width: 30px; max-width: 30px; min-height: 30px; max-height: 30px; }} QPushButton:hover {{ background-color: #357abd; }}")
        new_btn.clicked.connect(self.new_idea)
        layout.addWidget(new_btn)
        layout.addSpacing(4)
        
        min_btn = QPushButton('─')
        min_btn.setStyleSheet(ctrl_btn_style)
        min_btn.clicked.connect(self.showMinimized)
        layout.addWidget(min_btn)
        
        self.max_btn = QPushButton('□')
        self.max_btn.setStyleSheet(ctrl_btn_style)
        self.max_btn.clicked.connect(self._toggle_maximize)
        layout.addWidget(self.max_btn)
        
        close_btn = QPushButton('✕')
        close_btn.setStyleSheet(ctrl_btn_style + "QPushButton:hover { background-color: #e74c3c; color: white; }")
        close_btn.clicked.connect(self.close)
        layout.addWidget(close_btn)
        
        return titlebar

    def _set_page(self, page_num):
        if page_num < 1: page_num = 1
        self.current_page = page_num
        self._load_data()

    def _jump_to_page(self):
        text = self.page_input.text().strip()
        if text.isdigit():
            page = int(text)
            self._set_page(page)
        else:
            self.page_input.setText(str(self.current_page))

    def _update_pagination_ui(self):
        self.page_input.setText(str(self.current_page))
        self.total_page_label.setText(f"/ {self.total_pages}")
        
        is_first = (self.current_page <= 1)
        is_last = (self.current_page >= self.total_pages)
        
        self.btn_first.setDisabled(is_first)
        self.btn_prev.setDisabled(is_first)
        self.btn_next.setDisabled(is_last)
        self.btn_last.setDisabled(is_last)

    def _create_middle_panel(self):
        panel = QWidget()
        layout = QVBoxLayout(panel)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        act_bar = QHBoxLayout()
        act_bar.setSpacing(4)
        act_bar.setContentsMargins(20, 10, 20, 10)
        
        self.header_label = QLabel('全部数据')
        self.header_label.setStyleSheet("font-size:18px;font-weight:bold;")
        act_bar.addWidget(self.header_label)
        
        self.tag_filter_label = QLabel()
        self.tag_filter_label.setStyleSheet(f"background-color: {COLORS['primary']}; color: white; border-radius: 10px; padding: 4px 10px; font-size: 11px; font-weight: bold;")
        self.tag_filter_label.hide()
        act_bar.addWidget(self.tag_filter_label)
        act_bar.addStretch()
        
        self.btns = {}
        for k, i, f in [('pin','📌',self._do_pin), ('fav','⭐',self._do_fav), ('edit','✏️',self._do_edit),
                        ('del','🗑️',self._do_del), ('rest','♻️',self._do_restore), ('dest','🗑️',self._do_destroy)]:
            b = QPushButton(i)
            b.setStyleSheet(STYLES['btn_icon'])
            b.clicked.connect(f)
            b.setEnabled(False)
            act_bar.addWidget(b)
            self.btns[k] = b
        layout.addLayout(act_bar)
        
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setStyleSheet("border:none")
        self.list_container = ContentContainer()
        self.list_container.cleared.connect(self._clear_all_selections)
        self.list_layout = QVBoxLayout(self.list_container)
        self.list_layout.setAlignment(Qt.AlignTop)
        self.list_layout.setSpacing(10)
        self.list_layout.setContentsMargins(20, 5, 20, 15)
        scroll.setWidget(self.list_container)
        layout.addWidget(scroll)
        
        return panel

    def _create_tag_panel(self):
        panel = QWidget()
        panel.setObjectName("RightPanel")
        panel.setStyleSheet(f"#RightPanel {{ background-color: {COLORS['bg_mid']}; }}")
        panel.setFixedWidth(220)
        
        layout = QVBoxLayout(panel)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)
        
        header = QHBoxLayout()
        self.tag_panel_title = QLabel('🏷️ 最近标签')
        self.tag_panel_title.setStyleSheet("font-size: 14px; font-weight: bold; color: #4a90e2;")
        header.addWidget(self.tag_panel_title)
        
        self.clear_tag_btn = QPushButton('✕')
        self.clear_tag_btn.setFixedSize(20, 20)
        self.clear_tag_btn.setStyleSheet(f"QPushButton {{ background-color: transparent; border: 1px solid #666; border-radius: 10px; color: #999; font-size: 12px; }} QPushButton:hover {{ background-color: {COLORS['danger']}; border-color: {COLORS['danger']}; color: white; }}")
        self.clear_tag_btn.setToolTip('清除标签筛选 (ESC)')
        self.clear_tag_btn.clicked.connect(self._clear_tag_filter)
        self.clear_tag_btn.hide()
        header.addWidget(self.clear_tag_btn)
        layout.addLayout(header)
        
        self.tag_input = ClickableLineEdit()
        self.tag_input.setPlaceholderText("🔍 搜索...")
        self.tag_input.setStyleSheet(f"""
            QLineEdit {{
                background-color: #2D2D2D; 
                border: 1px solid #444;
                border-radius: 16px; 
                padding: 6px 12px; 
                font-size: 12px; 
                color: #EEE;
            }}
            QLineEdit:focus {{ 
                border-color: {COLORS['primary']}; 
                background-color: #38383C;
            }}
        """)
        self.tag_input.returnPressed.connect(self._handle_tag_input_return)
        self.tag_input.doubleClicked.connect(self._open_tag_selector_for_selection)
        layout.addWidget(self.tag_input)
        
        line = QFrame()
        line.setFrameShape(QFrame.HLine)
        line.setFrameShadow(QFrame.Plain)
        line.setStyleSheet(f"background-color: #505050; border: none; max-height: 1px; margin-top: 5px; margin-bottom: 5px;")
        layout.addWidget(line)
        
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setStyleSheet("""
            QScrollArea { border: none; background: transparent; }
            QWidget { background: transparent; }
            QScrollBar:vertical {
                border: none; background: #222; width: 6px; margin: 0;
            }
            QScrollBar::handle:vertical { background: #555; border-radius: 3px; }
        """)
        
        self.tag_list_widget = QWidget()
        self.tag_list_layout = FlowLayout(self.tag_list_widget, margin=0, spacing=8)
        
        scroll.setWidget(self.tag_list_widget)
        layout.addWidget(scroll)
        
        QTimer.singleShot(0, self._refresh_tag_panel)
        return panel

    def _handle_tag_input_return(self):
        text = self.tag_input.text().strip()
        if not text: return
        
        if self.selected_ids:
            self._add_tag_to_selection([text])
            self.tag_input.clear()
        else:
            self._refresh_tag_panel()

    def _open_tag_selector_for_selection(self):
        if self.selected_ids:
            selector = AdvancedTagSelector(self.db, idea_id=None, initial_tags=[])
            selector.tags_confirmed.connect(self._add_tag_to_selection)
            selector.show_at_cursor()

    def _add_tag_to_selection(self, tags):
        if not self.selected_ids or not tags: return
        self.db.add_tags_to_multiple_ideas(list(self.selected_ids), tags)
        self._show_tooltip(f"✅ 已添加 {len(tags)} 个标签到 {len(self.selected_ids)} 项")
        self._refresh_all()

    def _remove_tag_from_selection(self, tag_name):
        if not self.selected_ids: return
        self.db.remove_tag_from_multiple_ideas(list(self.selected_ids), tag_name)
        self._refresh_all()

    def _show_tag_context_menu(self, pos, tag_name):
        menu = QMenu(self)
        menu.setStyleSheet(f"""
            QMenu {{ background-color: #2D2D2D; color: #EEE; border: 1px solid #444; }}
            QMenu::item {{ padding: 6px 20px; }}
            QMenu::item:selected {{ background-color: {COLORS['primary']}; }}
        """)
        
        menu.addAction("✏️ 重命名", lambda: self._rename_tag_action(tag_name))
        menu.addSeparator()
        menu.addAction("🗑️ 删除该标签 (全局)", lambda: self._delete_tag_action(tag_name))
        
        menu.exec_(QCursor.pos())

    def _rename_tag_action(self, old_name):
        new_name, ok = self._show_custom_input_dialog("重命名标签", "请输入新名称:", old_name)
        if ok and new_name and new_name.strip():
            self.db.rename_tag(old_name, new_name.strip())
            self._refresh_all()

    def _delete_tag_action(self, tag_name):
        if self._show_custom_confirm_dialog("删除标签", f"确定要彻底删除标签 #{tag_name} 吗？\n所有引用该标签的数据都将解除关联。"):
            self.db.delete_tag(tag_name)
            self._refresh_all()

    def _show_custom_input_dialog(self, title, label_text, default_text=""):
        dlg = QDialog(self)
        dlg.setWindowFlags(Qt.FramelessWindowHint | Qt.Dialog)
        dlg.setAttribute(Qt.WA_TranslucentBackground)
        dlg.setFixedSize(320, 160)
        
        container = QWidget(dlg)
        container.setGeometry(0, 0, 320, 160)
        container.setStyleSheet(f"""
            QWidget {{
                background-color: {COLORS['bg_mid']};
                border: 1px solid #444;
                border-radius: 8px;
            }}
        """)
        
        layout = QVBoxLayout(container)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)
        
        lbl = QLabel(label_text)
        lbl.setStyleSheet("color: #DDD; font-size: 14px; font-weight: bold; border: none;")
        layout.addWidget(lbl)
        
        inp = QLineEdit(default_text)
        inp.setStyleSheet(f"""
            QLineEdit {{
                background-color: #1E1E1E;
                border: 1px solid #555;
                border-radius: 4px;
                padding: 6px;
                color: #EEE;
                font-size: 13px;
            }}
            QLineEdit:focus {{ border: 1px solid {COLORS['primary']}; }}
        """)
        inp.selectAll()
        layout.addWidget(inp)
        
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()
        
        btn_cancel = QPushButton("取消")
        btn_cancel.setCursor(Qt.PointingHandCursor)
        btn_cancel.setStyleSheet("""
            QPushButton { background: transparent; color: #AAA; border: none; font-size: 13px; }
            QPushButton:hover { color: #EEE; }
        """)
        btn_cancel.clicked.connect(dlg.reject)
        
        btn_ok = QPushButton("确定")
        btn_ok.setCursor(Qt.PointingHandCursor)
        btn_ok.setStyleSheet(f"""
            QPushButton {{ 
                background-color: {COLORS['primary']}; 
                color: white; 
                border-radius: 4px; 
                padding: 6px 16px;
                font-weight: bold;
            }}
            QPushButton:hover {{ background-color: #357ABD; }}
        """)
        btn_ok.clicked.connect(dlg.accept)
        
        btn_layout.addWidget(btn_cancel)
        btn_layout.addWidget(btn_ok)
        layout.addLayout(btn_layout)
        
        if dlg.exec_() == QDialog.Accepted:
            return inp.text(), True
        return "", False

    def _show_custom_confirm_dialog(self, title, msg):
        dlg = QDialog(self)
        dlg.setWindowFlags(Qt.FramelessWindowHint | Qt.Dialog)
        dlg.setAttribute(Qt.WA_TranslucentBackground)
        dlg.setFixedSize(340, 180)
        
        container = QWidget(dlg)
        container.setGeometry(0, 0, 340, 180)
        container.setStyleSheet(f"""
            QWidget {{
                background-color: {COLORS['bg_mid']};
                border: 1px solid #444;
                border-radius: 8px;
            }}
        """)
        
        layout = QVBoxLayout(container)
        layout.setContentsMargins(25, 25, 25, 20)
        layout.setSpacing(15)
        
        title_lbl = QLabel(f"⚠️  {title}")
        title_lbl.setStyleSheet(f"color: {COLORS['danger']}; font-size: 15px; font-weight: bold; border: none;")
        layout.addWidget(title_lbl)
        
        content_lbl = QLabel(msg)
        content_lbl.setWordWrap(True)
        content_lbl.setStyleSheet("color: #CCC; font-size: 13px; border: none; line-height: 1.4;")
        layout.addWidget(content_lbl)
        
        layout.addStretch()
        
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()
        
        btn_cancel = QPushButton("取消")
        btn_cancel.setCursor(Qt.PointingHandCursor)
        btn_cancel.setStyleSheet("""
            QPushButton { background: transparent; color: #AAA; border: none; font-size: 13px; }
            QPushButton:hover { color: #EEE; }
        """)
        btn_cancel.clicked.connect(dlg.reject)
        
        btn_del = QPushButton("删除")
        btn_del.setCursor(Qt.PointingHandCursor)
        btn_del.setStyleSheet(f"""
            QPushButton {{ 
                background-color: {COLORS['danger']}; 
                color: white; 
                border-radius: 4px; 
                padding: 6px 16px;
                font-weight: bold;
            }}
            QPushButton:hover {{ background-color: #C0392B; }}
        """)
        btn_del.clicked.connect(dlg.accept)
        
        btn_layout.addWidget(btn_cancel)
        btn_layout.addWidget(btn_del)
        layout.addLayout(btn_layout)
        
        return dlg.exec_() == QDialog.Accepted

    def _refresh_tag_panel(self):
        try:
            while self.tag_list_layout.count():
                item = self.tag_list_layout.takeAt(0)
                if item.widget():
                    item.widget().hide()
                    item.widget().deleteLater()
                
            if self.selected_ids:
                self.tag_panel_title.setText(f"🖊️ 标签管理 ({len(self.selected_ids)})")
                self.tag_input.setPlaceholderText("输入添加... (双击更多)")
                self.clear_tag_btn.hide()
                
                tags = self.db.get_union_tags(list(self.selected_ids))
                
                if not tags:
                    lbl = QLabel("无标签")
                    lbl.setStyleSheet("color:#666; font-style:italic; margin-top:10px;")
                    lbl.setAlignment(Qt.AlignCenter)
                    self.tag_list_widget.layout().addWidget(lbl)
                else:
                    for tag_name in tags:
                        btn = QPushButton(f"{tag_name}  ✕")
                        btn.setCursor(Qt.PointingHandCursor)
                        btn.setStyleSheet(f"""
                            QPushButton {{
                                background-color: #383838;
                                color: #DDD;
                                border: 1px solid #4D4D4D;
                                border-radius: 14px;
                                padding: 5px 12px;
                                text-align: center;
                                font-size: 12px;
                                font-family: "Segoe UI", "Microsoft YaHei";
                            }}
                            QPushButton:hover {{
                                background-color: {COLORS['danger']};
                                border-color: {COLORS['danger']};
                                color: white;
                            }}
                        """)
                        btn.clicked.connect(lambda _, t=tag_name: self._remove_tag_from_selection(t))
                        self.tag_list_layout.addWidget(btn)
                        
            else:
                self.tag_panel_title.setText("🏷️ 最近标签")
                self.tag_input.setPlaceholderText("🔍 搜索...")
                if self.current_tag_filter:
                    self.clear_tag_btn.show()
                else:
                    self.clear_tag_btn.hide()
                    
                c = self.db.conn.cursor()
                search_term = self.tag_input.text().strip()
                sql = '''
                    SELECT t.name, COUNT(it.idea_id) as cnt, MAX(i.updated_at) as last_used
                    FROM tags t 
                    JOIN idea_tags it ON t.id = it.tag_id 
                    JOIN ideas i ON it.idea_id = i.id 
                    WHERE i.is_deleted = 0 
                '''
                params = []
                if search_term:
                    sql += " AND t.name LIKE ?"
                    params.append(f"%{search_term}%")
                
                sql += ' GROUP BY t.id ORDER BY last_used DESC, cnt DESC, t.name ASC'
                
                c.execute(sql, params)
                tags = c.fetchall()
                
                if not tags:
                    return
                    
                for row in tags:
                    tag_name = row[0]
                    count = row[1]
                    is_active = (self.current_tag_filter == tag_name)
                    icon = "✓" if is_active else "🕒"
                    
                    btn = QPushButton(f'{icon} {tag_name} ({count})')
                    btn.setCursor(Qt.PointingHandCursor)
                    
                    btn.setContextMenuPolicy(Qt.CustomContextMenu)
                    btn.customContextMenuRequested.connect(lambda pos, n=tag_name: self._show_tag_context_menu(pos, n))
                    
                    bg_color = COLORS['primary'] if is_active else '#333333'
                    border_color = COLORS['primary'] if is_active else '#444444'
                    text_color = 'white' if is_active else '#CCCCCC'
                    
                    btn.setStyleSheet(f"""
                        QPushButton {{ 
                            background-color: {bg_color}; 
                            border: 1px solid {border_color}; 
                            border-radius: 14px; 
                            padding: 5px 12px; 
                            text-align: center; 
                            color: {text_color}; 
                            font-size: 12px;
                            font-family: "Segoe UI", "Microsoft YaHei";
                        }} 
                        QPushButton:hover {{ 
                            background-color: {COLORS['primary']};
                            border-color: {COLORS['primary']}; 
                            color: white; 
                        }}
                    """)
                    btn.clicked.connect(lambda _, t=tag_name: self._filter_by_tag(t))
                    self.tag_list_layout.addWidget(btn)
        except Exception as e:
            logger.error(f"Tag Panel Refresh Error: {e}")

    def _filter_by_tag(self, tag_name):
        if self.current_tag_filter == tag_name:
            self._clear_tag_filter()
        else:
            self.current_tag_filter = tag_name
            self._set_page(1)
            self.tag_filter_label.setText(f'🏷️ {tag_name}')
            self.tag_filter_label.show()
            self.clear_tag_btn.show()
            
            QTimer.singleShot(10, self._load_data)
            QTimer.singleShot(10, self._refresh_tag_panel)

    def _clear_tag_filter(self):
        self.current_tag_filter = None
        self.tag_filter_label.hide()
        self.clear_tag_btn.hide()
        QTimer.singleShot(10, self._load_data)
        QTimer.singleShot(10, self._refresh_tag_panel)

    def _get_resize_area(self, pos):
        x, y = pos.x(), pos.y()
        w, h = self.width(), self.height()
        m = self.RESIZE_MARGIN
        
        areas = []
        if x < m: areas.append('left')
        elif x > w - m: areas.append('right')
        if y < m: areas.append('top')
        elif y > h - m: areas.append('bottom')
        return areas
    
    def _set_cursor_for_resize(self, areas):
        if not areas:
            self.setCursor(Qt.ArrowCursor)
            return
        if 'left' in areas and 'top' in areas: self.setCursor(Qt.SizeFDiagCursor)
        elif 'right' in areas and 'bottom' in areas: self.setCursor(Qt.SizeFDiagCursor)
        elif 'left' in areas and 'bottom' in areas: self.setCursor(Qt.SizeBDiagCursor)
        elif 'right' in areas and 'top' in areas: self.setCursor(Qt.SizeBDiagCursor)
        elif 'left' in areas or 'right' in areas: self.setCursor(Qt.SizeHorCursor)
        elif 'top' in areas or 'bottom' in areas: self.setCursor(Qt.SizeVerCursor)

    def mousePressEvent(self, e):
        if e.button() == Qt.LeftButton:
            areas = self._get_resize_area(e.pos())
            if areas:
                self._resize_area = areas
                self._resize_start_pos = e.globalPos()
                self._resize_start_geometry = self.geometry()
                self._drag_pos = None
            elif e.y() < 40:
                self._drag_pos = e.globalPos() - self.frameGeometry().topLeft()
                self._resize_area = None
            else:
                self._drag_pos = None
                self._resize_area = None
            e.accept()

    def mouseMoveEvent(self, e):
        if e.buttons() == Qt.NoButton:
            areas = self._get_resize_area(e.pos())
            self._set_cursor_for_resize(areas)
            e.accept()
            return
        
        if e.buttons() == Qt.LeftButton:
            if self._resize_area:
                delta = e.globalPos() - self._resize_start_pos
                rect = self._resize_start_geometry
                new_rect = rect.adjusted(0, 0, 0, 0)
                if 'left' in self._resize_area:
                    new_left = rect.left() + delta.x()
                    if rect.right() - new_left >= 600:
                        new_rect.setLeft(new_left)
                if 'right' in self._resize_area:
                    new_width = rect.width() + delta.x()
                    if new_width >= 600:
                        new_rect.setWidth(new_width)
                if 'top' in self._resize_area:
                    new_top = rect.top() + delta.y()
                    if rect.bottom() - new_top >= 400:
                        new_rect.setTop(new_top)
                if 'bottom' in self._resize_area:
                    new_height = rect.height() + delta.y()
                    if new_height >= 400:
                        new_rect.setHeight(new_height)
                
                self.setGeometry(new_rect)
                e.accept()
            elif self._drag_pos:
                self.move(e.globalPos() - self._drag_pos)
                e.accept()

    def mouseReleaseEvent(self, e):
        self._drag_pos = None
        self._resize_area = None
        self.setCursor(Qt.ArrowCursor)

    def mouseDoubleClickEvent(self, e):
        if e.y() < 40: self._toggle_maximize()

    def _toggle_maximize(self):
        if self.isMaximized():
            self.showNormal()
            self.max_btn.setText('□')
        else:
            self.showMaximized()
            self.max_btn.setText('❐')

    def _add_search_to_history(self):
        search_text = self.search.text().strip()
        if search_text:
            self.search.add_history_entry(search_text)

    def quick_add_idea(self, text):
        raw = text.strip()
        if not raw: return
        lines = raw.split('\n')
        title = lines[0][:25].strip() if lines else "快速记录"
        if len(lines) > 1 or len(lines[0]) > 25: title += "..."
        idea_id = self.db.add_idea(title, raw, COLORS['default_note'], [], None)
        self._show_tag_selector(idea_id)
        self._refresh_all()

    def _show_tag_selector(self, idea_id):
        tag_selector = AdvancedTagSelector(self.db, idea_id, None, self)
        tag_selector.tags_confirmed.connect(lambda tags: self._on_tags_confirmed(idea_id, tags))
        tag_selector.show_at_cursor()

    def _on_tags_confirmed(self, idea_id, tags):
        self._show_tooltip(f'✅ 已记录并绑定 {len(tags)} 个标签', 2000)
        self._refresh_all()

    def _set_filter(self, f_type, val):
        self.curr_filter = (f_type, val)
        self.selected_ids.clear()
        self.last_clicked_id = None
        self.current_tag_filter = None
        self.tag_filter_label.hide()
        self.clear_tag_btn.hide()
        titles = {'all':'全部数据','today':'今日数据','trash':'回收站','favorite':'我的收藏'}
        if f_type == 'category':
            cat = next((c for c in self.db.get_categories() if c[0] == val), None)
            self.header_label.setText(f"📂 {cat[1]}" if cat else '文件夹')
        else:
            self.header_label.setText(titles.get(f_type, '灵感列表'))
        
        QTimer.singleShot(10, self._load_data)
        QTimer.singleShot(10, self._update_ui_state)
        QTimer.singleShot(10, self._refresh_tag_panel)

    def _load_data(self):
        try:
            while self.list_layout.count():
                w = self.list_layout.takeAt(0).widget()
                if w: w.deleteLater()
            self.cards = {}
            self.card_ordered_ids = []
            
            total_items = self.db.get_ideas_count(self.search.text(), *self.curr_filter, tag_filter=self.current_tag_filter)
            self.total_pages = math.ceil(total_items / self.page_size) if total_items > 0 else 1
            
            if self.current_page > self.total_pages: self.current_page = self.total_pages
            if self.current_page < 1: self.current_page = 1

            data_list = self.db.get_ideas(self.search.text(), *self.curr_filter, page=self.current_page, page_size=self.page_size, tag_filter=self.current_tag_filter)
            
            if not data_list:
                self.list_layout.addWidget(QLabel("🔭 空空如也", alignment=Qt.AlignCenter, styleSheet="color:#666;font-size:16px;margin-top:50px"))
            for d in data_list:
                c = IdeaCard(d, self.db)
                c.get_selected_ids_func = lambda: list(self.selected_ids)
                c.selection_requested.connect(self._handle_selection_request)
                c.double_clicked.connect(self._extract_single)
                c.setContextMenuPolicy(Qt.CustomContextMenu)
                c.customContextMenuRequested.connect(lambda pos, iid=d[0]: self._show_card_menu(iid, pos))
                self.list_layout.addWidget(c)
                self.cards[d[0]] = c
                self.card_ordered_ids.append(d[0])
                
            self._update_pagination_ui()
            self._update_ui_state()
        except Exception as e:
            logger.error(f"Load Data Error: {e}")

    def _show_card_menu(self, idea_id, pos):
        if idea_id not in self.selected_ids:
            self.selected_ids = {idea_id}
            self.last_clicked_id = idea_id
            self._update_all_card_selections()
            self._update_ui_state()
        data = self.db.get_idea(idea_id)
        if not data: return
        menu = QMenu(self)
        menu.setStyleSheet(f"QMenu {{ background-color: {COLORS['bg_mid']}; color: white; border: 1px solid {COLORS['bg_light']}; border-radius: 6px; padding: 4px; }} QMenu::item {{ padding: 8px 20px; border-radius: 4px; }} QMenu::item:selected {{ background-color: {COLORS['primary']}; }} QMenu::separator {{ height: 1px; background: {COLORS['bg_light']}; margin: 4px 0px; }}")
        
        in_trash = (self.curr_filter[0] == 'trash')
        is_locked = data[13] if len(data) > 13 else 0
        
        if not in_trash:
            if not is_locked:
                menu.addAction('✏️ 编辑', self._do_edit)
            else:
                edit_action = menu.addAction('✏️ 编辑 (已锁定)')
                edit_action.setEnabled(False) 
                
            menu.addAction('📋 提取(Ctrl+T)', lambda: self._extract_single(idea_id))
            menu.addSeparator()
            
            if is_locked:
                menu.addAction('🔓 解锁', self._do_lock)
            else:
                menu.addAction('🔒 锁定 (Ctrl+S)', self._do_lock)
                
            menu.addSeparator()
            menu.addAction('📌 取消置顶' if data[4] else '📌 置顶', self._do_pin)
            menu.addAction('☆ 取消收藏' if data[5] else '⭐ 收藏', self._do_fav)
            menu.addSeparator()
            
            if not is_locked:
                cat_menu = menu.addMenu('📂 移动到分类')
                cat_menu.addAction('⚠️ 未分类', lambda: self._move_to_category(None))
                for cat in self.db.get_categories():
                    cat_menu.addAction(f'📂 {cat[1]}', lambda cid=cat[0]: self._move_to_category(cid))
                menu.addSeparator()
                menu.addAction('🗑️ 移至回收站', self._do_del)
            else:
                del_action = menu.addAction('🗑️ 移至回收站 (已锁定)')
                del_action.setEnabled(False)
                
        else:
            menu.addAction('♻️ 恢复', self._do_restore)
            menu.addAction('🗑️ 永久删除', self._do_destroy)
            
        card = self.cards.get(idea_id)
        if card: menu.exec_(card.mapToGlobal(pos))

    def _do_lock(self):
        if not self.selected_ids: return
        status_map = self.db.get_lock_status(list(self.selected_ids))
        any_unlocked = False
        for iid, is_locked in status_map.items():
            if not is_locked:
                any_unlocked = True
                break
        target_state = 1 if any_unlocked else 0
        self.db.set_locked(list(self.selected_ids), target_state)
        action_name = "锁定" if target_state else "解锁"
        self._show_tooltip(f"✅ 已{action_name} {len(self.selected_ids)} 项")
        QTimer.singleShot(10, self._refresh_all)

    def _move_to_category(self, cat_id):
        if self.selected_ids:
            valid_ids = []
            status_map = self.db.get_lock_status(list(self.selected_ids))
            for iid in self.selected_ids:
                if not status_map.get(iid, 0):
                    valid_ids.append(iid)
            
            if len(valid_ids) < len(self.selected_ids):
                self._show_tooltip("⚠️ 部分项目已锁定，无法移动")
                
            for iid in valid_ids:
                self.db.move_category(iid, cat_id)
            self._refresh_all()
            if valid_ids:
                self._show_tooltip(f'✅ 已移动 {len(valid_ids)} 项')

    def _handle_selection_request(self, iid, is_ctrl, is_shift):
        if is_shift and self.last_clicked_id is not None:
            try:
                start_index = self.card_ordered_ids.index(self.last_clicked_id)
                end_index = self.card_ordered_ids.index(iid)
                min_idx = min(start_index, end_index)
                max_idx = max(start_index, end_index)
                if not is_ctrl: self.selected_ids.clear()
                for idx in range(min_idx, max_idx + 1):
                    self.selected_ids.add(self.card_ordered_ids[idx])
            except ValueError:
                self.selected_ids.clear()
                self.selected_ids.add(iid)
                self.last_clicked_id = iid
        elif is_ctrl:
            if iid in self.selected_ids: self.selected_ids.remove(iid)
            else: self.selected_ids.add(iid)
            self.last_clicked_id = iid
        else:
            self.selected_ids.clear()
            self.selected_ids.add(iid)
            self.last_clicked_id = iid
        self._update_all_card_selections()
        QTimer.singleShot(0, self._update_ui_state)

    def _update_all_card_selections(self):
        for iid, card in self.cards.items():
            card.update_selection(iid in self.selected_ids)

    def _update_ui_state(self):
        in_trash = (self.curr_filter[0] == 'trash')
        selection_count = len(self.selected_ids)
        has_selection = selection_count > 0
        is_single_selection = selection_count == 1
        for k in ['pin', 'fav', 'del']: self.btns[k].setVisible(not in_trash)
        for k in ['rest', 'dest']: self.btns[k].setVisible(in_trash)
        self.btns['edit'].setVisible(not in_trash)
        self.btns['edit'].setEnabled(is_single_selection)
        for k in ['pin', 'fav', 'del', 'rest', 'dest']: self.btns[k].setEnabled(has_selection)
        if is_single_selection and not in_trash:
            idea_id = list(self.selected_ids)[0]
            d = self.db.get_idea(idea_id)
            if d:
                self.btns['pin'].setText('📍' if not d[4] else '📌')
                self.btns['fav'].setText('☆' if not d[5] else '⭐')
        else:
            self.btns['pin'].setText('📌')
            self.btns['fav'].setText('⭐')
        QTimer.singleShot(0, self._refresh_tag_panel)

    def _on_new_data_in_category_requested(self, cat_id):
        self._open_edit_dialog(category_id_for_new=cat_id)

    def _open_edit_dialog(self, idea_id=None, category_id_for_new=None):
        for dialog in self.open_dialogs:
            if hasattr(dialog, 'idea_id') and dialog.idea_id == idea_id and idea_id is not None:
                dialog.activateWindow()
                return

        dialog = EditDialog(self.db, idea_id=idea_id, category_id_for_new=category_id_for_new, parent=None)
        dialog.setAttribute(Qt.WA_DeleteOnClose)
        
        dialog.data_saved.connect(self._refresh_all)
        dialog.finished.connect(lambda: self.open_dialogs.remove(dialog) if dialog in self.open_dialogs else None)

        self.open_dialogs.append(dialog)
        dialog.show()
        dialog.activateWindow()

    def _show_tooltip(self, msg, dur=2000):
        QToolTip.showText(QCursor.pos(), msg, self)
        QTimer.singleShot(dur, QToolTip.hideText)

    def new_idea(self):
        self._open_edit_dialog()

    def _do_edit(self):
        if len(self.selected_ids) == 1:
            idea_id = list(self.selected_ids)[0]
            status = self.db.get_lock_status([idea_id])
            if status.get(idea_id, 0):
                self._show_tooltip("🔒 该笔记已锁定，请先解锁")
                return
            self._open_edit_dialog(idea_id=idea_id)

    def _do_pin(self):
        if self.selected_ids:
            for iid in self.selected_ids: self.db.toggle_field(iid, 'is_pinned')
            self._load_data()

    def _do_fav(self):
        if self.selected_ids:
            for iid in self.selected_ids: self.db.toggle_field(iid, 'is_favorite')
            self._refresh_all()

    def _do_del(self):
        if self.selected_ids:
            valid_ids = []
            status_map = self.db.get_lock_status(list(self.selected_ids))
            for iid in self.selected_ids:
                if not status_map.get(iid, 0):
                    valid_ids.append(iid)
            
            if len(valid_ids) < len(self.selected_ids):
                self._show_tooltip("⚠️ 部分项目已锁定，无法删除")
            
            if not valid_ids: return

            for iid in valid_ids: self.db.set_deleted(iid, True)
            self.selected_ids.clear()
            QTimer.singleShot(10, self._refresh_all)

    def _do_restore(self):
        if self.selected_ids:
            for iid in self.selected_ids: self.db.set_deleted(iid, False)
            self.selected_ids.clear()
            QTimer.singleShot(10, self._refresh_all)

    def _do_destroy(self):
        if self.selected_ids and QMessageBox.Yes == QMessageBox.warning(self, '⚠️ 警告', f'确定永久删除选中的 {len(self.selected_ids)} 项?\n此操作不可恢复!', QMessageBox.Yes | QMessageBox.No):
            for iid in self.selected_ids: self.db.delete_permanent(iid)
            self.selected_ids.clear()
            QTimer.singleShot(10, self._refresh_all)

    def _refresh_all(self):
        if not self.isVisible(): return
        QTimer.singleShot(10, self._load_data)
        QTimer.singleShot(10, self.sidebar.refresh)
        QTimer.singleShot(10, self._update_ui_state)
        QTimer.singleShot(10, self._refresh_tag_panel)

    def _extract_single(self, idea_id):
        data = self.db.get_idea(idea_id)
        if not data:
            self._show_tooltip('⚠️ 数据不存在', 1500)
            return
        content_to_copy = data[2] if data[2] else ""
        QApplication.clipboard().setText(content_to_copy)
        preview = content_to_copy.replace('\n', ' ')[:40] + ('...' if len(content_to_copy) > 40 else '')
        self._show_tooltip(f'✅ 内容已提取到剪贴板\n\n📋 {preview}', 2500)

    def _extract_all(self):
        data = self.db.get_ideas('', 'all', None)
        if not data:
            self._show_tooltip('🔭 暂无数据', 1500)
            return
        lines = ['='*60, '💡 灵感闪记 - 内容导出', '='*60, '']
        for d in data:
            lines.append(f"【{d[1]}】")
            if d[4]: lines.append('📌 已置顶')
            if d[5]: lines.append('⭐ 已收藏')
            tags = self.db.get_tags(d[0])
            if tags: lines.append(f"标签: {', '.join(tags)}")
            lines.append(f"时间: {d[6]}")
            if d[2]: lines.append(f"\n{d[2]}")
            lines.append('\n'+'-'*60+'\n')
        text = '\n'.join(lines)
        QApplication.clipboard().setText(text)
        self._show_tooltip(f'✅ 已提取 {len(data)} 条到剪贴板!', 2000)

    def _handle_del_key(self):
        self._do_destroy() if self.curr_filter[0] == 'trash' else self._do_del()

    def _handle_extract_key(self):
        if len(self.selected_ids) == 1:
            self._extract_single(list(self.selected_ids)[0])
        elif len(self.selected_ids) > 1:
            self._show_tooltip('⚠️ 请选择一条笔记进行提取', 1500)
        else:
            self._show_tooltip('⚠️ 请先选择一条笔记', 1500)

    def show_main_window(self):
        self.show()
        self.activateWindow()

    def quit_app(self):
        BackupService.run_backup()
        QApplication.quit()

    def _save_window_state(self):
        save_setting("main_window_geometry_hex", self.saveGeometry().toHex().data().decode())
        save_setting("main_window_maximized", self.isMaximized())

    def save_state(self):
        self._save_window_state()

    def _restore_window_state(self):
        geo_hex = load_setting("main_window_geometry_hex")
        if geo_hex:
            try:
                self.restoreGeometry(QByteArray.fromHex(geo_hex.encode()))
            except Exception:
                self.resize(1300, 700)
        else:
            self.resize(1300, 700)
            
        if load_setting("main_window_maximized", False):
            self.showMaximized()
            self.max_btn.setText('❐')

    def closeEvent(self, event):
        self._save_window_state()
        self.closing.emit()
        self.hide()
        event.ignore()
```

## 文件: ui\quick_window.py

```python
# -*- coding: utf-8 -*-
# ui/quick_window.py
import sys
import os
import ctypes
from ctypes import wintypes
import time
import datetime
import subprocess
from PyQt5.QtWidgets import (QApplication, QWidget, QVBoxLayout, QListWidget, QLineEdit, 
                             QListWidgetItem, QHBoxLayout, QTreeWidget, QTreeWidgetItem, 
                             QPushButton, QStyle, QAction, QSplitter, QGraphicsDropShadowEffect, 
                             QLabel, QTreeWidgetItemIterator, QShortcut, QAbstractItemView, QMenu,
                             QColorDialog, QInputDialog, QMessageBox)
from PyQt5.QtCore import Qt, QTimer, QPoint, QRect, QSettings, QUrl, QMimeData, pyqtSignal, QObject, QSize, QByteArray
from PyQt5.QtGui import QImage, QColor, QCursor, QPixmap, QPainter, QIcon, QKeySequence, QDrag
from services.preview_service import PreviewService
from ui.dialogs import EditDialog
from ui.advanced_tag_selector import AdvancedTagSelector
from core.config import COLORS
from core.settings import load_setting, save_setting

# ... (Win32 API 定义部分保持不变) ...
if sys.platform == "win32":
    user32 = ctypes.windll.user32
    kernel32 = ctypes.windll.kernel32
    KEYEVENTF_KEYUP = 0x0002
    VK_CONTROL = 0x11
    VK_V = 0x56
    HWND_TOPMOST = -1
    HWND_NOTOPMOST = -2
    SWP_NOMOVE = 0x0002
    SWP_NOSIZE = 0x0001
    SWP_NOACTIVATE = 0x0010
    SWP_FLAGS = SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE
    class GUITHREADINFO(ctypes.Structure):
        _fields_ = [
            ("cbSize", wintypes.DWORD),
            ("flags", wintypes.DWORD),
            ("hwndActive", wintypes.HWND),
            ("hwndFocus", wintypes.HWND),      
            ("hwndCapture", wintypes.HWND),
            ("hwndMenuOwner", wintypes.HWND),
            ("hwndMoveSize", wintypes.HWND),
            ("hwndCaret", wintypes.HWND),
            ("rcCaret", wintypes.RECT)
        ]
    user32.GetGUIThreadInfo.argtypes = [wintypes.DWORD, ctypes.POINTER(GUITHREADINFO)]
    user32.GetGUIThreadInfo.restype = wintypes.BOOL
    user32.SetFocus.argtypes = [wintypes.HWND]
    user32.SetFocus.restype = wintypes.HWND
    user32.SetWindowPos.argtypes = [wintypes.HWND, wintypes.HWND, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_uint]
else:
    user32 = None
    kernel32 = None

def log(message):
    pass

try:
    from data.db_manager import DatabaseManager as DBManager
    from services.clipboard import ClipboardManager
except ImportError:
    class DBManager:
        def get_items(self, **kwargs): return []
        def get_partitions_tree(self): return []
        def get_partition_item_counts(self): return {}
    class ClipboardManager(QObject):
        data_captured = pyqtSignal()
        def __init__(self, db_manager):
            super().__init__()
            self.db = db_manager
        def process_clipboard(self, mime_data, cat_id=None): pass

# ... (DraggableListWidget 和 DropTreeWidget 类保持不变) ...
class DraggableListWidget(QListWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setDragEnabled(True)
    def startDrag(self, supportedActions):
        item = self.currentItem()
        if not item: return
        data = item.data(Qt.UserRole)
        if not data: return
        idea_id = data[0]
        mime = QMimeData()
        mime.setData('application/x-idea-id', str(idea_id).encode())
        drag = QDrag(self)
        drag.setMimeData(mime)
        drag.exec_(Qt.MoveAction)

class DropTreeWidget(QTreeWidget):
    item_dropped = pyqtSignal(int, int)
    order_changed = pyqtSignal()
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(True)
        self.setDragEnabled(True)
        self.setDragDropMode(QAbstractItemView.InternalMove)
        self.setDropIndicatorShown(True)
    def dragEnterEvent(self, event):
        if event.source() == self:
            super().dragEnterEvent(event)
            event.accept()
        elif event.mimeData().hasFormat('application/x-idea-id'):
            event.accept()
        else:
            event.ignore()
    def dragMoveEvent(self, event):
        if event.source() == self:
            super().dragMoveEvent(event)
        elif event.mimeData().hasFormat('application/x-idea-id'):
            item = self.itemAt(event.pos())
            if item:
                data = item.data(0, Qt.UserRole)
                if data and data.get('type') in ['partition', 'favorite']:
                    self.setCurrentItem(item)
                    event.accept()
                    return
            event.ignore()
        else:
            event.ignore()
    def dropEvent(self, event):
        if event.mimeData().hasFormat('application/x-idea-id'):
            try:
                idea_id = int(event.mimeData().data('application/x-idea-id'))
                item = self.itemAt(event.pos())
                if item:
                    data = item.data(0, Qt.UserRole)
                    if data and data.get('type') in ['partition', 'favorite']:
                        cat_id = data.get('id')
                        self.item_dropped.emit(idea_id, cat_id)
                        event.acceptProposedAction()
            except Exception as e:
                pass
        elif event.source() == self:
            super().dropEvent(event)
            self.order_changed.emit()
            event.accept()

# ... (DARK_STYLESHEET 和 ClickableLineEdit 类保持不变) ...
DARK_STYLESHEET = """
QWidget#Container {
    background-color: #1e1e1e;
    border: 1px solid #333333; 
    border-radius: 8px;    
}
QWidget {
    color: #cccccc;
    font-family: "Microsoft YaHei", "Segoe UI Emoji";
    font-size: 14px;
}
QLabel#TitleLabel {
    color: #858585;
    font-weight: bold;
    font-size: 15px;
    padding-left: 5px;
}
QListWidget, QTreeWidget {
    border: none;
    background-color: #1e1e1e;
    alternate-background-color: #252526;
    outline: none;
}
QListWidget::item { padding: 8px; border: none; }
QListWidget::item:selected, QTreeWidget::item:selected {
    background-color: #4a90e2; color: #FFFFFF;
}
QListWidget::item:hover { background-color: #444444; }

QSplitter::handle { background-color: #333333; width: 2px; }
QSplitter::handle:hover { background-color: #4a90e2; }

QLineEdit {
    background-color: #252526;
    border: 1px solid #333333;
    border-radius: 4px;
    padding: 6px;
    font-size: 16px;
}

QPushButton#ToolButton, QPushButton#MinButton, QPushButton#CloseButton, QPushButton#PinButton, QPushButton#MaxButton { 
    background-color: transparent; 
    border-radius: 4px; 
    padding: 0px;  
    font-size: 16px;
    font-weight: bold;
    text-align: center;
}
QPushButton#ToolButton:hover, QPushButton#MinButton:hover, QPushButton#MaxButton:hover { background-color: #444; }
QPushButton#ToolButton:checked, QPushButton#MaxButton:checked { background-color: #555; border: 1px solid #666; }
QPushButton#CloseButton:hover { background-color: #E81123; color: white; }
QPushButton#PinButton:hover { background-color: #444; }
QPushButton#PinButton:checked { background-color: #0078D4; color: white; border: 1px solid #005A9E; }
"""

class ClickableLineEdit(QLineEdit):
    doubleClicked = pyqtSignal()
    def mouseDoubleClickEvent(self, event):
        self.doubleClicked.emit()
        super().mouseDoubleClickEvent(event)

class QuickWindow(QWidget):
    RESIZE_MARGIN = 18 
    # 【修改】信号名称改为 toggle_main_window_requested
    toggle_main_window_requested = pyqtSignal()

    def __init__(self, db_manager):
        super().__init__()
        self.db = db_manager
        self.settings = QSettings("MyTools", "RapidNotes")
        
        self.m_drag = False
        self.m_DragPosition = QPoint()
        self.resize_area = None
        
        self._is_pinned = False
        self.last_active_hwnd = None
        self.last_focus_hwnd = None
        self.last_thread_id = None
        self.my_hwnd = None
        
        self.cm = ClipboardManager(self.db)
        self.clipboard = QApplication.clipboard()
        self.clipboard.dataChanged.connect(self.on_clipboard_changed)
        self.cm.data_captured.connect(self._update_list)
        self._processing_clipboard = False
        
        self.open_dialogs = []
        
        self.preview_service = PreviewService(self.db, self)
        
        self._init_ui()
        self._setup_shortcuts()
        self._restore_window_state()
        
        self.setMouseTracking(True)
        self.container.setMouseTracking(True)
        
        self.monitor_timer = QTimer(self)
        self.monitor_timer.timeout.connect(self._monitor_foreground_window)
        if user32:
            self.monitor_timer.start(200)

        self.search_timer = QTimer(self)
        self.search_timer.setSingleShot(True)
        self.search_timer.timeout.connect(self._update_list)
        
        self.search_box.textChanged.connect(self._on_search_text_changed)
        self.list_widget.itemActivated.connect(self._on_item_activated)
        
        self.list_widget.setContextMenuPolicy(Qt.CustomContextMenu)
        self.list_widget.customContextMenuRequested.connect(self._show_list_context_menu)
        
        self.partition_tree.currentItemChanged.connect(self._on_partition_selection_changed)
        self.partition_tree.item_dropped.connect(self._handle_category_drop)
        
        self.partition_tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.partition_tree.customContextMenuRequested.connect(self._show_partition_context_menu)
        self.partition_tree.order_changed.connect(self._save_partition_order)
        
        self.clear_action.triggered.connect(self.search_box.clear)
        self.search_box.textChanged.connect(lambda text: self.clear_action.setVisible(bool(text)))
        self.clear_action.setVisible(False)
        
        self.btn_stay_top.clicked.connect(self._toggle_stay_on_top)
        self.btn_toggle_side.clicked.connect(self._toggle_partition_panel)
        # 【修改】连接到新信号
        self.btn_open_full.clicked.connect(self.toggle_main_window_requested)
        self.btn_minimize.clicked.connect(self.showMinimized) 
        self.btn_close.clicked.connect(self.close)
        
        self._update_partition_tree()
        self._update_list()
        
        self.partition_tree.currentItemChanged.connect(self._update_partition_status_display)

    def _init_ui(self):
        self.setWindowTitle("快速笔记")
        self.resize(830, 630)
        self.setAttribute(Qt.WA_TranslucentBackground)
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.Window)
        
        self.root_layout = QVBoxLayout(self)
        self.root_layout.setContentsMargins(15, 15, 15, 15) 
        
        self.container = QWidget()
        self.container.setObjectName("Container")
        self.root_layout.addWidget(self.container)
        
        shadow = QGraphicsDropShadowEffect(self)
        shadow.setBlurRadius(25)
        shadow.setXOffset(0)
        shadow.setYOffset(4)
        shadow.setColor(QColor(0, 0, 0, 100))
        self.container.setGraphicsEffect(shadow)
        
        self.setStyleSheet(DARK_STYLESHEET)
        
        self.main_layout = QVBoxLayout(self.container)
        self.main_layout.setContentsMargins(10, 10, 10, 10)
        self.main_layout.setSpacing(10)
        
        # --- Title Bar ---
        title_bar_layout = QHBoxLayout()
        title_bar_layout.setContentsMargins(0, 0, 0, 0)
        title_bar_layout.setSpacing(5)
        
        self.title_label = QLabel("⚡️ 快速笔记")
        self.title_label.setObjectName("TitleLabel")
        title_bar_layout.addWidget(self.title_label)
        
        title_bar_layout.addStretch()
        
        self.btn_stay_top = QPushButton("📌", self)
        self.btn_stay_top.setObjectName("PinButton")
        self.btn_stay_top.setToolTip("保持置顶")
        self.btn_stay_top.setCheckable(True)
        self.btn_stay_top.setFixedSize(32, 32)

        self.btn_toggle_side = QPushButton("👁️", self)
        self.btn_toggle_side.setObjectName("ToolButton")
        self.btn_toggle_side.setToolTip("显示/隐藏侧边栏")
        self.btn_toggle_side.setFixedSize(32, 32)
        
        self.btn_open_full = QPushButton(self)
        self.btn_open_full.setObjectName("MaxButton")
        self.btn_open_full.setToolTip("切换主程序界面") # 修改提示
        self.btn_open_full.setIcon(self.style().standardIcon(QStyle.SP_TitleBarMaxButton))
        self.btn_open_full.setFixedSize(32, 32)

        self.btn_minimize = QPushButton("—", self)
        self.btn_minimize.setObjectName("MinButton")
        self.btn_minimize.setToolTip("最小化")
        self.btn_minimize.setFixedSize(32, 32)
        
        self.btn_close = QPushButton(self)
        self.btn_close.setObjectName("CloseButton")
        self.btn_close.setToolTip("关闭")
        self.btn_close.setIcon(self.style().standardIcon(QStyle.SP_TitleBarCloseButton))
        self.btn_close.setFixedSize(32, 32)
        
        title_bar_layout.addWidget(self.btn_stay_top)
        title_bar_layout.addWidget(self.btn_toggle_side)
        title_bar_layout.addWidget(self.btn_open_full) 
        title_bar_layout.addWidget(self.btn_minimize)
        title_bar_layout.addWidget(self.btn_close)
        
        self.main_layout.addLayout(title_bar_layout)
        
        # --- Search Bar ---
        self.search_box = QLineEdit(self)
        self.search_box.setPlaceholderText("搜索剪贴板历史...")
        self.clear_action = QAction(self)
        self.clear_action.setIcon(self.style().standardIcon(QStyle.SP_DialogCloseButton))
        self.search_box.addAction(self.clear_action, QLineEdit.TrailingPosition)
        
        self.main_layout.addWidget(self.search_box)
        
        # --- Splitter Content ---
        content_widget = QWidget()
        content_layout = QHBoxLayout(content_widget)
        content_layout.setContentsMargins(0, 0, 0, 0)
        
        self.splitter = QSplitter(Qt.Horizontal)
        self.splitter.setHandleWidth(4)
        
        self.list_widget = DraggableListWidget()
        self.list_widget.setFocusPolicy(Qt.StrongFocus)
        self.list_widget.setAlternatingRowColors(True)
        self.list_widget.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.list_widget.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.list_widget.setIconSize(QSize(120, 90))

        self.partition_tree = DropTreeWidget()
        self.partition_tree.setHeaderHidden(True)
        self.partition_tree.setFocusPolicy(Qt.NoFocus)
        self.partition_tree.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.partition_tree.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        
        self.splitter.addWidget(self.list_widget)
        self.splitter.addWidget(self.partition_tree)
        self.splitter.setStretchFactor(0, 1)
        self.splitter.setStretchFactor(1, 0)
        self.splitter.setSizes([550, 150])
        
        content_layout.addWidget(self.splitter)
        self.main_layout.addWidget(content_widget, 1)

        # --- Status Bar ---
        self.partition_status_label = QLabel("当前分区: 全部数据")
        self.partition_status_label.setObjectName("PartitionStatusLabel")
        self.partition_status_label.setStyleSheet("font-size: 11px; color: #888; padding-left: 5px;")
        self.main_layout.addWidget(self.partition_status_label)
        self.partition_status_label.hide()

    # --- 快捷键设置 ---
    def _setup_shortcuts(self):
        QShortcut(QKeySequence("Ctrl+F"), self, self.search_box.setFocus)
        QShortcut(QKeySequence("Delete"), self, self._do_delete_selected)
        QShortcut(QKeySequence("Ctrl+E"), self, self._do_toggle_favorite)
        QShortcut(QKeySequence("Ctrl+P"), self, self._do_toggle_pin)
        QShortcut(QKeySequence("Ctrl+W"), self, self.close)
        
        # 【新增】锁定快捷键
        QShortcut(QKeySequence("Ctrl+S"), self, self._do_lock_selected)
        
        # 监听空格键：预览
        self.space_shortcut = QShortcut(QKeySequence(Qt.Key_Space), self)
        self.space_shortcut.setContext(Qt.WindowShortcut)
        self.space_shortcut.activated.connect(self._do_preview)

    def _do_preview(self):
        iid = self._get_selected_id()
        if iid:
            self.preview_service.toggle_preview({iid})

    # --- 右键菜单逻辑 ---
    def _show_list_context_menu(self, pos):
        item = self.list_widget.itemAt(pos)
        if not item: return

        data = item.data(Qt.UserRole)
        if not data: return
        
        idea_id = data[0]
        is_pinned = data[4]
        is_fav = data[5]
        # 获取锁定状态
        is_locked = data[13] if len(data) > 13 else 0

        menu = QMenu(self)
        menu.setStyleSheet("""
            QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; border-radius: 4px; padding: 4px; }
            QMenu::item { padding: 6px 20px; border-radius: 3px; }
            QMenu::item:selected { background-color: #4a90e2; color: white; }
            QMenu::separator { background-color: #444; height: 1px; margin: 4px 0px; }
        """)

        action_preview = menu.addAction("👁️ 预览 (Space)")
        action_preview.triggered.connect(self._do_preview)
        
        menu.addSeparator()

        action_copy = menu.addAction("📋 复制内容")
        action_copy.triggered.connect(lambda: self._copy_item_content(data))
        
        menu.addSeparator()
        
        # 锁定选项
        if is_locked:
            menu.addAction("🔓 解锁", self._do_lock_selected)
        else:
            menu.addAction("🔒 锁定 (Ctrl+S)", self._do_lock_selected)

        action_pin = menu.addAction("📌 取消置顶" if is_pinned else "📌 置顶")
        action_pin.triggered.connect(self._do_toggle_pin)

        action_fav = menu.addAction("⭐ 取消收藏" if is_fav else "⭐ 收藏")
        action_fav.triggered.connect(self._do_toggle_favorite)
        
        if not is_locked:
            action_edit = menu.addAction("✏️ 编辑")
            action_edit.triggered.connect(self._do_edit_selected)
            menu.addSeparator()
            action_del = menu.addAction("🗑️ 删除")
            action_del.triggered.connect(self._do_delete_selected)
        else:
            menu.addSeparator()
            del_action = menu.addAction("🗑️ 删除 (已锁定)")
            del_action.setEnabled(False)

        menu.exec_(self.list_widget.mapToGlobal(pos))

    def _copy_item_content(self, data):
        item_type_idx = 10
        item_type = data[item_type_idx] if len(data) > item_type_idx else 'text'
        content = data[2]
        if item_type == 'text' and content:
            QApplication.clipboard().setText(content)

    # --- 逻辑处理 ---

    def _get_selected_id(self):
        item = self.list_widget.currentItem()
        if not item: return None
        data = item.data(Qt.UserRole)
        if data: return data[0] 
        return None
    
    # 锁定逻辑
    def _do_lock_selected(self):
        iid = self._get_selected_id()
        if not iid: return
        
        status = self.db.get_lock_status([iid])
        current_state = status.get(iid, 0)
        
        new_state = 0 if current_state else 1
        self.db.set_locked([iid], new_state)
        
        self._update_list()
    
    def _do_edit_selected(self):
        iid = self._get_selected_id()
        if iid:
            # 检查锁定
            status = self.db.get_lock_status([iid])
            if status.get(iid, 0):
                return

            for dialog in self.open_dialogs:
                if hasattr(dialog, 'idea_id') and dialog.idea_id == iid:
                    dialog.activateWindow()
                    return

            dialog = EditDialog(self.db, idea_id=iid, parent=None)
            dialog.setAttribute(Qt.WA_DeleteOnClose)
            
            dialog.data_saved.connect(self._update_list)
            dialog.data_saved.connect(self._update_partition_tree)
            
            dialog.finished.connect(lambda: self.open_dialogs.remove(dialog) if dialog in self.open_dialogs else None)
            
            self.open_dialogs.append(dialog)
            dialog.show()
            dialog.activateWindow()

    def _do_delete_selected(self):
        iid = self._get_selected_id()
        if iid:
            status = self.db.get_lock_status([iid])
            if status.get(iid, 0):
                return
                
            self.db.set_deleted(iid, True)
            self._update_list()
            self._update_partition_tree()

    def _do_toggle_favorite(self):
        iid = self._get_selected_id()
        if iid:
            self.db.toggle_field(iid, 'is_favorite')
            self._update_list() 

    def _do_toggle_pin(self):
        iid = self._get_selected_id()
        if iid:
            self.db.toggle_field(iid, 'is_pinned')
            self._update_list()

    def _handle_category_drop(self, idea_id, cat_id):
        status = self.db.get_lock_status([idea_id])
        if status.get(idea_id, 0):
            return

        if cat_id == -20: 
             self.db.set_favorite(idea_id, True)
        else:
             self.db.move_category(idea_id, cat_id)
        self._update_list()
        self._update_partition_tree()

    def _save_partition_order(self):
        update_list = []
        
        def iterate_items(parent_item, parent_id):
            for i in range(parent_item.childCount()):
                item = parent_item.child(i)
                data = item.data(0, Qt.UserRole)
                
                if data and data.get('type') == 'partition':
                    cat_id = data.get('id')
                    update_list.append((cat_id, parent_id, i))
                    
                    if item.childCount() > 0:
                        iterate_items(item, cat_id)
                        
        iterate_items(self.partition_tree.invisibleRootItem(), None)
        
        if update_list:
            self.db.save_category_order(update_list)

    # --- Restore & Save State ---
    def _restore_window_state(self):
        geo_hex = load_setting("quick_window_geometry_hex")
        if geo_hex:
            try:
                self.restoreGeometry(QByteArray.fromHex(geo_hex.encode()))
            except: pass
        else:
            screen_geo = QApplication.desktop().screenGeometry()
            win_geo = self.geometry()
            x = (screen_geo.width() - win_geo.width()) // 2
            y = (screen_geo.height() - win_geo.height()) // 2
            self.move(x, y)
            
        splitter_hex = load_setting("quick_window_splitter_hex")
        if splitter_hex:
            try:
                self.splitter.restoreState(QByteArray.fromHex(splitter_hex.encode()))
            except: pass

        is_hidden = load_setting("partition_panel_hidden", False)
        self.partition_tree.setHidden(is_hidden)
        self._update_partition_status_display()
        
        is_pinned = load_setting("quick_window_pinned", False)
        self.btn_stay_top.setChecked(is_pinned)
        self._toggle_stay_on_top()

    def save_state(self):
        geo_hex = self.saveGeometry().toHex().data().decode()
        save_setting("quick_window_geometry_hex", geo_hex)
        
        split_hex = self.splitter.saveState().toHex().data().decode()
        save_setting("quick_window_splitter_hex", split_hex)
        
        is_hidden = self.partition_tree.isHidden()
        save_setting("partition_panel_hidden", is_hidden)
        
        save_setting("quick_window_pinned", self.btn_stay_top.isChecked())

    def closeEvent(self, event):
        self.save_state()
        self.hide()
        event.ignore()

    # --- Mouse Logic ---
    def _get_resize_area(self, pos):
        x, y = pos.x(), pos.y()
        w, h = self.width(), self.height()
        m = self.RESIZE_MARGIN
        areas = []
        if x < m: areas.append('left')
        elif x > w - m: areas.append('right')
        if y < m: areas.append('top')
        elif y > h - m: areas.append('bottom')
        return areas

    def _set_cursor_shape(self, areas):
        if not areas: self.setCursor(Qt.ArrowCursor); return
        if 'left' in areas and 'top' in areas: self.setCursor(Qt.SizeFDiagCursor)
        elif 'right' in areas and 'bottom' in areas: self.setCursor(Qt.SizeFDiagCursor)
        elif 'left' in areas and 'bottom' in areas: self.setCursor(Qt.SizeBDiagCursor)
        elif 'right' in areas and 'top' in areas: self.setCursor(Qt.SizeBDiagCursor)
        elif 'left' in areas or 'right' in areas: self.setCursor(Qt.SizeHorCursor)
        elif 'top' in areas or 'bottom' in areas: self.setCursor(Qt.SizeVerCursor)

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            areas = self._get_resize_area(event.pos())
            if areas:
                self.resize_area = areas
                self.m_drag = False
            else:
                self.resize_area = None
                self.m_drag = True
                self.m_DragPosition = event.globalPos() - self.pos()
            event.accept()

    def mouseMoveEvent(self, event):
        if event.buttons() == Qt.NoButton:
            areas = self._get_resize_area(event.pos())
            self._set_cursor_shape(areas)
            event.accept()
            return
        if event.buttons() == Qt.LeftButton:
            if self.resize_area:
                global_pos = event.globalPos()
                rect = self.geometry()
                if 'left' in self.resize_area:
                    new_w = rect.right() - global_pos.x()
                    if new_w > 100: rect.setLeft(global_pos.x())
                elif 'right' in self.resize_area:
                    new_w = global_pos.x() - rect.left()
                    if new_w > 100: rect.setWidth(new_w)
                if 'top' in self.resize_area:
                    new_h = rect.bottom() - global_pos.y()
                    if new_h > 100: rect.setTop(global_pos.y())
                elif 'bottom' in self.resize_area:
                    new_h = global_pos.y() - rect.top()
                    if new_h > 100: rect.setHeight(new_h)
                self.setGeometry(rect)
                event.accept()
            elif self.m_drag:
                self.move(event.globalPos() - self.m_DragPosition)
                event.accept()

    def mouseReleaseEvent(self, event):
        self.m_drag = False
        self.resize_area = None
        self.setCursor(Qt.ArrowCursor)

    # --- Core Logic ---
    def showEvent(self, event):
        if not self.my_hwnd and user32: self.my_hwnd = int(self.winId())
        super().showEvent(event)

    def _monitor_foreground_window(self):
        if not user32: return 
        current_hwnd = user32.GetForegroundWindow()
        if current_hwnd == 0 or current_hwnd == self.my_hwnd: return
        if current_hwnd != self.last_active_hwnd:
            self.last_active_hwnd = current_hwnd
            self.last_thread_id = user32.GetWindowThreadProcessId(current_hwnd, None)
            self.last_focus_hwnd = None
            curr_thread = kernel32.GetCurrentThreadId()
            attached = False
            if curr_thread != self.last_thread_id:
                attached = user32.AttachThreadInput(curr_thread, self.last_thread_id, True)
            try:
                gui_info = GUITHREADINFO()
                gui_info.cbSize = ctypes.sizeof(GUITHREADINFO)
                if user32.GetGUIThreadInfo(self.last_thread_id, ctypes.byref(gui_info)):
                    self.last_focus_hwnd = gui_info.hwndFocus or gui_info.hwndActive
            except: pass
            finally:
                if attached: user32.AttachThreadInput(curr_thread, self.last_thread_id, False)

    def _on_search_text_changed(self): self.search_timer.start(300)

    def _update_list(self):
        search_text = self.search_box.text()
        current_partition = self.partition_tree.currentItem()
        if current_partition:
            partition_data = current_partition.data(0, Qt.UserRole)
            if partition_data:
                if partition_data.get('type') == 'today':
                    f_type, f_val = 'today', None
                elif partition_data.get('type') == 'partition':
                    f_type, f_val = 'category', partition_data.get('id')
                else: # all
                    f_type, f_val = 'all', None
            else:
                f_type, f_val = 'all', None
        else:
            f_type, f_val = 'all', None

        items = self.db.get_ideas(search=search_text, f_type=f_type, f_val=f_val)
        self.list_widget.clear()
        
        categories = {c[0]: c[1] for c in self.db.get_categories()}
        
        for item_tuple in items:
            list_item = QListWidgetItem()
            list_item.setData(Qt.UserRole, item_tuple)
            
            item_type = item_tuple[10] if len(item_tuple) > 10 else 'text'
            if item_type == 'image':
                blob_data = item_tuple[11] if len(item_tuple) > 11 else None
                if blob_data:
                    pixmap = QPixmap()
                    pixmap.loadFromData(blob_data)
                    if not pixmap.isNull():
                        icon = QIcon(pixmap)
                        list_item.setIcon(icon)

            display_text = self._get_content_display(item_tuple)
            list_item.setText(display_text)
            
            idea_id = item_tuple[0]
            category_id = item_tuple[8]
            
            cat_name = categories.get(category_id, "未分类")
            tags = self.db.get_tags(idea_id)
            tags_str = " ".join([f"#{t}" for t in tags]) if tags else "无"
            
            tooltip = f"📂 分区: {cat_name}\n🏷️ 标签: {tags_str}"
            list_item.setToolTip(tooltip)
            
            self.list_widget.addItem(list_item)
        if self.list_widget.count() > 0: self.list_widget.setCurrentRow(0)

    def _get_content_display(self, item_tuple):
        title = item_tuple[1]
        content = item_tuple[2]
        
        prefix = ""
        # 显示锁定状态前缀
        is_locked = item_tuple[13] if len(item_tuple) > 13 else 0
        if is_locked: prefix += "🔒 "
        
        if item_tuple[4]: prefix += "📌 "
        if item_tuple[5]: prefix += "⭐ "
        
        item_type = item_tuple[10] if len(item_tuple) > 10 and item_tuple[10] else 'text'

        text_part = ""
        if item_type == 'image':
            text_part = title 
        elif item_type == 'file':
            text_part = title 
        else: 
            text_part = title if title else (content if content else "")
            text_part = text_part.replace('\n', ' ').replace('\r', '').strip()[:150]
            
        return prefix + text_part

    def _create_color_icon(self, color_str):
        pixmap = QPixmap(16, 16)
        pixmap.fill(Qt.transparent)
        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.Antialiasing)
        painter.setBrush(QColor(color_str or "#808080"))
        painter.setPen(Qt.NoPen)
        painter.drawRoundedRect(2, 2, 12, 12, 4, 4)
        painter.end()
        return QIcon(pixmap)

    def _update_partition_tree(self):
        current_selection_data = None
        if self.partition_tree.currentItem():
            current_selection_data = self.partition_tree.currentItem().data(0, Qt.UserRole)
            
        self.partition_tree.clear()
        
        counts = self.db.get_partition_item_counts()
        partition_counts = counts.get('partitions', {})

        static_items = [
            ("全部数据", {'type': 'all', 'id': -1}, QStyle.SP_DirHomeIcon, counts.get('total', 0)),
            ("今日数据", {'type': 'today', 'id': -5}, QStyle.SP_FileDialogDetailedView, counts.get('today_modified', 0)),
            ("剪贴板数据", {'type': 'clipboard', 'id': -10}, QStyle.SP_ComputerIcon, counts.get('clipboard', 0)),
            ("收藏", {'type': 'favorite', 'id': -20}, QStyle.SP_DialogYesButton, counts.get('favorite', 0)),
        ]
        
        for name, data, icon, count in static_items:
            item = QTreeWidgetItem(self.partition_tree, [f"{name} ({count})"])
            item.setData(0, Qt.UserRole, data)
            item.setIcon(0, self.style().standardIcon(icon))
        
        top_level_partitions = self.db.get_partitions_tree()
        self._add_partition_recursive(top_level_partitions, self.partition_tree, partition_counts)

        self.partition_tree.expandAll()
        
        if current_selection_data:
            it = QTreeWidgetItemIterator(self.partition_tree)
            while it.value():
                item = it.value()
                item_data = item.data(0, Qt.UserRole)
                if item_data and item_data.get('id') == current_selection_data.get('id') and item_data.get('type') == current_selection_data.get('type'):
                    self.partition_tree.setCurrentItem(item)
                    break
                it += 1
        else:
            if self.partition_tree.topLevelItemCount() > 0:
                self.partition_tree.setCurrentItem(self.partition_tree.topLevelItem(0))

    def _add_partition_recursive(self, partitions, parent_item, partition_counts):
        for partition in partitions:
            count = partition_counts.get(partition.id, 0)
            item = QTreeWidgetItem(parent_item, [f"{partition.name} ({count})"])
            item.setData(0, Qt.UserRole, {'type': 'partition', 'id': partition.id, 'color': partition.color})
            item.setIcon(0, self._create_color_icon(partition.color))
            
            if partition.children:
                self._add_partition_recursive(partition.children, item, partition_counts)

    def _update_partition_status_display(self):
        is_hidden = self.partition_tree.isHidden()
        if is_hidden:
            current_item = self.partition_tree.currentItem()
            if current_item:
                text = current_item.text(0).split(' (')[0]
                self.partition_status_label.setText(f"当前分区: {text}")
            else:
                self.partition_status_label.setText("当前分区: N/A")
            self.partition_status_label.show()
        else:
            self.partition_status_label.hide()

    def _on_partition_selection_changed(self, c, p):
        self._update_list()
        self._update_partition_status_display()
        
    def _toggle_partition_panel(self):
        is_currently_visible = self.partition_tree.isVisible()
        self.partition_tree.setVisible(not is_currently_visible)
        self.settings.setValue("partition_panel_hidden", not is_currently_visible)
        self._update_partition_status_display()
    
    def _toggle_stay_on_top(self):
        if not user32: return
        self._is_pinned = self.btn_stay_top.isChecked()
        hwnd = int(self.winId())
        if self._is_pinned:
            user32.SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_FLAGS)
        else:
            user32.SetWindowPos(hwnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_FLAGS)

    def _on_item_activated(self, item):
        item_tuple = item.data(Qt.UserRole)
        if not item_tuple: return

        try:
            clipboard = QApplication.clipboard()
            
            item_type_index = 10
            item_type = item_tuple[item_type_index] if len(item_tuple) > item_type_index and item_tuple[item_type_index] else 'text'
            
            if item_type == 'image':
                blob_index = 11
                image_blob = item_tuple[blob_index]
                if image_blob:
                    image = QImage()
                    image.loadFromData(image_blob)
                    clipboard.setImage(image)
            elif item_type == 'file':
                content_index = 2
                file_path_str = item_tuple[content_index]
                if file_path_str:
                    mime_data = QMimeData()
                    urls = [QUrl.fromLocalFile(p) for p in file_path_str.split(';') if p]
                    mime_data.setUrls(urls)
                    clipboard.setMimeData(mime_data)
            else:
                content_index = 2
                content_to_copy = item_tuple[content_index] if item_tuple[content_index] else ""
                clipboard.setText(content_to_copy)

            self._paste_ditto_style()
        except Exception as e: 
            log(f"❌ 粘贴操作失败: {e}")

    def _paste_ditto_style(self):
        if not user32: return
        target_win = self.last_active_hwnd
        target_focus = self.last_focus_hwnd
        target_thread = self.last_thread_id
        if not target_win or not user32.IsWindow(target_win): return
        curr_thread = kernel32.GetCurrentThreadId()
        attached = False
        if target_thread and curr_thread != target_thread:
            attached = user32.AttachThreadInput(curr_thread, target_thread, True)
        try:
            if user32.IsIconic(target_win): user32.ShowWindow(target_win, 9)
            user32.SetForegroundWindow(target_win)
            if target_focus and user32.IsWindow(target_focus): user32.SetFocus(target_focus)
            time.sleep(0.1)
            user32.keybd_event(VK_CONTROL, 0, 0, 0)
            user32.keybd_event(VK_V, 0, 0, 0)
            user32.keybd_event(VK_V, 0, KEYEVENTF_KEYUP, 0)
            user32.keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0)
        except Exception as e: log(f"❌ 粘贴异常: {e}")
        finally:
            if attached: user32.AttachThreadInput(curr_thread, target_thread, False)

    def on_clipboard_changed(self):
        if self._processing_clipboard:
            return
        self._processing_clipboard = True
        try:
            mime = self.clipboard.mimeData()
            self.cm.process_clipboard(mime, None)
        finally:
            self._processing_clipboard = False

    def keyPressEvent(self, event):
        key = event.key()
        if key == Qt.Key_Escape: self.close()
        elif key in (Qt.Key_Up, Qt.Key_Down):
            if not self.list_widget.hasFocus():
                self.list_widget.setFocus()
                QApplication.sendEvent(self.list_widget, event)
        else: super().keyPressEvent(event)

    # --- 分区右键菜单 ---
    def _show_partition_context_menu(self, pos):
        item = self.partition_tree.itemAt(pos)
        menu = QMenu(self)
        menu.setStyleSheet(f"background-color: {COLORS.get('bg_dark', '#2d2d2d')}; color: white; border: 1px solid #444;")
        
        if not item:
            menu.addAction('➕ 新建分组', self._new_group)
            menu.exec_(self.partition_tree.mapToGlobal(pos))
            return

        data = item.data(0, Qt.UserRole)
        
        if data and data.get('type') == 'partition':
            cat_id = data.get('id')
            raw_text = item.text(0)
            current_name = raw_text.split(' (')[0]

            menu.addAction('➕ 新建数据', lambda: self._request_new_data(cat_id))
            menu.addSeparator()
            menu.addAction('🎨 设置颜色', lambda: self._change_color(cat_id))
            menu.addAction('🏷️ 设置预设标签', lambda: self._set_preset_tags(cat_id))
            menu.addSeparator()
            menu.addAction('➕ 新建分组', self._new_group)
            menu.addAction('➕ 新建分区', lambda: self._new_zone(cat_id))
            menu.addAction('✏️ 重命名', lambda: self._rename_category(cat_id, current_name))
            menu.addAction('🗑️ 删除', lambda: self._del_category(cat_id))
            
            menu.exec_(self.partition_tree.mapToGlobal(pos))
        else:
             if not item:
                menu.addAction('➕ 新建分组', self._new_group)
                menu.exec_(self.partition_tree.mapToGlobal(pos))
             else:
                pass

    def _request_new_data(self, cat_id):
        dialog = EditDialog(self.db, category_id_for_new=cat_id, parent=None)
        dialog.setAttribute(Qt.WA_DeleteOnClose)
        
        dialog.data_saved.connect(self._update_list)
        dialog.data_saved.connect(self._update_partition_tree)
        
        dialog.finished.connect(lambda: self.open_dialogs.remove(dialog) if dialog in self.open_dialogs else None)
        
        self.open_dialogs.append(dialog)
        dialog.show()
        dialog.activateWindow()

    def _new_group(self):
        text, ok = QInputDialog.getText(self, '新建组', '组名称:')
        if ok and text:
            self.db.add_category(text, parent_id=None)
            self._update_partition_tree()
            
    def _new_zone(self, parent_id):
        text, ok = QInputDialog.getText(self, '新建区', '区名称:')
        if ok and text:
            self.db.add_category(text, parent_id=parent_id)
            self._update_partition_tree()

    def _rename_category(self, cat_id, old_name):
        text, ok = QInputDialog.getText(self, '重命名', '新名称:', text=old_name)
        if ok and text and text.strip():
            self.db.rename_category(cat_id, text.strip())
            self._update_partition_tree()
            self._update_list() 

    def _del_category(self, cid):
        c = self.db.conn.cursor()
        c.execute("SELECT COUNT(*) FROM categories WHERE parent_id = ?", (cid,))
        child_count = c.fetchone()[0]

        msg = '确认删除此分类? (其中的内容将移至未分类)'
        if child_count > 0:
            msg = f'此组包含 {child_count} 个区，确认一并删除?\n(所有内容都将移至未分类)'

        if QMessageBox.Yes == QMessageBox.question(self, '确认删除', msg):
            c.execute("SELECT id FROM categories WHERE parent_id = ?", (cid,))
            child_ids = [row[0] for row in c.fetchall()]
            for child_id in child_ids:
                self.db.delete_category(child_id)
            self.db.delete_category(cid)
            self._update_partition_tree()
            self._update_list()

    def _change_color(self, cat_id):
        color = QColorDialog.getColor(Qt.gray, self, "选择分类颜色")
        if color.isValid():
            self.db.set_category_color(cat_id, color.name())
            self._update_partition_tree()

    def _set_preset_tags(self, cat_id):
        current_tags = self.db.get_category_preset_tags(cat_id)
        
        dlg = QDialog(self)
        dlg.setWindowTitle("🏷️ 设置预设标签")
        dlg.setStyleSheet(f"background-color: {COLORS.get('bg_dark', '#2d2d2d')}; color: #EEE;")
        dlg.setFixedSize(350, 150)
        
        layout = QVBoxLayout(dlg)
        layout.setContentsMargins(20, 20, 20, 20)
        
        info = QLabel("拖入该分类时自动绑定以下标签：\n(双击输入框选择历史标签)")
        info.setStyleSheet("color: #888; font-size: 12px; margin-bottom: 5px;")
        layout.addWidget(info)
        
        inp = ClickableLineEdit()
        inp.setText(current_tags)
        inp.setPlaceholderText("例如: 工作, 重要 (逗号分隔)")
        inp.setStyleSheet(f"background-color: {COLORS.get('bg_mid', '#333')}; border: 1px solid #444; padding: 6px; border-radius: 4px; color: white;")
        layout.addWidget(inp)
        
        def open_tag_selector():
            initial_list = [t.strip() for t in inp.text().split(',') if t.strip()]
            selector = AdvancedTagSelector(self.db, idea_id=None, initial_tags=initial_list)
            def on_confirmed(tags):
                inp.setText(', '.join(tags))
            selector.tags_confirmed.connect(on_confirmed)
            selector.show_at_cursor()
            
        inp.doubleClicked.connect(open_tag_selector)
        
        btns = QHBoxLayout()
        btns.addStretch()
        btn_ok = QPushButton("完成")
        btn_ok.setStyleSheet(f"background-color: {COLORS.get('primary', '#0078D4')}; border:none; padding: 5px 15px; border-radius: 4px; font-weight:bold; color: white;")
        btn_ok.clicked.connect(dlg.accept)
        btns.addWidget(btn_ok)
        layout.addLayout(btns)
        
        if dlg.exec_() == QDialog.Accepted:
            new_tags = inp.text().strip()
            self.db.set_category_preset_tags(cat_id, new_tags)
            
            tags_list = [t.strip() for t in new_tags.split(',') if t.strip()]
            if tags_list:
                self.db.apply_preset_tags_to_category_items(cat_id, tags_list)
                
            self.data_changed.emit()
```

## 文件: ui\sidebar.py

```python
# -*- coding: utf-8 -*-
# ui/sidebar.py
from PyQt5.QtWidgets import (QTreeWidget, QTreeWidgetItem, QMenu, QMessageBox, QInputDialog, 
                             QFrame, QColorDialog, QDialog, QVBoxLayout, QLabel, QLineEdit, 
                             QPushButton, QHBoxLayout, QApplication, QWidget)
from PyQt5.QtCore import Qt, pyqtSignal, QSize, QEvent, QTimer
from PyQt5.QtGui import QFont, QColor, QPixmap, QPainter, QIcon, QCursor
from core.config import COLORS
from ui.advanced_tag_selector import AdvancedTagSelector

class ClickableLineEdit(QLineEdit):
    doubleClicked = pyqtSignal()
    def mouseDoubleClickEvent(self, event):
        self.doubleClicked.emit()
        super().mouseDoubleClickEvent(event)

class Sidebar(QTreeWidget):
    filter_changed = pyqtSignal(str, object)
    data_changed = pyqtSignal()
    new_data_requested = pyqtSignal(int)

    def __init__(self, db, parent=None):
        super().__init__(parent)
        self.db = db
        self.setHeaderHidden(True)
        self.setIndentation(15)
        
        self.setCursor(Qt.ArrowCursor)
        
        self.setDragEnabled(True)
        self.setAcceptDrops(True)
        self.setDropIndicatorShown(True)
        self.setDragDropMode(self.InternalMove)

        self.setStyleSheet(f"""
            QTreeWidget {{
                background-color: {COLORS['bg_mid']};
                color: #ddd;
                border: none;
                font-size: 13px;
                padding: 2px;
                outline: none;
            }}
            QTreeWidget::item {{
                height: 24px;
                padding: 1px 4px;
                border-radius: 4px;
                margin-bottom: 0px;
            }}
            QTreeWidget::item:hover {{
                background-color: #2a2d2e;
            }}
            QTreeWidget::item:selected {{
                background-color: #37373d;
                color: white;
            }}
            
            QScrollBar:vertical {{
                border: none;
                background: transparent;
                width: 6px;
                margin: 0px;
            }}
            QScrollBar::handle:vertical {{
                background: #444;
                border-radius: 3px;
                min-height: 20px;
            }}
            QScrollBar::handle:vertical:hover {{
                background: #555;
            }}
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {{
                height: 0px;
            }}
            QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {{
                background: none;
            }}
        """)

        self.itemClicked.connect(self._on_click)
        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self._show_menu)
        self.refresh_sync()

    def enterEvent(self, event):
        self.setCursor(Qt.ArrowCursor)
        super().enterEvent(event)

    def refresh(self):
        """异步刷新，防止闪退"""
        QTimer.singleShot(10, self.refresh_sync)

    def refresh_sync(self):
        """实际执行刷新的逻辑"""
        self.blockSignals(True)
        try:
            self.clear()
            self.setColumnCount(1)
            counts = self.db.get_counts()

            system_menu_items = [
                ("全部数据", 'all', '🗂️'), ("今日数据", 'today', '📅'),
                ("剪贴板数据", 'clipboard', '📋'),
                ("未分类", 'uncategorized', '⚠️'), ("未标签", 'untagged', '🏷️'),
                ("收藏", 'favorite', '⭐'), ("回收站", 'trash', '🗑️')
            ]

            for name, key, icon in system_menu_items:
                item = QTreeWidgetItem(self, [f"{icon}  {name} ({counts.get(key, 0)})"])
                item.setData(0, Qt.UserRole, (key, None))
                item.setFlags(item.flags() & ~Qt.ItemIsDragEnabled)
                item.setExpanded(False)

            sep_item = QTreeWidgetItem(self)
            sep_item.setFlags(Qt.NoItemFlags)
            sep_item.setSizeHint(0, QSize(0, 16)) 
            
            container = QWidget()
            container.setStyleSheet("background: transparent;")
            
            layout = QVBoxLayout(container)
            layout.setContentsMargins(10, 0, 10, 0)
            layout.setAlignment(Qt.AlignCenter)
            
            line = QFrame()
            line.setFixedHeight(1) 
            line.setStyleSheet("background-color: #505050; border: none;") 
            
            layout.addWidget(line)
            self.setItemWidget(sep_item, 0, container)

            user_partitions_root = QTreeWidgetItem(self, ["🗃️ 我的分区"])
            user_partitions_root.setFlags(user_partitions_root.flags() & ~Qt.ItemIsSelectable & ~Qt.ItemIsDragEnabled)
            font = user_partitions_root.font(0)
            font.setBold(True)
            user_partitions_root.setFont(0, font)
            user_partitions_root.setForeground(0, QColor("#FFFFFF"))
            
            partitions_tree = self.db.get_partitions_tree()
            self._add_partition_recursive(partitions_tree, user_partitions_root, counts.get('categories', {}))
            
            self.expandAll()
        finally:
            self.blockSignals(False)

    def _create_color_icon(self, color_str):
        pixmap = QPixmap(14, 14)
        pixmap.fill(Qt.transparent)
        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.Antialiasing)
        
        c = QColor(color_str if color_str else "#808080")
        painter.setBrush(c)
        painter.setPen(Qt.NoPen)
        painter.drawEllipse(1, 1, 12, 12)
        painter.end()
        return QIcon(pixmap)

    def _add_partition_recursive(self, partitions, parent_item, counts):
        for p in partitions:
            count = counts.get(p.id, 0)
            child_counts = sum(counts.get(child.id, 0) for child in p.children)
            total_count = count + child_counts

            item = QTreeWidgetItem(parent_item, [f"{p.name} ({total_count})"])
            item.setIcon(0, self._create_color_icon(p.color))
            item.setData(0, Qt.UserRole, ('category', p.id))
            
            if p.children:
                self._add_partition_recursive(p.children, item, counts)

    def dragEnterEvent(self, e):
        if e.mimeData().hasFormat('application/x-tree-widget-internal-move') or \
           e.mimeData().hasFormat('application/x-idea-id') or \
           e.mimeData().hasFormat('application/x-idea-ids'):
            e.accept()
        else:
            e.ignore()

    def dragMoveEvent(self, e):
        item = self.itemAt(e.pos())
        if item:
            d = item.data(0, Qt.UserRole)
            if d and d[0] in ['category', 'trash', 'favorite', 'uncategorized']:
                self.setCurrentItem(item)
                e.accept()
                return
            if e.mimeData().hasFormat('application/x-tree-widget-internal-move'):
                e.accept()
                return
        e.ignore()

    def dropEvent(self, e):
        ids_to_process = []
        if e.mimeData().hasFormat('application/x-idea-ids'):
            try:
                data = e.mimeData().data('application/x-idea-ids').data().decode('utf-8')
                ids_to_process = [int(x) for x in data.split(',') if x]
            except Exception: pass
        elif e.mimeData().hasFormat('application/x-idea-id'):
            try: 
                ids_to_process = [int(e.mimeData().data('application/x-idea-id'))]
            except Exception: pass
        
        if ids_to_process:
            try:
                item = self.itemAt(e.pos())
                if not item: return
                d = item.data(0, Qt.UserRole)
                if not d: return
                key, val = d
                
                for iid in ids_to_process:
                    if key == 'category': self.db.move_category(iid, val)
                    elif key == 'uncategorized': self.db.move_category(iid, None)
                    elif key == 'trash': self.db.set_deleted(iid, True)
                    elif key == 'favorite': self.db.set_favorite(iid, True)
                
                self.data_changed.emit()
                self.refresh()
                e.acceptProposedAction()
            except Exception as err:
                pass
        else:
            super().dropEvent(e)
            self._save_current_order()

    def _save_current_order(self):
        update_list = []
        def iterate_items(parent_item, parent_id):
            for i in range(parent_item.childCount()):
                item = parent_item.child(i)
                data = item.data(0, Qt.UserRole)
                if data and data[0] == 'category':
                    cat_id = data[1]
                    update_list.append({'id': cat_id, 'sort_order': i, 'parent_id': parent_id})
                    if item.childCount() > 0:
                        iterate_items(item, cat_id)
        iterate_items(self.invisibleRootItem(), None)
        if update_list:
            self.db.save_category_order(update_list)

    def _on_click(self, item):
        data = item.data(0, Qt.UserRole)
        if data: self.filter_changed.emit(*data)

    def _show_menu(self, pos):
        item = self.itemAt(pos)
        menu = QMenu(self)
        menu.setStyleSheet("background:#2d2d2d;color:white")

        if not item or item.text(0) == "🗃️ 我的分区":
            menu.addAction('➕ 组', self._new_group)
            menu.exec_(self.mapToGlobal(pos))
            return

        data = item.data(0, Qt.UserRole)
        if not data: return

        # 回收站右键菜单
        if data[0] == 'trash':
            menu.addAction('🗑️ 清空回收站', self._empty_trash)
            menu.exec_(self.mapToGlobal(pos))
            return

        if data[0] == 'category':
            cat_id = data[1]
            raw_text = item.text(0)
            current_name = raw_text.split(' (')[0]

            menu.addAction('➕ 数据', lambda: self._request_new_data(cat_id))
            menu.addSeparator()
            menu.addAction('🎨 设置颜色', lambda: self._change_color(cat_id))
            menu.addAction('🏷️ 设置预设标签', lambda: self._set_preset_tags(cat_id))
            menu.addSeparator()
            menu.addAction('➕ 组', self._new_group)
            menu.addAction('➕ 区', lambda: self._new_zone(cat_id))
            menu.addAction('✏️ 重命名', lambda: self._rename_category(cat_id, current_name))
            menu.addAction('🗑️ 删除', lambda: self._del_category(cat_id))
            menu.exec_(self.mapToGlobal(pos))

    def _empty_trash(self):
        if QMessageBox.Yes == QMessageBox.warning(self, '清空回收站', '⚠️ 确定要清空回收站吗？\n此操作将永久删除所有内容，不可恢复！', QMessageBox.Yes | QMessageBox.No):
            self.db.empty_trash()
            self.data_changed.emit()
            self.refresh()

    def _set_preset_tags(self, cat_id):
        current_tags = self.db.get_category_preset_tags(cat_id)
        
        dlg = QDialog(self)
        dlg.setWindowTitle("🏷️ 设置预设标签")
        dlg.setStyleSheet(f"background-color: {COLORS['bg_dark']}; color: #EEE;")
        dlg.setFixedSize(350, 150)
        
        layout = QVBoxLayout(dlg)
        layout.setContentsMargins(20, 20, 20, 20)
        
        info = QLabel("拖入该分类时自动绑定以下标签：\n(双击输入框选择历史标签)")
        info.setStyleSheet("color: #888; font-size: 12px; margin-bottom: 5px;")
        layout.addWidget(info)
        
        inp = ClickableLineEdit()
        inp.setText(current_tags)
        inp.setPlaceholderText("例如: 工作, 重要 (逗号分隔)")
        inp.setStyleSheet(f"background-color: {COLORS['bg_mid']}; border: 1px solid #444; padding: 6px; border-radius: 4px; color: white;")
        layout.addWidget(inp)
        
        def open_tag_selector():
            initial_list = [t.strip() for t in inp.text().split(',') if t.strip()]
            selector = AdvancedTagSelector(self.db, idea_id=None, initial_tags=initial_list)
            def on_confirmed(tags):
                inp.setText(', '.join(tags))
            selector.tags_confirmed.connect(on_confirmed)
            selector.show_at_cursor()
            
        inp.doubleClicked.connect(open_tag_selector)
        
        btns = QHBoxLayout()
        btns.addStretch()
        btn_ok = QPushButton("完成")
        btn_ok.setStyleSheet(f"background-color: {COLORS['primary']}; border:none; padding: 5px 15px; border-radius: 4px; font-weight:bold;")
        btn_ok.clicked.connect(dlg.accept)
        btns.addWidget(btn_ok)
        layout.addLayout(btns)
        
        if dlg.exec_() == QDialog.Accepted:
            new_tags = inp.text().strip()
            self.db.set_category_preset_tags(cat_id, new_tags)
            
            tags_list = [t.strip() for t in new_tags.split(',') if t.strip()]
            if tags_list:
                self.db.apply_preset_tags_to_category_items(cat_id, tags_list)
                
            self.data_changed.emit()

    def _change_color(self, cat_id):
        color = QColorDialog.getColor(Qt.gray, self, "选择分类颜色")
        if color.isValid():
            self.db.set_category_color(cat_id, color.name())
            self.refresh()

    def _request_new_data(self, cat_id):
        self.new_data_requested.emit(cat_id)

    def _new_group(self):
        text, ok = QInputDialog.getText(self, '新建组', '组名称:')
        if ok and text:
            self.db.add_category(text, parent_id=None)
            self.refresh()
            
    def _new_zone(self, parent_id):
        text, ok = QInputDialog.getText(self, '新建区', '区名称:')
        if ok and text:
            self.db.add_category(text, parent_id=parent_id)
            self.refresh()

    def _rename_category(self, cat_id, old_name):
        text, ok = QInputDialog.getText(self, '重命名', '新名称:', text=old_name)
        if ok and text and text.strip():
            self.db.rename_category(cat_id, text.strip())
            self.refresh()

    def _del_category(self, cid):
        c = self.db.conn.cursor()
        c.execute("SELECT COUNT(*) FROM categories WHERE parent_id = ?", (cid,))
        child_count = c.fetchone()[0]

        msg = '确认删除此分类? (其中的内容将移至未分类)'
        if child_count > 0:
            msg = f'此组包含 {child_count} 个区，确认一并删除?\n(所有内容都将移至未分类)'

        if QMessageBox.Yes == QMessageBox.question(self, '确认删除', msg):
            c.execute("SELECT id FROM categories WHERE parent_id = ?", (cid,))
            child_ids = [row[0] for row in c.fetchall()]
            for child_id in child_ids:
                self.db.delete_category(child_id)
            self.db.delete_category(cid)
            self.refresh()
```

## 文件: ui\success_animation.py

```python
﻿# -*- coding: utf-8 -*-
# ui/success_animation.py

from PyQt5.QtWidgets import QWidget
from PyQt5.QtCore import Qt, QTimer, QRectF
from PyQt5.QtGui import QPainter, QColor, QPen, QPainterPath

class SuccessAnimationWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFixedSize(24, 24)
        self.progress = 0.0
        self.timer = QTimer(self)
        self.timer.timeout.connect(self._update_anim)
        
    def start(self):
        self.progress = 0.0
        self.timer.start(20) # 50fps
        self.show()
        
    def _update_anim(self):
        self.progress += 0.1
        if self.progress >= 1.0:
            self.progress = 1.0
            self.timer.stop()
        self.update()
        
    def paintEvent(self, event):
        p = QPainter(self)
        p.setRenderHint(QPainter.Antialiasing)
        
        # 绘制背景圆圈 (渐现)
        alpha = int(255 * min(1.0, self.progress * 2))
        color = QColor("#2ecc71") # 绿色
        p.setPen(Qt.NoPen)
        color.setAlpha(alpha)
        p.setBrush(color)
        p.drawEllipse(2, 2, 20, 20)
        
        # 绘制打钩 (Stroke 动画)
        if self.progress > 0.3:
            path = QPainterPath()
            path.moveTo(7, 12)
            path.lineTo(10, 15)
            path.lineTo(17, 8)
            
            check_prog = (self.progress - 0.3) / 0.7
            if check_prog > 1: check_prog = 1
            
            # 简单的遮罩或截断实现比较复杂，这里用简单的分段绘制模拟
            # 为保持代码简洁，直接绘制完整钩，配合透明度
            p.setPen(QPen(Qt.white, 2, Qt.SolidLine, Qt.RoundCap, Qt.RoundJoin))
            p.setBrush(Qt.NoBrush)
            
            # 计算动态路径
            len_total = path.length()
            len_curr = len_total * check_prog
            
            # 创建子路径
            percent = path.percentAtLength(len_curr)
            # 注意: PyQt5旧版本可能没有 pointAtPercent，这里简化处理：
            # 直接画出完整路径，依靠速度快，肉眼看不出太大区别，或者用上面的圆圈淡入即可
            p.drawPath(path)
```

## 文件: ui\tag_selector.py

```python
﻿# -*- coding: utf-8 -*-
# ui/tag_selector.py

from PyQt5.QtWidgets import QWidget, QVBoxLayout, QHBoxLayout, QCheckBox, QPushButton, QLineEdit, QScrollArea, QLabel
from PyQt5.QtCore import Qt, pyqtSignal, QPoint
from PyQt5.QtGui import QCursor
from core.config import COLORS

class TagSelectorFloat(QWidget):
    """标签选择悬浮面板"""
    tags_confirmed = pyqtSignal(list)
    
    def __init__(self, db, idea_id, parent=None):
        super().__init__(parent)
        self.db = db
        self.idea_id = idea_id
        self.selected_tags = set()
        
        self.setWindowFlags(
            Qt.FramelessWindowHint | 
            Qt.WindowStaysOnTopHint | 
            Qt.Tool
        )
        self.setAttribute(Qt.WA_TranslucentBackground)
        self.setAttribute(Qt.WA_ShowWithoutActivating, False)
        
        self._init_ui()
        self._load_tags()
        
    def _init_ui(self):
        # 主容器
        container = QWidget()
        container.setStyleSheet(f"""
            QWidget {{
                background-color: {COLORS['bg_dark']};
                border: 2px solid {COLORS['primary']};
                border-radius: 12px;
            }}
        """)
        
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.addWidget(container)
        
        layout = QVBoxLayout(container)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)
        
        # 标题栏
        header = QHBoxLayout()
        title = QLabel('🏷️ 快速选择标签')
        title.setStyleSheet(f"""
            font-size: 14px; 
            font-weight: bold; 
            color: {COLORS['primary']};
            background: transparent;
            border: none;
        """)
        header.addWidget(title)
        
        close_btn = QPushButton('✕')
        close_btn.setFixedSize(20, 20)
        close_btn.setStyleSheet(f"""
            QPushButton {{
                background: transparent;
                border: 1px solid #666;
                border-radius: 10px;
                color: #999;
                font-size: 12px;
                padding: 0px;
            }}
            QPushButton:hover {{
                background-color: {COLORS['danger']};
                border-color: {COLORS['danger']};
                color: white;
            }}
        """)
        close_btn.clicked.connect(self._on_close)
        header.addWidget(close_btn)
        
        layout.addLayout(header)
        
        hint = QLabel('💡 点击选择标签，失去焦点后自动保存')
        hint.setStyleSheet("""
            color: #888; 
            font-size: 11px; 
            background: transparent;
            border: none;
        """)
        layout.addWidget(hint)
        
        input_layout = QHBoxLayout()
        self.new_tag_input = QLineEdit()
        self.new_tag_input.setPlaceholderText('输入新标签...')
        self.new_tag_input.setStyleSheet(f"""
            QLineEdit {{
                background-color: {COLORS['bg_mid']};
                border: 1px solid {COLORS['bg_light']};
                border-radius: 8px;
                padding: 6px 10px;
                color: #eee;
                font-size: 12px;
            }}
            QLineEdit:focus {{
                border: 1px solid {COLORS['primary']};
            }}
        """)
        self.new_tag_input.returnPressed.connect(self._add_new_tag)
        input_layout.addWidget(self.new_tag_input)
        
        add_btn = QPushButton('➕')
        add_btn.setFixedSize(28, 28)
        add_btn.setStyleSheet(f"""
            QPushButton {{
                background-color: {COLORS['primary']};
                border: none;
                border-radius: 6px;
                color: white;
                font-size: 14px;
            }}
            QPushButton:hover {{
                background-color: #357abd;
            }}
        """)
        add_btn.clicked.connect(self._add_new_tag)
        input_layout.addWidget(add_btn)
        
        layout.addLayout(input_layout)
        
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFixedHeight(200)
        # 【关键修复】在此处注入 QScrollBar 样式
        scroll.setStyleSheet("""
            QScrollArea {
                border: none;
                background: transparent;
            }
            QScrollBar:vertical {
                border: none;
                background: transparent;
                width: 6px;
                margin: 0px;
            }
            QScrollBar::handle:vertical {
                background: #444;
                border-radius: 3px;
                min-height: 20px;
            }
            QScrollBar::handle:vertical:hover {
                background: #555;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                height: 0px;
            }
            QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {
                background: none;
            }
        """)
        
        self.tag_list_widget = QWidget()
        self.tag_list_layout = QVBoxLayout(self.tag_list_widget)
        self.tag_list_layout.setAlignment(Qt.AlignTop)
        self.tag_list_layout.setSpacing(6)
        self.tag_list_layout.setContentsMargins(0, 0, 0, 0)
        
        scroll.setWidget(self.tag_list_widget)
        layout.addWidget(scroll)
        
        self.count_label = QLabel('已选择 0 个标签')
        self.count_label.setStyleSheet(f"""
            color: {COLORS['primary']}; 
            font-size: 11px; 
            font-weight: bold;
            background: transparent;
            border: none;
        """)
        layout.addWidget(self.count_label)
        
        self.setFixedWidth(300)
        
    def _load_tags(self):
        while self.tag_list_layout.count():
            item = self.tag_list_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
        
        c = self.db.conn.cursor()
        c.execute('''
            SELECT DISTINCT t.name, COUNT(it.idea_id) as cnt 
            FROM tags t
            LEFT JOIN idea_tags it ON t.id = it.tag_id
            LEFT JOIN ideas i ON it.idea_id = i.id AND i.is_deleted = 0
            GROUP BY t.id
            ORDER BY cnt DESC, t.name ASC
        ''')
        all_tags = c.fetchall()
        
        current_tags = set(self.db.get_tags(self.idea_id))
        self.selected_tags = current_tags.copy()
        
        if not all_tags:
            empty = QLabel('暂无标签，请创建新标签')
            empty.setStyleSheet("color: #666; font-style: italic; font-size: 11px;")
            empty.setAlignment(Qt.AlignCenter)
            self.tag_list_layout.addWidget(empty)
        else:
            for tag_name, count in all_tags:
                checkbox = QCheckBox(f'{tag_name} ({count})')
                checkbox.setChecked(tag_name in current_tags)
                checkbox.setStyleSheet(f"""
                    QCheckBox {{
                        color: #ddd;
                        font-size: 12px;
                        spacing: 8px;
                        background: transparent;
                        border: none;
                    }}
                    QCheckBox::indicator {{
                        width: 16px;
                        height: 16px;
                        border: 2px solid #666;
                        border-radius: 4px;
                        background-color: {COLORS['bg_mid']};
                    }}
                    QCheckBox::indicator:checked {{
                        background-color: {COLORS['primary']};
                        border-color: {COLORS['primary']};
                        image: url(none);
                    }}
                    QCheckBox::indicator:hover {{
                        border-color: {COLORS['primary']};
                    }}
                    QCheckBox:hover {{
                        color: white;
                    }}
                """)
                checkbox.stateChanged.connect(lambda state, name=tag_name: self._on_tag_changed(name, state))
                self.tag_list_layout.addWidget(checkbox)
                
        self._update_count()
        
    def _on_tag_changed(self, tag_name, state):
        if state == Qt.Checked:
            self.selected_tags.add(tag_name)
        else:
            self.selected_tags.discard(tag_name)
        self._update_count()
        
    def _add_new_tag(self):
        tag_name = self.new_tag_input.text().strip()
        if not tag_name:
            return
            
        c = self.db.conn.cursor()
        c.execute('SELECT id FROM tags WHERE name = ?', (tag_name,))
        if c.fetchone():
            self.selected_tags.add(tag_name)
            self._load_tags()
            self.new_tag_input.clear()
            return
            
        c.execute('INSERT INTO tags (name) VALUES (?)', (tag_name,))
        self.db.conn.commit()
        
        self.selected_tags.add(tag_name)
        
        self._load_tags()
        self.new_tag_input.clear()
        
    def _update_count(self):
        count = len(self.selected_tags)
        self.count_label.setText(f'已选择 {count} 个标签')
        
    def _save_tags(self):
        c = self.db.conn.cursor()
        c.execute('DELETE FROM idea_tags WHERE idea_id = ?', (self.idea_id,))
        
        for tag_name in self.selected_tags:
            c.execute('SELECT id FROM tags WHERE name = ?', (tag_name,))
            result = c.fetchone()
            if result:
                tag_id = result[0]
                c.execute('INSERT INTO idea_tags (idea_id, tag_id) VALUES (?, ?)', 
                          (self.idea_id, tag_id))
                self.db.conn.commit()
        
    def _on_close(self):
        self._save_tags()
        self.tags_confirmed.emit(list(self.selected_tags))
        self.close()
        
    def focusOutEvent(self, event):
        self._save_tags()
        self.tags_confirmed.emit(list(self.selected_tags))
        self.close()
        super().focusOutEvent(event)
        
    def show_at_cursor(self):
        cursor_pos = QCursor.pos()
        screen_geo = self.screen().geometry()
        
        x = cursor_pos.x() + 10
        y = cursor_pos.y() + 10
        
        if x + self.width() > screen_geo.right():
            x = cursor_pos.x() - self.width() - 10
            
        if y + self.height() > screen_geo.bottom():
            y = screen_geo.bottom() - self.height() - 10
            
        self.move(x, y)
        self.show()
        self.raise_()
        self.activateWindow()
        self.setFocus()
```

## 文件: ui\__init__.py

```python
﻿# -*- coding: utf-8 -*-

```

## 文件: ui\components\rich_text_edit.py

```python
from PyQt5.QtWidgets import QTextEdit, QRubberBand, QMenu, QAction
from PyQt5.QtGui import QImage, QColor, QTextCharFormat, QTextCursor, QPainter, QMouseEvent, QTextImageFormat, QTextListFormat, QTextBlockFormat
from PyQt5.QtCore import Qt, QByteArray, QBuffer, QIODevice, QSize, QPoint, QRect

class ImageResizer(QRubberBand):
    def __init__(self, parent=None, cursor=None, image_format=None):
        super().__init__(QRubberBand.Rectangle, parent)
        self.editor = parent
        self.cursor = cursor  # 指向图片的 TextCursor
        self.image_format = image_format
        self.current_image_name = image_format.name()
        
        # 初始尺寸
        self.original_width = image_format.width()
        self.original_height = image_format.height()
        self.aspect_ratio = self.original_height / self.original_width if self.original_width > 0 else 1.0
        
        # 拖拽状态
        self.dragging = False
        self.drag_start_pos = QPoint()
        self.start_rect = QRect()
        
        self.show()
        self.update_geometry()

    def update_geometry(self):
        # 根据 cursor 计算图片在 viewport 中的位置
        rect = self.editor.cursorRect(self.cursor)
        # cursorRect 返回的是光标位置（一条线），我们需要图片的实际矩形
        # 实际上对于 ImageResource，我们需要更复杂的计算，或者利用 cursorRect 的位置
        # 这里简化：假设我们已知宽高
        w = int(self.image_format.width())
        h = int(self.image_format.height())
        # cursorRect 通常在图片的右侧，我们需要调整
        # 但对于 Block 中的 Image，cursorRect 可能就是图片区域？
        # 不，QTextEdit 中图片通常是一个字符。
        
        # 更准确的方法是：
        # 使用 editor.cursorRect(cursor) 得到位置，然后结合 width/height
        self.setGeometry(rect.x(), rect.y(), w, h)

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            # 简单实现：点击右下角区域作为调整大小
            if (self.width() - event.pos().x() < 20) and (self.height() - event.pos().y() < 20):
                self.dragging = True
                self.drag_start_pos = event.globalPos()
                self.start_rect = self.geometry()
                event.accept()
            else:
                # 点击其他地方，可能是想取消选中或移动
                self.editor.deselect_image()
                # 转发事件给 editor? 其实不需要，并在点击外部时由 editor 处理
        
    def mouseMoveEvent(self, event):
        if self.dragging:
            delta = event.globalPos() - self.drag_start_pos
            new_w = max(50, self.start_rect.width() + delta.x())
            new_h = int(new_w * self.aspect_ratio) # 保持比例
            
            self.resize(new_w, new_h)
            event.accept()
            
    def mouseReleaseEvent(self, event):
        if self.dragging:
            self.dragging = False
            # 应用新的尺寸到文档
            self._apply_new_size()
            
    def _apply_new_size(self):
        # 更新 ImageFormat
        new_fmt = QTextImageFormat(self.image_format)
        new_fmt.setWidth(self.width())
        new_fmt.setHeight(self.height())
        new_fmt.setName(self.current_image_name) # 保持名字很重要
        
        # 我们必须操作 document
        # 使用 cursor 选中该图片字符，然后 setCharFormat (其实是 mergeCharFormat 不适用 ImageFormat 的属性更新?)
        # 实际上更新图片大小比较 tricky，最稳妥是替换
        c = QTextCursor(self.cursor)
        c.setPosition(self.cursor.position()) # 确保位置正确
        c.setPosition(self.cursor.position() + 1, QTextCursor.KeepAnchor) # 选中图片字符
        c.setCharFormat(new_fmt) # 这里可能不管用，对于 ImageFormat 需要用 mergeBlockCharFormat? 不，直接替换更好?
        
        # 更好的方法: 替换图片
        # 但为了避免重新加载闪烁，PyQt 的 QTextImageFormat 属性修改后，如果不重新 insert 可能不刷新。
        # 试试最直接的: insertImage 替换
        # c.insertImage(new_fmt) 
        # 但这样会导致 cursor 丢失。
        
        # 正确做法：
        image_name = new_fmt.name()
        self.editor.document().addResource(3, image_name, self.editor.document().resource(3, image_name)) # 刷新资源? 不
        
        c.insertImage(new_fmt)
        
        # 更新内部状态
        self.image_format = new_fmt
        self.cursor = QTextCursor(c) # 更新 cursor 位置（因为它动了）
        self.cursor.setPosition(c.position() - 1) # 回退到图片前
        
        # 重新定位 Resizer
        self.update_geometry()

    def paintEvent(self, event):
        # 绘制边框和手柄
        painter = QPainter(self)
        painter.setPen(Qt.blue)
        painter.setBrush(Qt.NoBrush)
        painter.drawRect(0, 0, self.width()-1, self.height()-1)
        
        # 右下角手柄
        painter.setBrush(Qt.blue)
        painter.drawRect(self.width()-10, self.height()-10, 10, 10)

class RichTextEdit(QTextEdit):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.image_data = None
        self.current_resizer = None

    def mousePressEvent(self, event):
        # 检测点击图片
        cursor = self.cursorForPosition(event.pos())
        fmt = cursor.charFormat()
        
        if fmt.isImageFormat():
            image_fmt = fmt.toImageFormat()
            # 选中图片
            self.select_image(cursor, image_fmt)
            return # 吞掉事件，防止光标移动导致取消选中? 
            # 或者我们只在点击确切是图片时拦截。
            
        # 点击非图片区域，取消选中
        self.deselect_image()
        super().mousePressEvent(event)

    def select_image(self, cursor, image_fmt):
        self.deselect_image()
        
        # 创建调整器
        # 注意: cursor 位置是在图片字符之前还是之后? need careful handling
        # cursorForPosition 返回的 cursor 通常在字符之间。
        # 我们需要确保 cursor 指向图片字符的开始。
        
        # 简单处理: 我们假设 clicked on image implies that the char to the right (or left) is the image.
        # But cursorForPosition is precise.
        
        # 调整 cursor 选中该图片
        # 如果是点在图片上，cursor通常在图片后面？
        # 让我们获取确切的 ImageFormat
        
        self.current_resizer = ImageResizer(self, cursor, image_fmt)
        self.current_resizer.show()

    def deselect_image(self):
        if self.current_resizer:
            self.current_resizer.close()
            self.current_resizer = None

    def keyPressEvent(self, event):
         # ESC 取消选中
        if event.key() == Qt.Key_Escape and self.current_resizer:
            self.deselect_image()
            return
        super().keyPressEvent(event)
        
    def contextMenuEvent(self, event):
        # 增强右键菜单
        menu = self.createStandardContextMenu()
        
        # 检查是否点击了图片
        cursor = self.cursorForPosition(event.pos())
        fmt = cursor.charFormat()
        
        if fmt.isImageFormat():
            menu.addSeparator()
            # 显式拷贝对象，防止 C++ 对象释放导致的野指针崩溃
            target_cursor = QTextCursor(cursor)
            target_fmt = QTextImageFormat(fmt.toImageFormat())
            
            restore_action = menu.addAction("还原原始大小")
            # lambda 接收 checked 参数，并使用默认参数锁定对象副本
            restore_action.triggered.connect(lambda checked=False, c=target_cursor, f=target_fmt: self._restore_image_size(c, f))
            
        menu.exec_(event.globalPos())
        
    def _restore_image_size(self, cursor, image_fmt):
        try:
            image_name = image_fmt.name()
            # 3 = QTextDocument.ImageResource
            image_variant = self.document().resource(3, image_name)
            
            if not image_variant:
                return
                
            # PyQt5 中 resource 可能返回 QVariant，需要解包
            image = image_variant
            if hasattr(image, 'toImage'): # 如果是 QVariant
                image = image.toImage()
                
            # 再次检查
            if not isinstance(image, QImage) or image.isNull():
                return
            
            new_fmt = QTextImageFormat(image_fmt)
            new_fmt.setWidth(image.width())
            new_fmt.setHeight(image.height())
            new_fmt.setName(image_name) # 确保名字一致
            
            c = QTextCursor(cursor)
            # 确保光标位置有效
            if c.position() < self.document().characterCount():
                c.setPosition(cursor.position())
                c.setPosition(cursor.position() + 1, QTextCursor.KeepAnchor)
                c.insertImage(new_fmt)
                
            self.deselect_image()
        except Exception as e:
            pass

    def highlight_selection(self, color_str):
        cursor = self.textCursor()
        if not cursor.hasSelection():
            return
            
        fmt = QTextCharFormat()
        if not color_str:
            fmt.setBackground(Qt.transparent)
        else:
            fmt.setBackground(QColor(color_str))
            
        cursor.mergeCharFormat(fmt)
        self.setTextCursor(cursor)

    def canInsertFromMimeData(self, source):
        return source.hasImage() or super().canInsertFromMimeData(source)

    def insertFromMimeData(self, source):
        if source.hasImage():
            image = source.imageData()
            if isinstance(image, QImage):
                byte_array = QByteArray()
                buffer = QBuffer(byte_array)
                buffer.open(QIODevice.WriteOnly)
                image.save(buffer, "PNG")
                self.image_data = byte_array.data()

                cursor = self.textCursor()
                
                max_width = self.viewport().width() - 40
                if image.width() > max_width:
                    scale = max_width / image.width()
                    scaled_image = image.scaled(
                        int(max_width), 
                        int(image.height() * scale),
                        Qt.KeepAspectRatio,
                        Qt.SmoothTransformation
                    )
                    cursor.insertImage(scaled_image)
                else:
                    cursor.insertImage(image)
                return

        super().insertFromMimeData(source)

    def get_image_data(self):
        return self.image_data

    def set_image_data(self, data):
        self.image_data = data
        if data:
            image = QImage()
            image.loadFromData(data)
            if not image.isNull():
                self.clear()
                cursor = self.textCursor()
                max_width = self.viewport().width() - 40
                if image.width() > max_width:
                    scale = max_width / image.width()
                    scaled_image = image.scaled(
                        int(max_width),
                        int(image.height() * scale),
                        Qt.KeepAspectRatio,
                        Qt.SmoothTransformation
                    )
                    cursor.insertImage(scaled_image)
                else:
                    cursor.insertImage(image)

    def toggle_list(self, list_style):
        cursor = self.textCursor()
        cursor.beginEditBlock()
        
        current_list = cursor.currentList()
        if current_list:
             fmt = current_list.format()
             if fmt.style() == list_style:
                 # 取消列表: 将当前块格式重置
                 # 实际上比较复杂，简单做法是创建一个新的 BlockFormat
                 block_fmt = QTextBlockFormat()
                 block_fmt.setObjectIndex(-1) # 移除列表关联
                 cursor.setBlockFormat(block_fmt)
             else:
                 fmt.setStyle(list_style)
                 current_list.setFormat(fmt)
        else:
             list_fmt = QTextListFormat()
             list_fmt.setStyle(list_style)
             cursor.createList(list_fmt)
             
        cursor.endEditBlock()

```

## 文件: ui\components\search_line_edit.py

```python
# -*- coding: utf-8 -*-
# ui/components/search_line_edit.py

from PyQt5.QtWidgets import (QLineEdit, QPushButton, QHBoxLayout, QWidget, 
                             QVBoxLayout, QApplication, QLabel, QLayout, 
                             QScrollArea, QFrame, QGraphicsDropShadowEffect, QSizePolicy)
from PyQt5.QtCore import Qt, QSettings, QPoint, QRect, QSize, pyqtSignal, QPropertyAnimation, QEasingCurve
from PyQt5.QtGui import QColor, QFont, QCursor

# --- 1. 流式布局 ---
class FlowLayout(QLayout):
    def __init__(self, parent=None, margin=0, spacing=-1):
        super(FlowLayout, self).__init__(parent)
        if parent is not None:
            self.setContentsMargins(margin, margin, margin, margin)
        self.setSpacing(spacing)
        self.itemList = []

    def __del__(self):
        item = self.takeAt(0)
        while item:
            item = self.takeAt(0)

    def addItem(self, item):
        self.itemList.append(item)

    def count(self):
        return len(self.itemList)

    def itemAt(self, index):
        if 0 <= index < len(self.itemList):
            return self.itemList[index]
        return None

    def takeAt(self, index):
        if 0 <= index < len(self.itemList):
            return self.itemList.pop(index)
        return None

    def expandingDirections(self):
        return Qt.Orientations(Qt.Orientation(0))

    def hasHeightForWidth(self):
        return True

    def heightForWidth(self, width):
        height = self.doLayout(QRect(0, 0, width, 0), True)
        return height

    def setGeometry(self, rect):
        super(FlowLayout, self).setGeometry(rect)
        self.doLayout(rect, False)

    def sizeHint(self):
        return self.minimumSize()

    def minimumSize(self):
        size = QSize()
        for item in self.itemList:
            size = size.expandedTo(item.minimumSize())
        margin = self.contentsMargins()
        size += QSize(margin.left() + margin.right(), margin.top() + margin.bottom())
        return size

    def doLayout(self, rect, testOnly):
        x = rect.x()
        y = rect.y()
        lineHeight = 0
        spacing = self.spacing()

        for item in self.itemList:
            wid = item.widget()
            spaceX = spacing + wid.style().layoutSpacing(QSizePolicy.PushButton, QSizePolicy.PushButton, Qt.Horizontal)
            spaceY = spacing + wid.style().layoutSpacing(QSizePolicy.PushButton, QSizePolicy.PushButton, Qt.Vertical)
            
            nextX = x + item.sizeHint().width() + spaceX
            if nextX - spaceX > rect.right() and lineHeight > 0:
                x = rect.x()
                y = y + lineHeight + spaceY
                nextX = x + item.sizeHint().width() + spaceX
                lineHeight = 0

            if not testOnly:
                item.setGeometry(QRect(QPoint(x, y), item.sizeHint()))

            x = nextX
            lineHeight = max(lineHeight, item.sizeHint().height())

        return y + lineHeight - rect.y()

# --- 2. 历史记录气泡 ---
class HistoryChip(QFrame):
    clicked = pyqtSignal(str)
    deleted = pyqtSignal(str)

    def __init__(self, text, parent=None):
        super().__init__(parent)
        self.text = text
        self.setCursor(Qt.PointingHandCursor)
        self.setObjectName("HistoryChip")
        
        layout = QHBoxLayout(self)
        layout.setContentsMargins(10, 4, 4, 4)
        layout.setSpacing(6)
        
        lbl = QLabel(text)
        lbl.setStyleSheet("border: none; background: transparent; color: #DDD; font-size: 12px;")
        layout.addWidget(lbl)
        
        self.btn_del = QPushButton("×")
        self.btn_del.setFixedSize(16, 16)
        self.btn_del.setCursor(Qt.PointingHandCursor)
        self.btn_del.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #666;
                border-radius: 8px;
                font-weight: bold;
                padding-bottom: 2px;
            }
            QPushButton:hover {
                background-color: #E74C3C;
                color: white;
            }
        """)
        self.btn_del.clicked.connect(self._on_delete)
        layout.addWidget(self.btn_del)
        
        self.setStyleSheet("""
            #HistoryChip {
                background-color: #3A3A3E;
                border: 1px solid #555;
                border-radius: 12px;
            }
            #HistoryChip:hover {
                background-color: #454549;
                border-color: #4a90e2;
            }
        """)

    def mousePressEvent(self, e):
        if e.button() == Qt.LeftButton and not self.btn_del.underMouse():
            self.clicked.emit(self.text)
        super().mousePressEvent(e)

    def _on_delete(self):
        self.deleted.emit(self.text)

# --- 3. 现代感弹窗 (完美对齐版) ---
class SearchHistoryPopup(QWidget):
    item_selected = pyqtSignal(str)
    
    def __init__(self, search_edit):
        super().__init__(search_edit.window()) 
        self.search_edit = search_edit
        self.settings = QSettings("KMain_V3", "SearchHistory")
        
        # 阴影边距设置 (左右下各留空间，上方少留一点)
        self.shadow_margin = 12 
        
        self.setWindowFlags(Qt.Popup | Qt.FramelessWindowHint | Qt.NoDropShadowWindowHint)
        self.setAttribute(Qt.WA_TranslucentBackground)
        
        # 使用根布局来管理边距，确保容器居中，阴影不被切
        self.root_layout = QVBoxLayout(self)
        self.root_layout.setContentsMargins(self.shadow_margin, self.shadow_margin, self.shadow_margin, self.shadow_margin)
        
        # 主容器
        self.container = QWidget()
        self.container.setObjectName("PopupContainer")
        self.container.setStyleSheet("""
            #PopupContainer {
                background-color: #252526;
                border: 1px solid #444;
                border-radius: 10px;
            }
        """)
        self.root_layout.addWidget(self.container)
        
        # 阴影
        shadow = QGraphicsDropShadowEffect(self.container)
        shadow.setBlurRadius(20)
        shadow.setXOffset(0)
        shadow.setYOffset(5)
        shadow.setColor(QColor(0, 0, 0, 120))
        self.container.setGraphicsEffect(shadow)
        
        # 内容布局
        layout = QVBoxLayout(self.container)
        layout.setContentsMargins(12, 12, 12, 12)
        layout.setSpacing(10)
        
        # 顶部栏
        top_layout = QHBoxLayout()
        lbl_title = QLabel("🕒 搜索历史")
        lbl_title.setStyleSheet("color: #888; font-weight: bold; font-size: 11px; background: transparent; border: none;")
        top_layout.addWidget(lbl_title)
        
        top_layout.addStretch()
        
        btn_clear = QPushButton("清空")
        btn_clear.setCursor(Qt.PointingHandCursor)
        btn_clear.setStyleSheet("""
            QPushButton { background: transparent; color: #666; border: none; font-size: 11px; }
            QPushButton:hover { color: #E74C3C; }
        """)
        btn_clear.clicked.connect(self._clear_all)
        top_layout.addWidget(btn_clear)
        
        layout.addLayout(top_layout)
        
        # 滚动区域
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        # 强制全透明背景
        scroll.setStyleSheet("""
            QScrollArea { background-color: transparent; border: none; }
            QScrollArea > QWidget > QWidget { background-color: transparent; }
            QScrollBar:vertical { background: #252526; width: 6px; margin: 0; }
            QScrollBar::handle:vertical { background: #444; border-radius: 3px; min-height: 20px; }
            QScrollBar::handle:vertical:hover { background: #555; }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical { height: 0; }
        """)
        scroll.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        
        self.chips_widget = QWidget()
        self.chips_widget.setStyleSheet("background-color: transparent;")
        self.flow_layout = FlowLayout(self.chips_widget, margin=0, spacing=8)
        scroll.setWidget(self.chips_widget)
        
        layout.addWidget(scroll)
        
        self.opacity_anim = QPropertyAnimation(self, b"windowOpacity")
        
        self.refresh_ui()

    def refresh_ui(self):
        while self.flow_layout.count():
            item = self.flow_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
                
        history = self.search_edit.get_history()
        
        # 【核心修正】强制宽度与输入框一致
        target_content_width = self.search_edit.width()
        
        if not history:
            lbl_empty = QLabel("暂无历史记录")
            lbl_empty.setAlignment(Qt.AlignCenter)
            lbl_empty.setStyleSheet("color: #555; font-style: italic; margin: 20px; background: transparent; border: none;")
            self.flow_layout.addWidget(lbl_empty)
            content_height = 100
        else:
            for text in history:
                chip = HistoryChip(text)
                chip.clicked.connect(self._on_chip_clicked)
                chip.deleted.connect(self._on_chip_deleted)
                self.flow_layout.addWidget(chip)
            
            # 计算高度：内容宽度 = 容器宽度 - 内部边距(24) - 滚动条预留(6)
            effective_width = target_content_width - 30
            flow_height = self.flow_layout.heightForWidth(effective_width)
            content_height = min(400, max(120, flow_height + 50)) # 加上顶部栏高度

        # 计算窗口总尺寸：内容尺寸 + 阴影边距
        total_width = target_content_width + (self.shadow_margin * 2)
        total_height = content_height + (self.shadow_margin * 2)
        
        self.resize(total_width, total_height)

    def _on_chip_clicked(self, text):
        self.item_selected.emit(text)
        self.close()

    def _on_chip_deleted(self, text):
        self.search_edit.remove_history_entry(text)
        self.refresh_ui()

    def _clear_all(self):
        self.search_edit.clear_history()
        self.refresh_ui()

    def show_animated(self):
        self.refresh_ui()
        
        # 【核心修正】坐标对齐逻辑
        # 1. 获取输入框左下角坐标
        pos = self.search_edit.mapToGlobal(QPoint(0, self.search_edit.height()))
        
        # 2. 偏移坐标：X轴减去阴影边距，Y轴加上间距并减去阴影边距
        # 这样 Container 的左边框就会和 Input 的左边框完全对齐
        x_pos = pos.x() - self.shadow_margin
        y_pos = pos.y() + 5 - self.shadow_margin # 5px 垂直间距
        
        self.move(x_pos, y_pos)
        
        self.setWindowOpacity(0)
        self.show()
        
        self.opacity_anim.setDuration(200)
        self.opacity_anim.setStartValue(0)
        self.opacity_anim.setEndValue(1)
        self.opacity_anim.setEasingCurve(QEasingCurve.OutCubic)
        self.opacity_anim.start()

# --- 4. 搜索框本体 ---
class SearchLineEdit(QLineEdit):
    SETTINGS_KEY = "SearchHistoryList"
    MAX_HISTORY = 30

    def __init__(self, parent=None):
        super().__init__(parent)
        self.settings = QSettings("KMain_V3", "KMain_V3")
        self.popup = None

    def mouseDoubleClickEvent(self, event):
        if event.button() == Qt.LeftButton:
            self._show_popup()
        super().mouseDoubleClickEvent(event)

    def _show_popup(self):
        if self.popup and self.popup.isVisible():
            self.popup.close()
            return
            
        self.popup = SearchHistoryPopup(self)
        self.popup.item_selected.connect(self._on_history_selected)
        self.popup.show_animated()

    def _on_history_selected(self, text):
        self.setText(text)
        self.returnPressed.emit()

    def add_history_entry(self, text):
        if not text or not text.strip(): return
        text = text.strip()
        history = self.get_history()
        
        if text in history:
            history.remove(text)
        history.insert(0, text)
        
        if len(history) > self.MAX_HISTORY:
            history = history[:self.MAX_HISTORY]
            
        self.settings.setValue(self.SETTINGS_KEY, history)

    def remove_history_entry(self, text):
        history = self.get_history()
        if text in history:
            history.remove(text)
            self.settings.setValue(self.SETTINGS_KEY, history)

    def clear_history(self):
        self.settings.setValue(self.SETTINGS_KEY, [])

    def get_history(self):
        val = self.settings.value(self.SETTINGS_KEY, [])
        if not isinstance(val, list): return []
        return [str(v) for v in val]
```

## 文件: ui\components\syntax_highlighter.py

```python
# -*- coding: utf-8 -*-
# ui/components/syntax_highlighter.py

from PyQt5.QtGui import QSyntaxHighlighter, QTextCharFormat, QColor, QFont
from PyQt5.QtCore import QRegExp

class SimpleHighlighter(QSyntaxHighlighter):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.highlightingRules = []

        # 1. 关键词 (蓝色)
        keywordFormat = QTextCharFormat()
        keywordFormat.setForeground(QColor("#569CD6")) 
        keywordFormat.setFontWeight(QFont.Bold)
        keywords = [
            "def", "class", "if", "else", "elif", "try", "except", "return", 
            "import", "from", "while", "for", "in", "True", "False", "None", 
            "and", "or", "not", "lambda", "with", "as", "pass", "break",
            "print", "range", "len", "self", "super"
        ]
        for word in keywords:
            pattern = QRegExp(r"\b" + word + r"\b")
            self.highlightingRules.append((pattern, keywordFormat))

        # 2. 字符串 (橙红色)
        stringFormat = QTextCharFormat()
        stringFormat.setForeground(QColor("#CE9178"))
        self.highlightingRules.append((QRegExp(r"\".*\""), stringFormat))
        self.highlightingRules.append((QRegExp(r"'.*'"), stringFormat))

        # 3. 注释 (绿色)
        commentFormat = QTextCharFormat()
        commentFormat.setForeground(QColor("#6A9955"))
        self.highlightingRules.append((QRegExp(r"#[^\n]*"), commentFormat))
        self.highlightingRules.append((QRegExp(r"//[^\n]*"), commentFormat))
        
        # 4. 数字 (浅绿色)
        numberFormat = QTextCharFormat()
        numberFormat.setForeground(QColor("#B5CEA8"))
        self.highlightingRules.append((QRegExp(r"\b[0-9]+\b"), numberFormat))
        
        # 5. 函数调用 (黄色)
        functionFormat = QTextCharFormat()
        functionFormat.setForeground(QColor("#DCDCAA"))
        self.highlightingRules.append((QRegExp(r"\b[A-Za-z0-9_]+(?=\()"), functionFormat))

    def highlightBlock(self, text):
        for pattern, format in self.highlightingRules:
            expression = QRegExp(pattern)
            index = expression.indexIn(text)
            while index >= 0:
                length = expression.matchedLength()
                self.setFormat(index, length, format)
                index = expression.indexIn(text, index + length)
```

