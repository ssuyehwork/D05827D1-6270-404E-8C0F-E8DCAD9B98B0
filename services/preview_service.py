# -*- coding: utf-8 -*-# services/preview_service.pyimport os  # 【新增】用于检测文件路径from PyQt5.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QLabel, QTextEdit,                              QWidget, QDesktopWidget, QShortcut, QPushButton,                              QGraphicsDropShadowEffect, QSizePolicy, QStyle)from PyQt5.QtCore import Qt, QPoint, QSize, QEvent, QRectfrom PyQt5.QtGui import QPixmap, QKeySequence, QFont, QColor, QPainter, QIconfrom core.config import COLORS, STYLESclass ScalableImageLabel(QLabel):    """    智能图片标签：    支持随窗口大小变化自动缩放图片，保持比例并居中。    """    def __init__(self, pixmap, parent=None):        super().__init__(parent)        self._original_pixmap = pixmap        self.setSizePolicy(QSizePolicy.Ignored, QSizePolicy.Ignored)        self.setAlignment(Qt.AlignCenter)        self.setMinimumSize(200, 200)    def set_pixmap(self, pixmap):        self._original_pixmap = pixmap        self.update()    def paintEvent(self, event):        if not self._original_pixmap or self._original_pixmap.isNull():            super().paintEvent(event)            return        painter = QPainter(self)        painter.setRenderHint(QPainter.Antialiasing)        painter.setRenderHint(QPainter.SmoothPixmapTransform)        # 计算缩放后的尺寸，保持纵横比        scaled_size = self._original_pixmap.size().scaled(self.size(), Qt.KeepAspectRatio)                # 计算居中位置        x = (self.width() - scaled_size.width()) // 2        y = (self.height() - scaled_size.height()) // 2                # 绘制        target_rect = QRect(x, y, scaled_size.width(), scaled_size.height())        painter.drawPixmap(target_rect, self._original_pixmap)class PreviewDialog(QDialog):    """    增强版预览窗口：支持拖动、最大化、最小化、自适应缩放    """    def __init__(self, item_type, data, parent=None):        super().__init__(parent)        # 普通无边框窗口，支持最小化和任务栏显示        self.setWindowFlags(Qt.FramelessWindowHint | Qt.Window)        self.setAttribute(Qt.WA_TranslucentBackground)        self.setAttribute(Qt.WA_DeleteOnClose)                 # 拖动相关变量        self._drag_pos = None        self._is_maximized = False        self._original_geometry = None                self._init_ui(item_type, data)        self._setup_shortcuts()    def _init_ui(self, item_type, data):        # 1. 根布局（用于容纳阴影）        root_layout = QVBoxLayout(self)        root_layout.setContentsMargins(10, 10, 10, 10) # 留出阴影边距        # 2. 主容器        self.container = QWidget()        self.container.setObjectName("PreviewContainer")        self.container.setStyleSheet(f"""            QWidget#PreviewContainer {{                background-color: {COLORS['bg_dark']};                border: 1px solid {COLORS['bg_light']};                border-radius: 8px;            }}        """)                # 添加阴影        shadow = QGraphicsDropShadowEffect(self)        shadow.setBlurRadius(20)        shadow.setXOffset(0)        shadow.setYOffset(5)        shadow.setColor(QColor(0, 0, 0, 150))        self.container.setGraphicsEffect(shadow)                root_layout.addWidget(self.container)        # 3. 内容布局        content_layout = QVBoxLayout(self.container)        content_layout.setContentsMargins(0, 0, 0, 0)        content_layout.setSpacing(0)        # 4. 自定义标题栏        title_bar = self._create_title_bar(item_type)        content_layout.addWidget(title_bar)        # 5. 内容区域        self.content_area = QWidget()        self.content_layout = QVBoxLayout(self.content_area)        self.content_layout.setContentsMargins(15, 5, 15, 15)                if item_type == 'text':            self._setup_text_preview(self.content_layout, data)        elif item_type == 'image':            self._setup_image_preview(self.content_layout, data)                    content_layout.addWidget(self.content_area, 1) # content_area 占据剩余空间        # 6. 底部提示条        status_bar = QLabel("按 [Space] 或 [Esc] 快速关闭")        status_bar.setAlignment(Qt.AlignCenter)        status_bar.setStyleSheet(f"color: {COLORS['text_sub']}; font-size: 10px; padding-bottom: 5px; border: none; background: transparent;")        content_layout.addWidget(status_bar)    def _create_title_bar(self, item_type):        """创建包含图标、标题和窗口控制按钮的标题栏"""        title_bar = QWidget()        title_bar.setFixedHeight(36)        title_bar.setStyleSheet(f"""            QWidget {{                background-color: {COLORS['bg_mid']};                border-top-left-radius: 8px;                border-top-right-radius: 8px;                border-bottom: 1px solid {COLORS['bg_light']};            }}        """)                layout = QHBoxLayout(title_bar)        layout.setContentsMargins(10, 0, 10, 0)                # 图标和标题        icon_char = "🖼️" if item_type == 'image' else "📝"        title_label = QLabel(f"{icon_char} 内容预览")        title_label.setStyleSheet("font-weight: bold; color: #ddd; border: none; background: transparent;")        layout.addWidget(title_label)        layout.addStretch()        # 窗口控制按钮样式        btn_style = """            QPushButton {                background: transparent;                border: none;                color: #aaa;                border-radius: 4px;                font-family: Arial;                font-size: 14px;            }            QPushButton:hover { background-color: rgba(255, 255, 255, 0.1); color: white; }        """        btn_close_style = """            QPushButton { background: transparent; border: none; color: #aaa; border-radius: 4px; font-size: 16px; }            QPushButton:hover { background-color: #e74c3c; color: white; }        """        # 最小化        self.btn_min = QPushButton("─")        self.btn_min.setFixedSize(28, 28)        self.btn_min.setStyleSheet(btn_style)        self.btn_min.clicked.connect(self.showMinimized)                # 最大化/还原        self.btn_max = QPushButton("□")        self.btn_max.setFixedSize(28, 28)        self.btn_max.setStyleSheet(btn_style)        self.btn_max.clicked.connect(self._toggle_maximize)        # 关闭        self.btn_close = QPushButton("×")        self.btn_close.setFixedSize(28, 28)        self.btn_close.setStyleSheet(btn_close_style)        self.btn_close.clicked.connect(self.close)        layout.addWidget(self.btn_min)        layout.addWidget(self.btn_max)        layout.addWidget(self.btn_close)                return title_bar    def _setup_text_preview(self, layout, text_data):        self.resize(1130, 740)        text_edit = QTextEdit()        text_edit.setReadOnly(True)        text_edit.setText(text_data)        text_edit.setFont(QFont("Microsoft YaHei", 12))        text_edit.setStyleSheet(f"""            QTextEdit {{                background-color: transparent;                border: none;                color: {COLORS['text']};                selection-background-color: {COLORS['primary']};                padding: 10px;            }}        """ + STYLES.get('main_window', '').split('/* 滚动条美化 V2 */')[1] if '/* 滚动条美化 V2 */' in STYLES.get('main_window', '') else "")        layout.addWidget(text_edit)        self._center_on_screen()    def _setup_image_preview(self, layout, image_data):        pixmap = QPixmap()        pixmap.loadFromData(image_data)        if pixmap.isNull():            lbl = QLabel("❌ 图片加载失败")            lbl.setStyleSheet("color: #e74c3c; font-size: 16px; border: none;")            lbl.setAlignment(Qt.AlignCenter)            layout.addWidget(lbl)            self.resize(400, 300)        else:            # 使用自定义的智能缩放 Label            self.image_label = ScalableImageLabel(pixmap)            layout.addWidget(self.image_label)                        # 智能计算图片窗口大小            screen = QDesktopWidget().availableGeometry()            img_w, img_h = pixmap.width(), pixmap.height()                        # 如果图片很大，限制在屏幕80%；如果图片很小，保持原大但不少于400x300            target_w = min(img_w + 40, int(screen.width() * 0.8))            target_h = min(img_h + 80, int(screen.height() * 0.8))                        self.resize(max(target_w, 400), max(target_h, 300))                self._center_on_screen()    def _center_on_screen(self):        screen = QDesktopWidget().screenNumber(QDesktopWidget().cursor().pos())        center = QDesktopWidget().screenGeometry(screen).center()        self.move(center.x() - self.width() // 2, center.y() - self.height() // 2)    def _toggle_maximize(self):        if self.isMaximized():            self.showNormal()            self.btn_max.setText("□")            self.layout().setContentsMargins(10, 10, 10, 10)        else:            self.showMaximized()            self.btn_max.setText("❐")            self.layout().setContentsMargins(0, 0, 0, 0)    def _setup_shortcuts(self):        QShortcut(QKeySequence(Qt.Key_Escape), self, self.close)        QShortcut(QKeySequence(Qt.Key_Space), self, self.close)    def mousePressEvent(self, event):        if event.button() == Qt.LeftButton and event.y() < 50:            self._drag_pos = event.globalPos() - self.frameGeometry().topLeft()            event.accept()        else:            super().mousePressEvent(event)    def mouseMoveEvent(self, event):        if event.buttons() == Qt.LeftButton and self._drag_pos:            if not self.isMaximized():                self.move(event.globalPos() - self._drag_pos)                event.accept()        else:            super().mouseMoveEvent(event)    def mouseReleaseEvent(self, event):        self._drag_pos = None        super().mouseReleaseEvent(event)            def mouseDoubleClickEvent(self, event):        if event.y() < 50:            self._toggle_maximize()class PreviewService:    """    预览服务控制器    """    def __init__(self, db_manager, parent_window):        self.db = db_manager        self.parent = parent_window        self.current_dialog = None    def toggle_preview(self, selected_ids):        # 关闭逻辑        if self.current_dialog and self.current_dialog.isVisible():            self.current_dialog.close()            self.current_dialog = None            return        # 开启逻辑        if not selected_ids:            return        if len(selected_ids) != 1:            self._show_tooltip('⚠️ 只能预览单个项目')            return        idea_id = list(selected_ids)[0]        self._open_preview(idea_id)    def _open_preview(self, idea_id):        idea = self.db.get_idea(idea_id, include_blob=True)        if not idea:            return        content = idea[2]        try:            item_type = idea[10] if len(idea) > 10 else 'text'            data_blob = idea[11] if len(idea) > 11 else None        except IndexError:            item_type = 'text'            data_blob = None        preview_data = None        final_type = 'text'        # 1. 数据库中的图片二进制数据        if item_type == 'image' and data_blob:            final_type = 'image'            preview_data = data_blob                    # 2. 本地图片路径检测 (修复：如果内容是图片路径，则显示图片)        elif content and os.path.exists(content):            # 常见图片格式后缀            img_exts = {'.png', '.jpg', '.jpeg', '.bmp', '.gif', '.webp', '.ico'}            ext = os.path.splitext(content)[1].lower()                        if ext in img_exts:                try:                    with open(content, 'rb') as f:                        preview_data = f.read()                    final_type = 'image'                except Exception:                    # 读取失败，回退显示路径文本                    final_type = 'text'                    preview_data = content            else:                # 不是图片文件                final_type = 'text'                preview_data = content        # 3. 普通文本        elif content and content.strip():            final_type = 'text'            preview_data = content                else:            self._show_tooltip('⚠️ 内容为空，无法预览')            return        self.current_dialog = PreviewDialog(final_type, preview_data, self.parent)        self.current_dialog.finished.connect(self._on_dialog_closed)        self.current_dialog.show()    def _on_dialog_closed(self):        self.current_dialog = None    def _show_tooltip(self, msg):        if hasattr(self.parent, '_show_tooltip'):            self.parent._show_tooltip(msg, 1500)